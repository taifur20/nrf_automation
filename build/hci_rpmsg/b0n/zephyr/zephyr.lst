
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

01000000 <_vector_table>:
 1000000:	48 05 00 21 7d 20 00 01 d1 3c 00 01 51 20 00 01     H..!} ...<..Q ..
 1000010:	51 20 00 01 51 20 00 01 51 20 00 01 00 00 00 00     Q ..Q ..Q ......
	...
 100002c:	c5 1b 00 01 51 20 00 01 00 00 00 00 51 20 00 01     ....Q ......Q ..
 100003c:	51 20 00 01                                         Q ..

01000040 <_irq_vector_table>:
 1000040:	21 1c 00 01 21 1c 00 01 21 1c 00 01 21 1c 00 01     !...!...!...!...
 1000050:	21 1c 00 01 21 1c 00 01 21 1c 00 01 21 1c 00 01     !...!...!...!...
 1000060:	21 1c 00 01 21 1c 00 01 21 1c 00 01 21 1c 00 01     !...!...!...!...
 1000070:	21 1c 00 01 21 1c 00 01 21 1c 00 01 21 1c 00 01     !...!...!...!...
 1000080:	21 1c 00 01 21 1c 00 01 21 1c 00 01 21 1c 00 01     !...!...!...!...
 1000090:	21 1c 00 01 21 1c 00 01 21 1c 00 01 21 1c 00 01     !...!...!...!...
 10000a0:	21 1c 00 01 21 1c 00 01 21 1c 00 01 21 1c 00 01     !...!...!...!...
 10000b0:	21 1c 00 01 21 1c 00 01                             !...!...

010000b8 <_vector_end>:
	...

01000200 <m_firmware_info>:
 1000200:	de e6 1e 28 4c bb ce 8f 02 35 00 00 3c 00 00 00     ...(L....5..<...
 1000210:	0c 52 00 00 01 00 00 00 00 00 00 01 00 00 00 01     .R..............
 1000220:	ff ff 02 91 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...

Disassembly of section text:

01000240 <__aeabi_uldivmod>:
 1000240:	b953      	cbnz	r3, 1000258 <__aeabi_uldivmod+0x18>
 1000242:	b94a      	cbnz	r2, 1000258 <__aeabi_uldivmod+0x18>
 1000244:	2900      	cmp	r1, #0
 1000246:	bf08      	it	eq
 1000248:	2800      	cmpeq	r0, #0
 100024a:	bf1c      	itt	ne
 100024c:	f04f 31ff 	movne.w	r1, #4294967295
 1000250:	f04f 30ff 	movne.w	r0, #4294967295
 1000254:	f000 b80c 	b.w	1000270 <__aeabi_idiv0>
 1000258:	f1ad 0c08 	sub.w	ip, sp, #8
 100025c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 1000260:	f000 f9d0 	bl	1000604 <__udivmoddi4>
 1000264:	f8dd e004 	ldr.w	lr, [sp, #4]
 1000268:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 100026c:	b004      	add	sp, #16
 100026e:	4770      	bx	lr

01000270 <__aeabi_idiv0>:
 1000270:	4770      	bx	lr
 1000272:	bf00      	nop

01000274 <ocrypto_constant_time_equal>:
 1000274:	b430      	push	{r4, r5}
 1000276:	f04f 0300 	mov.w	r3, #0

0100027a <constant_time_equal_loop>:
 100027a:	f810 4b01 	ldrb.w	r4, [r0], #1
 100027e:	f811 5b01 	ldrb.w	r5, [r1], #1
 1000282:	3a01      	subs	r2, #1
 1000284:	ea84 0405 	eor.w	r4, r4, r5
 1000288:	ea43 0304 	orr.w	r3, r3, r4
 100028c:	d1f5      	bne.n	100027a <constant_time_equal_loop>
 100028e:	f1a3 0301 	sub.w	r3, r3, #1
 1000292:	ea4f 70d3 	mov.w	r0, r3, lsr #31
 1000296:	bc30      	pop	{r4, r5}
 1000298:	4770      	bx	lr
 100029a:	bf00      	nop

0100029c <ocrypto_constant_time_is_zero>:
 100029c:	f04f 0300 	mov.w	r3, #0

010002a0 <constant_time_is_zero_loop>:
 10002a0:	f810 2b01 	ldrb.w	r2, [r0], #1
 10002a4:	3901      	subs	r1, #1
 10002a6:	ea43 0302 	orr.w	r3, r3, r2
 10002aa:	d1f9      	bne.n	10002a0 <constant_time_is_zero_loop>
 10002ac:	f1a3 0301 	sub.w	r3, r3, #1
 10002b0:	ea4f 70d3 	mov.w	r0, r3, lsr #31
 10002b4:	4770      	bx	lr
 10002b6:	bf00      	nop

010002b8 <ocrypto_constant_time_xor>:
 10002b8:	b430      	push	{r4, r5}

010002ba <constant_time_xor_loop>:
 10002ba:	f811 4b01 	ldrb.w	r4, [r1], #1
 10002be:	f812 5b01 	ldrb.w	r5, [r2], #1
 10002c2:	406c      	eors	r4, r5
 10002c4:	f800 4b01 	strb.w	r4, [r0], #1
 10002c8:	3b01      	subs	r3, #1
 10002ca:	d1f6      	bne.n	10002ba <constant_time_xor_loop>
 10002cc:	bc30      	pop	{r4, r5}
 10002ce:	4770      	bx	lr

010002d0 <ocrypto_sha256_loop>:
 10002d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10002d4:	e890 0ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp}
 10002d8:	f100 0040 	add.w	r0, r0, #64	; 0x40
 10002dc:	f04f 0e04 	mov.w	lr, #4
 10002e0:	e059      	b.n	1000396 <sha256_loop_start>

010002e2 <sha256_loop>:
 10002e2:	b4f0      	push	{r4, r5, r6, r7}
 10002e4:	6b82      	ldr	r2, [r0, #56]	; 0x38
 10002e6:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 10002e8:	6804      	ldr	r4, [r0, #0]
 10002ea:	2505      	movs	r5, #5
 10002ec:	2624      	movs	r6, #36	; 0x24

010002ee <sha256_loop2>:
 10002ee:	5987      	ldr	r7, [r0, r6]
 10002f0:	443c      	add	r4, r7
 10002f2:	ea4f 4772 	mov.w	r7, r2, ror #17
 10002f6:	ea87 47f2 	eor.w	r7, r7, r2, ror #19
 10002fa:	ea87 2792 	eor.w	r7, r7, r2, lsr #10
 10002fe:	443c      	add	r4, r7
 1000300:	6842      	ldr	r2, [r0, #4]
 1000302:	ea4f 17f2 	mov.w	r7, r2, ror #7
 1000306:	ea87 47b2 	eor.w	r7, r7, r2, ror #18
 100030a:	ea87 07d2 	eor.w	r7, r7, r2, lsr #3
 100030e:	443c      	add	r4, r7
 1000310:	f840 4b04 	str.w	r4, [r0], #4
 1000314:	2d03      	cmp	r5, #3
 1000316:	bf08      	it	eq
 1000318:	f06f 061b 	mvneq.w	r6, #27
 100031c:	5987      	ldr	r7, [r0, r6]
 100031e:	443a      	add	r2, r7
 1000320:	ea4f 4773 	mov.w	r7, r3, ror #17
 1000324:	ea87 47f3 	eor.w	r7, r7, r3, ror #19
 1000328:	ea87 2793 	eor.w	r7, r7, r3, lsr #10
 100032c:	443a      	add	r2, r7
 100032e:	6843      	ldr	r3, [r0, #4]
 1000330:	ea4f 17f3 	mov.w	r7, r3, ror #7
 1000334:	ea87 47b3 	eor.w	r7, r7, r3, ror #18
 1000338:	ea87 07d3 	eor.w	r7, r7, r3, lsr #3
 100033c:	443a      	add	r2, r7
 100033e:	f840 2b04 	str.w	r2, [r0], #4
 1000342:	5987      	ldr	r7, [r0, r6]
 1000344:	443b      	add	r3, r7
 1000346:	ea4f 4774 	mov.w	r7, r4, ror #17
 100034a:	ea87 47f4 	eor.w	r7, r7, r4, ror #19
 100034e:	ea87 2794 	eor.w	r7, r7, r4, lsr #10
 1000352:	443b      	add	r3, r7
 1000354:	6844      	ldr	r4, [r0, #4]
 1000356:	ea4f 17f4 	mov.w	r7, r4, ror #7
 100035a:	ea87 47b4 	eor.w	r7, r7, r4, ror #18
 100035e:	ea87 07d4 	eor.w	r7, r7, r4, lsr #3
 1000362:	443b      	add	r3, r7
 1000364:	f840 3b04 	str.w	r3, [r0], #4
 1000368:	3d01      	subs	r5, #1
 100036a:	d1c0      	bne.n	10002ee <sha256_loop2>
 100036c:	f1a0 003c 	sub.w	r0, r0, #60	; 0x3c
 1000370:	6a07      	ldr	r7, [r0, #32]
 1000372:	443c      	add	r4, r7
 1000374:	ea4f 4772 	mov.w	r7, r2, ror #17
 1000378:	ea87 47f2 	eor.w	r7, r7, r2, ror #19
 100037c:	ea87 2792 	eor.w	r7, r7, r2, lsr #10
 1000380:	443c      	add	r4, r7
 1000382:	6802      	ldr	r2, [r0, #0]
 1000384:	ea4f 17f2 	mov.w	r7, r2, ror #7
 1000388:	ea87 47b2 	eor.w	r7, r7, r2, ror #18
 100038c:	ea87 07d2 	eor.w	r7, r7, r2, lsr #3
 1000390:	443c      	add	r4, r7
 1000392:	63c4      	str	r4, [r0, #60]	; 0x3c
 1000394:	bcf0      	pop	{r4, r5, r6, r7}

01000396 <sha256_loop_start>:
 1000396:	f04f 0202 	mov.w	r2, #2

0100039a <sha256_loop1>:
 100039a:	ea88 1c78 	eor.w	ip, r8, r8, ror #5
 100039e:	ea8c 4cf8 	eor.w	ip, ip, r8, ror #19
 10003a2:	eb0b 1cbc 	add.w	ip, fp, ip, ror #6
 10003a6:	ea8a 0309 	eor.w	r3, sl, r9
 10003aa:	ea03 0308 	and.w	r3, r3, r8
 10003ae:	ea83 030a 	eor.w	r3, r3, sl
 10003b2:	449c      	add	ip, r3
 10003b4:	f850 3b04 	ldr.w	r3, [r0], #4
 10003b8:	449c      	add	ip, r3
 10003ba:	f851 3b04 	ldr.w	r3, [r1], #4
 10003be:	449c      	add	ip, r3
 10003c0:	4467      	add	r7, ip
 10003c2:	ea44 0b05 	orr.w	fp, r4, r5
 10003c6:	ea0b 0b06 	and.w	fp, fp, r6
 10003ca:	ea04 0305 	and.w	r3, r4, r5
 10003ce:	ea4b 0b03 	orr.w	fp, fp, r3
 10003d2:	44e3      	add	fp, ip
 10003d4:	ea84 23f4 	eor.w	r3, r4, r4, ror #11
 10003d8:	ea83 5334 	eor.w	r3, r3, r4, ror #20
 10003dc:	eb0b 0bb3 	add.w	fp, fp, r3, ror #2
 10003e0:	ea87 1c77 	eor.w	ip, r7, r7, ror #5
 10003e4:	ea8c 4cf7 	eor.w	ip, ip, r7, ror #19
 10003e8:	eb0a 1cbc 	add.w	ip, sl, ip, ror #6
 10003ec:	ea89 0308 	eor.w	r3, r9, r8
 10003f0:	ea03 0307 	and.w	r3, r3, r7
 10003f4:	ea83 0309 	eor.w	r3, r3, r9
 10003f8:	449c      	add	ip, r3
 10003fa:	f850 3b04 	ldr.w	r3, [r0], #4
 10003fe:	449c      	add	ip, r3
 1000400:	f851 3b04 	ldr.w	r3, [r1], #4
 1000404:	449c      	add	ip, r3
 1000406:	4466      	add	r6, ip
 1000408:	ea4b 0a04 	orr.w	sl, fp, r4
 100040c:	ea0a 0a05 	and.w	sl, sl, r5
 1000410:	ea0b 0304 	and.w	r3, fp, r4
 1000414:	ea4a 0a03 	orr.w	sl, sl, r3
 1000418:	44e2      	add	sl, ip
 100041a:	ea8b 23fb 	eor.w	r3, fp, fp, ror #11
 100041e:	ea83 533b 	eor.w	r3, r3, fp, ror #20
 1000422:	eb0a 0ab3 	add.w	sl, sl, r3, ror #2
 1000426:	ea86 1c76 	eor.w	ip, r6, r6, ror #5
 100042a:	ea8c 4cf6 	eor.w	ip, ip, r6, ror #19
 100042e:	eb09 1cbc 	add.w	ip, r9, ip, ror #6
 1000432:	ea88 0307 	eor.w	r3, r8, r7
 1000436:	ea03 0306 	and.w	r3, r3, r6
 100043a:	ea83 0308 	eor.w	r3, r3, r8
 100043e:	449c      	add	ip, r3
 1000440:	f850 3b04 	ldr.w	r3, [r0], #4
 1000444:	449c      	add	ip, r3
 1000446:	f851 3b04 	ldr.w	r3, [r1], #4
 100044a:	449c      	add	ip, r3
 100044c:	4465      	add	r5, ip
 100044e:	ea4a 090b 	orr.w	r9, sl, fp
 1000452:	ea09 0904 	and.w	r9, r9, r4
 1000456:	ea0a 030b 	and.w	r3, sl, fp
 100045a:	ea49 0903 	orr.w	r9, r9, r3
 100045e:	44e1      	add	r9, ip
 1000460:	ea8a 23fa 	eor.w	r3, sl, sl, ror #11
 1000464:	ea83 533a 	eor.w	r3, r3, sl, ror #20
 1000468:	eb09 09b3 	add.w	r9, r9, r3, ror #2
 100046c:	ea85 1c75 	eor.w	ip, r5, r5, ror #5
 1000470:	ea8c 4cf5 	eor.w	ip, ip, r5, ror #19
 1000474:	eb08 1cbc 	add.w	ip, r8, ip, ror #6
 1000478:	ea87 0306 	eor.w	r3, r7, r6
 100047c:	ea03 0305 	and.w	r3, r3, r5
 1000480:	ea83 0307 	eor.w	r3, r3, r7
 1000484:	449c      	add	ip, r3
 1000486:	f850 3b04 	ldr.w	r3, [r0], #4
 100048a:	449c      	add	ip, r3
 100048c:	f851 3b04 	ldr.w	r3, [r1], #4
 1000490:	449c      	add	ip, r3
 1000492:	4464      	add	r4, ip
 1000494:	ea49 080a 	orr.w	r8, r9, sl
 1000498:	ea08 080b 	and.w	r8, r8, fp
 100049c:	ea09 030a 	and.w	r3, r9, sl
 10004a0:	ea48 0803 	orr.w	r8, r8, r3
 10004a4:	44e0      	add	r8, ip
 10004a6:	ea89 23f9 	eor.w	r3, r9, r9, ror #11
 10004aa:	ea83 5339 	eor.w	r3, r3, r9, ror #20
 10004ae:	eb08 08b3 	add.w	r8, r8, r3, ror #2
 10004b2:	ea84 1c74 	eor.w	ip, r4, r4, ror #5
 10004b6:	ea8c 4cf4 	eor.w	ip, ip, r4, ror #19
 10004ba:	eb07 1cbc 	add.w	ip, r7, ip, ror #6
 10004be:	ea86 0305 	eor.w	r3, r6, r5
 10004c2:	ea03 0304 	and.w	r3, r3, r4
 10004c6:	ea83 0306 	eor.w	r3, r3, r6
 10004ca:	449c      	add	ip, r3
 10004cc:	f850 3b04 	ldr.w	r3, [r0], #4
 10004d0:	449c      	add	ip, r3
 10004d2:	f851 3b04 	ldr.w	r3, [r1], #4
 10004d6:	449c      	add	ip, r3
 10004d8:	44e3      	add	fp, ip
 10004da:	ea48 0709 	orr.w	r7, r8, r9
 10004de:	ea07 070a 	and.w	r7, r7, sl
 10004e2:	ea08 0309 	and.w	r3, r8, r9
 10004e6:	ea47 0703 	orr.w	r7, r7, r3
 10004ea:	4467      	add	r7, ip
 10004ec:	ea88 23f8 	eor.w	r3, r8, r8, ror #11
 10004f0:	ea83 5338 	eor.w	r3, r3, r8, ror #20
 10004f4:	eb07 07b3 	add.w	r7, r7, r3, ror #2
 10004f8:	ea8b 1c7b 	eor.w	ip, fp, fp, ror #5
 10004fc:	ea8c 4cfb 	eor.w	ip, ip, fp, ror #19
 1000500:	eb06 1cbc 	add.w	ip, r6, ip, ror #6
 1000504:	ea85 0304 	eor.w	r3, r5, r4
 1000508:	ea03 030b 	and.w	r3, r3, fp
 100050c:	ea83 0305 	eor.w	r3, r3, r5
 1000510:	449c      	add	ip, r3
 1000512:	f850 3b04 	ldr.w	r3, [r0], #4
 1000516:	449c      	add	ip, r3
 1000518:	f851 3b04 	ldr.w	r3, [r1], #4
 100051c:	449c      	add	ip, r3
 100051e:	44e2      	add	sl, ip
 1000520:	ea47 0608 	orr.w	r6, r7, r8
 1000524:	ea06 0609 	and.w	r6, r6, r9
 1000528:	ea07 0308 	and.w	r3, r7, r8
 100052c:	ea46 0603 	orr.w	r6, r6, r3
 1000530:	4466      	add	r6, ip
 1000532:	ea87 23f7 	eor.w	r3, r7, r7, ror #11
 1000536:	ea83 5337 	eor.w	r3, r3, r7, ror #20
 100053a:	eb06 06b3 	add.w	r6, r6, r3, ror #2
 100053e:	ea8a 1c7a 	eor.w	ip, sl, sl, ror #5
 1000542:	ea8c 4cfa 	eor.w	ip, ip, sl, ror #19
 1000546:	eb05 1cbc 	add.w	ip, r5, ip, ror #6
 100054a:	ea84 030b 	eor.w	r3, r4, fp
 100054e:	ea03 030a 	and.w	r3, r3, sl
 1000552:	ea83 0304 	eor.w	r3, r3, r4
 1000556:	449c      	add	ip, r3
 1000558:	f850 3b04 	ldr.w	r3, [r0], #4
 100055c:	449c      	add	ip, r3
 100055e:	f851 3b04 	ldr.w	r3, [r1], #4
 1000562:	449c      	add	ip, r3
 1000564:	44e1      	add	r9, ip
 1000566:	ea46 0507 	orr.w	r5, r6, r7
 100056a:	ea05 0508 	and.w	r5, r5, r8
 100056e:	ea06 0307 	and.w	r3, r6, r7
 1000572:	ea45 0503 	orr.w	r5, r5, r3
 1000576:	4465      	add	r5, ip
 1000578:	ea86 23f6 	eor.w	r3, r6, r6, ror #11
 100057c:	ea83 5336 	eor.w	r3, r3, r6, ror #20
 1000580:	eb05 05b3 	add.w	r5, r5, r3, ror #2
 1000584:	ea89 1c79 	eor.w	ip, r9, r9, ror #5
 1000588:	ea8c 4cf9 	eor.w	ip, ip, r9, ror #19
 100058c:	eb04 1cbc 	add.w	ip, r4, ip, ror #6
 1000590:	ea8b 030a 	eor.w	r3, fp, sl
 1000594:	ea03 0309 	and.w	r3, r3, r9
 1000598:	ea83 030b 	eor.w	r3, r3, fp
 100059c:	449c      	add	ip, r3
 100059e:	f850 3b04 	ldr.w	r3, [r0], #4
 10005a2:	449c      	add	ip, r3
 10005a4:	f851 3b04 	ldr.w	r3, [r1], #4
 10005a8:	449c      	add	ip, r3
 10005aa:	44e0      	add	r8, ip
 10005ac:	ea45 0406 	orr.w	r4, r5, r6
 10005b0:	ea04 0407 	and.w	r4, r4, r7
 10005b4:	ea05 0306 	and.w	r3, r5, r6
 10005b8:	ea44 0403 	orr.w	r4, r4, r3
 10005bc:	4464      	add	r4, ip
 10005be:	ea85 23f5 	eor.w	r3, r5, r5, ror #11
 10005c2:	ea83 5335 	eor.w	r3, r3, r5, ror #20
 10005c6:	eb04 04b3 	add.w	r4, r4, r3, ror #2
 10005ca:	3a01      	subs	r2, #1
 10005cc:	f47f aee5 	bne.w	100039a <sha256_loop1>
 10005d0:	f1a0 0040 	sub.w	r0, r0, #64	; 0x40
 10005d4:	f1be 0e01 	subs.w	lr, lr, #1
 10005d8:	f47f ae83 	bne.w	10002e2 <sha256_loop>
 10005dc:	f1a0 0c40 	sub.w	ip, r0, #64	; 0x40
 10005e0:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
 10005e4:	1900      	adds	r0, r0, r4
 10005e6:	1949      	adds	r1, r1, r5
 10005e8:	1992      	adds	r2, r2, r6
 10005ea:	19db      	adds	r3, r3, r7
 10005ec:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 10005f0:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
 10005f4:	4440      	add	r0, r8
 10005f6:	4449      	add	r1, r9
 10005f8:	4452      	add	r2, sl
 10005fa:	445b      	add	r3, fp
 10005fc:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 1000600:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

01000604 <__udivmoddi4>:
 1000604:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1000608:	4607      	mov	r7, r0
 100060a:	468c      	mov	ip, r1
 100060c:	4608      	mov	r0, r1
 100060e:	9e09      	ldr	r6, [sp, #36]	; 0x24
 1000610:	4615      	mov	r5, r2
 1000612:	463c      	mov	r4, r7
 1000614:	4619      	mov	r1, r3
 1000616:	2b00      	cmp	r3, #0
 1000618:	f040 80c5 	bne.w	10007a6 <__udivmoddi4+0x1a2>
 100061c:	4282      	cmp	r2, r0
 100061e:	fab2 f782 	clz	r7, r2
 1000622:	d946      	bls.n	10006b2 <__udivmoddi4+0xae>
 1000624:	b14f      	cbz	r7, 100063a <__udivmoddi4+0x36>
 1000626:	f1c7 0e20 	rsb	lr, r7, #32
 100062a:	fa00 f307 	lsl.w	r3, r0, r7
 100062e:	40bd      	lsls	r5, r7
 1000630:	fa24 fe0e 	lsr.w	lr, r4, lr
 1000634:	40bc      	lsls	r4, r7
 1000636:	ea4e 0c03 	orr.w	ip, lr, r3
 100063a:	ea4f 4815 	mov.w	r8, r5, lsr #16
 100063e:	fa1f fe85 	uxth.w	lr, r5
 1000642:	0c22      	lsrs	r2, r4, #16
 1000644:	fbbc f9f8 	udiv	r9, ip, r8
 1000648:	fb08 c319 	mls	r3, r8, r9, ip
 100064c:	fb09 fa0e 	mul.w	sl, r9, lr
 1000650:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
 1000654:	459a      	cmp	sl, r3
 1000656:	d928      	bls.n	10006aa <__udivmoddi4+0xa6>
 1000658:	18eb      	adds	r3, r5, r3
 100065a:	f109 30ff 	add.w	r0, r9, #4294967295
 100065e:	d204      	bcs.n	100066a <__udivmoddi4+0x66>
 1000660:	459a      	cmp	sl, r3
 1000662:	d902      	bls.n	100066a <__udivmoddi4+0x66>
 1000664:	f1a9 0002 	sub.w	r0, r9, #2
 1000668:	442b      	add	r3, r5
 100066a:	eba3 030a 	sub.w	r3, r3, sl
 100066e:	b2a4      	uxth	r4, r4
 1000670:	fbb3 f2f8 	udiv	r2, r3, r8
 1000674:	fb08 3312 	mls	r3, r8, r2, r3
 1000678:	fb02 fe0e 	mul.w	lr, r2, lr
 100067c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 1000680:	45a6      	cmp	lr, r4
 1000682:	d914      	bls.n	10006ae <__udivmoddi4+0xaa>
 1000684:	192c      	adds	r4, r5, r4
 1000686:	f102 33ff 	add.w	r3, r2, #4294967295
 100068a:	d203      	bcs.n	1000694 <__udivmoddi4+0x90>
 100068c:	45a6      	cmp	lr, r4
 100068e:	d901      	bls.n	1000694 <__udivmoddi4+0x90>
 1000690:	1e93      	subs	r3, r2, #2
 1000692:	442c      	add	r4, r5
 1000694:	eba4 040e 	sub.w	r4, r4, lr
 1000698:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 100069c:	b11e      	cbz	r6, 10006a6 <__udivmoddi4+0xa2>
 100069e:	40fc      	lsrs	r4, r7
 10006a0:	2300      	movs	r3, #0
 10006a2:	6034      	str	r4, [r6, #0]
 10006a4:	6073      	str	r3, [r6, #4]
 10006a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 10006aa:	4648      	mov	r0, r9
 10006ac:	e7dd      	b.n	100066a <__udivmoddi4+0x66>
 10006ae:	4613      	mov	r3, r2
 10006b0:	e7f0      	b.n	1000694 <__udivmoddi4+0x90>
 10006b2:	b902      	cbnz	r2, 10006b6 <__udivmoddi4+0xb2>
 10006b4:	deff      	udf	#255	; 0xff
 10006b6:	bb87      	cbnz	r7, 100071a <__udivmoddi4+0x116>
 10006b8:	1a83      	subs	r3, r0, r2
 10006ba:	2101      	movs	r1, #1
 10006bc:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 10006c0:	b2aa      	uxth	r2, r5
 10006c2:	0c20      	lsrs	r0, r4, #16
 10006c4:	fbb3 fcfe 	udiv	ip, r3, lr
 10006c8:	fb0e 331c 	mls	r3, lr, ip, r3
 10006cc:	fb0c f802 	mul.w	r8, ip, r2
 10006d0:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 10006d4:	4598      	cmp	r8, r3
 10006d6:	d962      	bls.n	100079e <__udivmoddi4+0x19a>
 10006d8:	18eb      	adds	r3, r5, r3
 10006da:	f10c 30ff 	add.w	r0, ip, #4294967295
 10006de:	d204      	bcs.n	10006ea <__udivmoddi4+0xe6>
 10006e0:	4598      	cmp	r8, r3
 10006e2:	d902      	bls.n	10006ea <__udivmoddi4+0xe6>
 10006e4:	f1ac 0002 	sub.w	r0, ip, #2
 10006e8:	442b      	add	r3, r5
 10006ea:	eba3 0308 	sub.w	r3, r3, r8
 10006ee:	b2a4      	uxth	r4, r4
 10006f0:	fbb3 fcfe 	udiv	ip, r3, lr
 10006f4:	fb0e 331c 	mls	r3, lr, ip, r3
 10006f8:	fb0c f202 	mul.w	r2, ip, r2
 10006fc:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 1000700:	42a2      	cmp	r2, r4
 1000702:	d94e      	bls.n	10007a2 <__udivmoddi4+0x19e>
 1000704:	192c      	adds	r4, r5, r4
 1000706:	f10c 33ff 	add.w	r3, ip, #4294967295
 100070a:	d204      	bcs.n	1000716 <__udivmoddi4+0x112>
 100070c:	42a2      	cmp	r2, r4
 100070e:	d902      	bls.n	1000716 <__udivmoddi4+0x112>
 1000710:	f1ac 0302 	sub.w	r3, ip, #2
 1000714:	442c      	add	r4, r5
 1000716:	1aa4      	subs	r4, r4, r2
 1000718:	e7be      	b.n	1000698 <__udivmoddi4+0x94>
 100071a:	f1c7 0c20 	rsb	ip, r7, #32
 100071e:	40bd      	lsls	r5, r7
 1000720:	fa00 f307 	lsl.w	r3, r0, r7
 1000724:	fa20 f80c 	lsr.w	r8, r0, ip
 1000728:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 100072c:	fa24 fc0c 	lsr.w	ip, r4, ip
 1000730:	40bc      	lsls	r4, r7
 1000732:	ea4c 0203 	orr.w	r2, ip, r3
 1000736:	b2ab      	uxth	r3, r5
 1000738:	fbb8 fcfe 	udiv	ip, r8, lr
 100073c:	0c11      	lsrs	r1, r2, #16
 100073e:	fb0e 801c 	mls	r0, lr, ip, r8
 1000742:	fb0c f903 	mul.w	r9, ip, r3
 1000746:	ea41 4000 	orr.w	r0, r1, r0, lsl #16
 100074a:	4581      	cmp	r9, r0
 100074c:	d923      	bls.n	1000796 <__udivmoddi4+0x192>
 100074e:	1828      	adds	r0, r5, r0
 1000750:	f10c 31ff 	add.w	r1, ip, #4294967295
 1000754:	d204      	bcs.n	1000760 <__udivmoddi4+0x15c>
 1000756:	4581      	cmp	r9, r0
 1000758:	d902      	bls.n	1000760 <__udivmoddi4+0x15c>
 100075a:	f1ac 0102 	sub.w	r1, ip, #2
 100075e:	4428      	add	r0, r5
 1000760:	eba0 0009 	sub.w	r0, r0, r9
 1000764:	b292      	uxth	r2, r2
 1000766:	fbb0 fcfe 	udiv	ip, r0, lr
 100076a:	fb0e 001c 	mls	r0, lr, ip, r0
 100076e:	fb0c f803 	mul.w	r8, ip, r3
 1000772:	ea42 4300 	orr.w	r3, r2, r0, lsl #16
 1000776:	4598      	cmp	r8, r3
 1000778:	d90f      	bls.n	100079a <__udivmoddi4+0x196>
 100077a:	18eb      	adds	r3, r5, r3
 100077c:	f10c 32ff 	add.w	r2, ip, #4294967295
 1000780:	d204      	bcs.n	100078c <__udivmoddi4+0x188>
 1000782:	4598      	cmp	r8, r3
 1000784:	d902      	bls.n	100078c <__udivmoddi4+0x188>
 1000786:	f1ac 0202 	sub.w	r2, ip, #2
 100078a:	442b      	add	r3, r5
 100078c:	eba3 0308 	sub.w	r3, r3, r8
 1000790:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
 1000794:	e792      	b.n	10006bc <__udivmoddi4+0xb8>
 1000796:	4661      	mov	r1, ip
 1000798:	e7e2      	b.n	1000760 <__udivmoddi4+0x15c>
 100079a:	4662      	mov	r2, ip
 100079c:	e7f6      	b.n	100078c <__udivmoddi4+0x188>
 100079e:	4660      	mov	r0, ip
 10007a0:	e7a3      	b.n	10006ea <__udivmoddi4+0xe6>
 10007a2:	4663      	mov	r3, ip
 10007a4:	e7b7      	b.n	1000716 <__udivmoddi4+0x112>
 10007a6:	4283      	cmp	r3, r0
 10007a8:	d905      	bls.n	10007b6 <__udivmoddi4+0x1b2>
 10007aa:	b10e      	cbz	r6, 10007b0 <__udivmoddi4+0x1ac>
 10007ac:	e9c6 7000 	strd	r7, r0, [r6]
 10007b0:	2100      	movs	r1, #0
 10007b2:	4608      	mov	r0, r1
 10007b4:	e777      	b.n	10006a6 <__udivmoddi4+0xa2>
 10007b6:	fab3 f183 	clz	r1, r3
 10007ba:	b981      	cbnz	r1, 10007de <__udivmoddi4+0x1da>
 10007bc:	4283      	cmp	r3, r0
 10007be:	d301      	bcc.n	10007c4 <__udivmoddi4+0x1c0>
 10007c0:	42ba      	cmp	r2, r7
 10007c2:	d80a      	bhi.n	10007da <__udivmoddi4+0x1d6>
 10007c4:	1abc      	subs	r4, r7, r2
 10007c6:	eb60 0303 	sbc.w	r3, r0, r3
 10007ca:	2001      	movs	r0, #1
 10007cc:	469c      	mov	ip, r3
 10007ce:	2e00      	cmp	r6, #0
 10007d0:	d067      	beq.n	10008a2 <__udivmoddi4+0x29e>
 10007d2:	e9c6 4c00 	strd	r4, ip, [r6]
 10007d6:	2100      	movs	r1, #0
 10007d8:	e765      	b.n	10006a6 <__udivmoddi4+0xa2>
 10007da:	4608      	mov	r0, r1
 10007dc:	e7f7      	b.n	10007ce <__udivmoddi4+0x1ca>
 10007de:	f1c1 0c20 	rsb	ip, r1, #32
 10007e2:	408b      	lsls	r3, r1
 10007e4:	fa02 f501 	lsl.w	r5, r2, r1
 10007e8:	fa22 f40c 	lsr.w	r4, r2, ip
 10007ec:	fa20 fb0c 	lsr.w	fp, r0, ip
 10007f0:	fa27 f20c 	lsr.w	r2, r7, ip
 10007f4:	408f      	lsls	r7, r1
 10007f6:	431c      	orrs	r4, r3
 10007f8:	fa00 f301 	lsl.w	r3, r0, r1
 10007fc:	ea4f 4914 	mov.w	r9, r4, lsr #16
 1000800:	4313      	orrs	r3, r2
 1000802:	fa1f fe84 	uxth.w	lr, r4
 1000806:	0c1a      	lsrs	r2, r3, #16
 1000808:	fbbb f8f9 	udiv	r8, fp, r9
 100080c:	fb09 bb18 	mls	fp, r9, r8, fp
 1000810:	fb08 fa0e 	mul.w	sl, r8, lr
 1000814:	ea42 420b 	orr.w	r2, r2, fp, lsl #16
 1000818:	4592      	cmp	sl, r2
 100081a:	d93e      	bls.n	100089a <__udivmoddi4+0x296>
 100081c:	18a2      	adds	r2, r4, r2
 100081e:	f108 30ff 	add.w	r0, r8, #4294967295
 1000822:	d204      	bcs.n	100082e <__udivmoddi4+0x22a>
 1000824:	4592      	cmp	sl, r2
 1000826:	d902      	bls.n	100082e <__udivmoddi4+0x22a>
 1000828:	f1a8 0002 	sub.w	r0, r8, #2
 100082c:	4422      	add	r2, r4
 100082e:	eba2 020a 	sub.w	r2, r2, sl
 1000832:	b29b      	uxth	r3, r3
 1000834:	fbb2 f8f9 	udiv	r8, r2, r9
 1000838:	fb09 2218 	mls	r2, r9, r8, r2
 100083c:	fb08 fe0e 	mul.w	lr, r8, lr
 1000840:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
 1000844:	4596      	cmp	lr, r2
 1000846:	d92a      	bls.n	100089e <__udivmoddi4+0x29a>
 1000848:	18a2      	adds	r2, r4, r2
 100084a:	f108 33ff 	add.w	r3, r8, #4294967295
 100084e:	d204      	bcs.n	100085a <__udivmoddi4+0x256>
 1000850:	4596      	cmp	lr, r2
 1000852:	d902      	bls.n	100085a <__udivmoddi4+0x256>
 1000854:	f1a8 0302 	sub.w	r3, r8, #2
 1000858:	4422      	add	r2, r4
 100085a:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 100085e:	eba2 020e 	sub.w	r2, r2, lr
 1000862:	fba0 9305 	umull	r9, r3, r0, r5
 1000866:	429a      	cmp	r2, r3
 1000868:	46ce      	mov	lr, r9
 100086a:	4698      	mov	r8, r3
 100086c:	d302      	bcc.n	1000874 <__udivmoddi4+0x270>
 100086e:	d106      	bne.n	100087e <__udivmoddi4+0x27a>
 1000870:	454f      	cmp	r7, r9
 1000872:	d204      	bcs.n	100087e <__udivmoddi4+0x27a>
 1000874:	3801      	subs	r0, #1
 1000876:	ebb9 0e05 	subs.w	lr, r9, r5
 100087a:	eb63 0804 	sbc.w	r8, r3, r4
 100087e:	b186      	cbz	r6, 10008a2 <__udivmoddi4+0x29e>
 1000880:	ebb7 030e 	subs.w	r3, r7, lr
 1000884:	eb62 0708 	sbc.w	r7, r2, r8
 1000888:	fa07 fc0c 	lsl.w	ip, r7, ip
 100088c:	40cb      	lsrs	r3, r1
 100088e:	40cf      	lsrs	r7, r1
 1000890:	ea4c 0303 	orr.w	r3, ip, r3
 1000894:	e9c6 3700 	strd	r3, r7, [r6]
 1000898:	e79d      	b.n	10007d6 <__udivmoddi4+0x1d2>
 100089a:	4640      	mov	r0, r8
 100089c:	e7c7      	b.n	100082e <__udivmoddi4+0x22a>
 100089e:	4643      	mov	r3, r8
 10008a0:	e7db      	b.n	100085a <__udivmoddi4+0x256>
 10008a2:	4631      	mov	r1, r6
 10008a4:	e6ff      	b.n	10006a6 <__udivmoddi4+0xa2>
	...

010008a8 <ocrypto_sha256>:
 10008a8:	e92d 4df0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, fp, lr}
 10008ac:	f20f 2bd8 	addw	fp, pc, #728	; 0x2d8
 10008b0:	e9db ab00 	ldrd	sl, fp, [fp]
 10008b4:	2700      	movs	r7, #0
 10008b6:	b0b2      	sub	sp, #200	; 0xc8
 10008b8:	e9cd ab00 	strd	sl, fp, [sp]
 10008bc:	f20f 2bd0 	addw	fp, pc, #720	; 0x2d0
 10008c0:	e9db ab00 	ldrd	sl, fp, [fp]
 10008c4:	4614      	mov	r4, r2
 10008c6:	e9cd ab02 	strd	sl, fp, [sp, #8]
 10008ca:	f20f 2bcc 	addw	fp, pc, #716	; 0x2cc
 10008ce:	e9db ab00 	ldrd	sl, fp, [fp]
 10008d2:	4605      	mov	r5, r0
 10008d4:	e9cd ab04 	strd	sl, fp, [sp, #16]
 10008d8:	f20f 2bc4 	addw	fp, pc, #708	; 0x2c4
 10008dc:	e9db ab00 	ldrd	sl, fp, [fp]
 10008e0:	e9cd 7230 	strd	r7, r2, [sp, #192]	; 0xc0
 10008e4:	e9cd ab06 	strd	sl, fp, [sp, #24]
 10008e8:	2a00      	cmp	r2, #0
 10008ea:	d178      	bne.n	10009de <ocrypto_sha256+0x136>
 10008ec:	2780      	movs	r7, #128	; 0x80
 10008ee:	213a      	movs	r1, #58	; 0x3a
 10008f0:	2001      	movs	r0, #1
 10008f2:	230e      	movs	r3, #14
 10008f4:	466e      	mov	r6, sp
 10008f6:	f8cd 2081 	str.w	r2, [sp, #129]	; 0x81
 10008fa:	eb0d 0807 	add.w	r8, sp, r7
 10008fe:	f10d 0285 	add.w	r2, sp, #133	; 0x85
 1000902:	f88d 7080 	strb.w	r7, [sp, #128]	; 0x80
 1000906:	2700      	movs	r7, #0
 1000908:	2b02      	cmp	r3, #2
 100090a:	6017      	str	r7, [r2, #0]
 100090c:	d021      	beq.n	1000952 <ocrypto_sha256+0xaa>
 100090e:	2b03      	cmp	r3, #3
 1000910:	6057      	str	r7, [r2, #4]
 1000912:	d01e      	beq.n	1000952 <ocrypto_sha256+0xaa>
 1000914:	2b04      	cmp	r3, #4
 1000916:	6097      	str	r7, [r2, #8]
 1000918:	d01b      	beq.n	1000952 <ocrypto_sha256+0xaa>
 100091a:	2b05      	cmp	r3, #5
 100091c:	60d7      	str	r7, [r2, #12]
 100091e:	d018      	beq.n	1000952 <ocrypto_sha256+0xaa>
 1000920:	2b06      	cmp	r3, #6
 1000922:	6117      	str	r7, [r2, #16]
 1000924:	d015      	beq.n	1000952 <ocrypto_sha256+0xaa>
 1000926:	2b07      	cmp	r3, #7
 1000928:	6157      	str	r7, [r2, #20]
 100092a:	d012      	beq.n	1000952 <ocrypto_sha256+0xaa>
 100092c:	2b08      	cmp	r3, #8
 100092e:	6197      	str	r7, [r2, #24]
 1000930:	d00f      	beq.n	1000952 <ocrypto_sha256+0xaa>
 1000932:	2b09      	cmp	r3, #9
 1000934:	61d7      	str	r7, [r2, #28]
 1000936:	d00c      	beq.n	1000952 <ocrypto_sha256+0xaa>
 1000938:	2b0a      	cmp	r3, #10
 100093a:	6217      	str	r7, [r2, #32]
 100093c:	d009      	beq.n	1000952 <ocrypto_sha256+0xaa>
 100093e:	2b0b      	cmp	r3, #11
 1000940:	6257      	str	r7, [r2, #36]	; 0x24
 1000942:	d006      	beq.n	1000952 <ocrypto_sha256+0xaa>
 1000944:	2b0c      	cmp	r3, #12
 1000946:	6297      	str	r7, [r2, #40]	; 0x28
 1000948:	d003      	beq.n	1000952 <ocrypto_sha256+0xaa>
 100094a:	2b0e      	cmp	r3, #14
 100094c:	62d7      	str	r7, [r2, #44]	; 0x2c
 100094e:	bf08      	it	eq
 1000950:	6317      	streq	r7, [r2, #48]	; 0x30
 1000952:	ebb1 0f83 	cmp.w	r1, r3, lsl #2
 1000956:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 100095a:	d012      	beq.n	1000982 <ocrypto_sha256+0xda>
 100095c:	1c43      	adds	r3, r0, #1
 100095e:	2200      	movs	r2, #0
 1000960:	a932      	add	r1, sp, #200	; 0xc8
 1000962:	4401      	add	r1, r0
 1000964:	2b3b      	cmp	r3, #59	; 0x3b
 1000966:	f801 2c48 	strb.w	r2, [r1, #-72]
 100096a:	d00a      	beq.n	1000982 <ocrypto_sha256+0xda>
 100096c:	a932      	add	r1, sp, #200	; 0xc8
 100096e:	440b      	add	r3, r1
 1000970:	f803 2c48 	strb.w	r2, [r3, #-72]
 1000974:	2839      	cmp	r0, #57	; 0x39
 1000976:	f100 0302 	add.w	r3, r0, #2
 100097a:	bf1c      	itt	ne
 100097c:	185b      	addne	r3, r3, r1
 100097e:	f803 2c48 	strbne.w	r2, [r3, #-72]
 1000982:	0f63      	lsrs	r3, r4, #29
 1000984:	f88d 30bb 	strb.w	r3, [sp, #187]	; 0xbb
 1000988:	0d63      	lsrs	r3, r4, #21
 100098a:	f88d 30bc 	strb.w	r3, [sp, #188]	; 0xbc
 100098e:	0b63      	lsrs	r3, r4, #13
 1000990:	4641      	mov	r1, r8
 1000992:	f88d 30bd 	strb.w	r3, [sp, #189]	; 0xbd
 1000996:	4630      	mov	r0, r6
 1000998:	0963      	lsrs	r3, r4, #5
 100099a:	00e4      	lsls	r4, r4, #3
 100099c:	f88d 30be 	strb.w	r3, [sp, #190]	; 0xbe
 10009a0:	f88d 40bf 	strb.w	r4, [sp, #191]	; 0xbf
 10009a4:	f003 f808 	bl	10039b8 <sha256_blocks.constprop.0>
 10009a8:	e9dd 0100 	ldrd	r0, r1, [sp]
 10009ac:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 10009b0:	ba06      	rev	r6, r0
 10009b2:	ba14      	rev	r4, r2
 10009b4:	ba18      	rev	r0, r3
 10009b6:	ba09      	rev	r1, r1
 10009b8:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 10009bc:	ba12      	rev	r2, r2
 10009be:	6069      	str	r1, [r5, #4]
 10009c0:	612a      	str	r2, [r5, #16]
 10009c2:	ba19      	rev	r1, r3
 10009c4:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 10009c8:	ba12      	rev	r2, r2
 10009ca:	ba1b      	rev	r3, r3
 10009cc:	602e      	str	r6, [r5, #0]
 10009ce:	60ac      	str	r4, [r5, #8]
 10009d0:	60e8      	str	r0, [r5, #12]
 10009d2:	6169      	str	r1, [r5, #20]
 10009d4:	61aa      	str	r2, [r5, #24]
 10009d6:	61eb      	str	r3, [r5, #28]
 10009d8:	b032      	add	sp, #200	; 0xc8
 10009da:	e8bd 8df0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, fp, pc}
 10009de:	466e      	mov	r6, sp
 10009e0:	4630      	mov	r0, r6
 10009e2:	4688      	mov	r8, r1
 10009e4:	f002 ff8a 	bl	10038fc <sha256_blocks>
 10009e8:	1a24      	subs	r4, r4, r0
 10009ea:	4603      	mov	r3, r0
 10009ec:	eb08 0104 	add.w	r1, r8, r4
 10009f0:	2800      	cmp	r0, #0
 10009f2:	f000 80b8 	beq.w	1000b66 <ocrypto_sha256+0x2be>
 10009f6:	1e42      	subs	r2, r0, #1
 10009f8:	2a02      	cmp	r2, #2
 10009fa:	d945      	bls.n	1000a88 <ocrypto_sha256+0x1e0>
 10009fc:	f858 2004 	ldr.w	r2, [r8, r4]
 1000a00:	9220      	str	r2, [sp, #128]	; 0x80
 1000a02:	0882      	lsrs	r2, r0, #2
 1000a04:	2a01      	cmp	r2, #1
 1000a06:	d03a      	beq.n	1000a7e <ocrypto_sha256+0x1d6>
 1000a08:	6848      	ldr	r0, [r1, #4]
 1000a0a:	2a02      	cmp	r2, #2
 1000a0c:	9021      	str	r0, [sp, #132]	; 0x84
 1000a0e:	d036      	beq.n	1000a7e <ocrypto_sha256+0x1d6>
 1000a10:	6888      	ldr	r0, [r1, #8]
 1000a12:	2a03      	cmp	r2, #3
 1000a14:	9022      	str	r0, [sp, #136]	; 0x88
 1000a16:	d032      	beq.n	1000a7e <ocrypto_sha256+0x1d6>
 1000a18:	68c8      	ldr	r0, [r1, #12]
 1000a1a:	2a04      	cmp	r2, #4
 1000a1c:	9023      	str	r0, [sp, #140]	; 0x8c
 1000a1e:	d02e      	beq.n	1000a7e <ocrypto_sha256+0x1d6>
 1000a20:	6908      	ldr	r0, [r1, #16]
 1000a22:	2a05      	cmp	r2, #5
 1000a24:	9024      	str	r0, [sp, #144]	; 0x90
 1000a26:	d02a      	beq.n	1000a7e <ocrypto_sha256+0x1d6>
 1000a28:	6948      	ldr	r0, [r1, #20]
 1000a2a:	2a06      	cmp	r2, #6
 1000a2c:	9025      	str	r0, [sp, #148]	; 0x94
 1000a2e:	d026      	beq.n	1000a7e <ocrypto_sha256+0x1d6>
 1000a30:	6988      	ldr	r0, [r1, #24]
 1000a32:	2a07      	cmp	r2, #7
 1000a34:	9026      	str	r0, [sp, #152]	; 0x98
 1000a36:	d022      	beq.n	1000a7e <ocrypto_sha256+0x1d6>
 1000a38:	69c8      	ldr	r0, [r1, #28]
 1000a3a:	2a08      	cmp	r2, #8
 1000a3c:	9027      	str	r0, [sp, #156]	; 0x9c
 1000a3e:	d01e      	beq.n	1000a7e <ocrypto_sha256+0x1d6>
 1000a40:	6a08      	ldr	r0, [r1, #32]
 1000a42:	2a09      	cmp	r2, #9
 1000a44:	9028      	str	r0, [sp, #160]	; 0xa0
 1000a46:	d01a      	beq.n	1000a7e <ocrypto_sha256+0x1d6>
 1000a48:	6a48      	ldr	r0, [r1, #36]	; 0x24
 1000a4a:	2a0a      	cmp	r2, #10
 1000a4c:	9029      	str	r0, [sp, #164]	; 0xa4
 1000a4e:	d016      	beq.n	1000a7e <ocrypto_sha256+0x1d6>
 1000a50:	6a88      	ldr	r0, [r1, #40]	; 0x28
 1000a52:	2a0b      	cmp	r2, #11
 1000a54:	902a      	str	r0, [sp, #168]	; 0xa8
 1000a56:	d012      	beq.n	1000a7e <ocrypto_sha256+0x1d6>
 1000a58:	6ac8      	ldr	r0, [r1, #44]	; 0x2c
 1000a5a:	2a0c      	cmp	r2, #12
 1000a5c:	902b      	str	r0, [sp, #172]	; 0xac
 1000a5e:	d00e      	beq.n	1000a7e <ocrypto_sha256+0x1d6>
 1000a60:	6b08      	ldr	r0, [r1, #48]	; 0x30
 1000a62:	2a0d      	cmp	r2, #13
 1000a64:	902c      	str	r0, [sp, #176]	; 0xb0
 1000a66:	d00a      	beq.n	1000a7e <ocrypto_sha256+0x1d6>
 1000a68:	6b48      	ldr	r0, [r1, #52]	; 0x34
 1000a6a:	2a0e      	cmp	r2, #14
 1000a6c:	902d      	str	r0, [sp, #180]	; 0xb4
 1000a6e:	d006      	beq.n	1000a7e <ocrypto_sha256+0x1d6>
 1000a70:	2a0f      	cmp	r2, #15
 1000a72:	6b88      	ldr	r0, [r1, #56]	; 0x38
 1000a74:	bf18      	it	ne
 1000a76:	6bca      	ldrne	r2, [r1, #60]	; 0x3c
 1000a78:	902e      	str	r0, [sp, #184]	; 0xb8
 1000a7a:	bf18      	it	ne
 1000a7c:	922f      	strne	r2, [sp, #188]	; 0xbc
 1000a7e:	f023 0703 	bic.w	r7, r3, #3
 1000a82:	42bb      	cmp	r3, r7
 1000a84:	4439      	add	r1, r7
 1000a86:	d014      	beq.n	1000ab2 <ocrypto_sha256+0x20a>
 1000a88:	7808      	ldrb	r0, [r1, #0]
 1000a8a:	aa32      	add	r2, sp, #200	; 0xc8
 1000a8c:	443a      	add	r2, r7
 1000a8e:	f802 0c48 	strb.w	r0, [r2, #-72]
 1000a92:	1c7a      	adds	r2, r7, #1
 1000a94:	4293      	cmp	r3, r2
 1000a96:	d90c      	bls.n	1000ab2 <ocrypto_sha256+0x20a>
 1000a98:	a832      	add	r0, sp, #200	; 0xc8
 1000a9a:	4402      	add	r2, r0
 1000a9c:	3702      	adds	r7, #2
 1000a9e:	7848      	ldrb	r0, [r1, #1]
 1000aa0:	42bb      	cmp	r3, r7
 1000aa2:	f802 0c48 	strb.w	r0, [r2, #-72]
 1000aa6:	d904      	bls.n	1000ab2 <ocrypto_sha256+0x20a>
 1000aa8:	788a      	ldrb	r2, [r1, #2]
 1000aaa:	a932      	add	r1, sp, #200	; 0xc8
 1000aac:	440f      	add	r7, r1
 1000aae:	f807 2c48 	strb.w	r2, [r7, #-72]
 1000ab2:	2180      	movs	r1, #128	; 0x80
 1000ab4:	1c58      	adds	r0, r3, #1
 1000ab6:	aa32      	add	r2, sp, #200	; 0xc8
 1000ab8:	441a      	add	r2, r3
 1000aba:	2838      	cmp	r0, #56	; 0x38
 1000abc:	9330      	str	r3, [sp, #192]	; 0xc0
 1000abe:	f802 1c48 	strb.w	r1, [r2, #-72]
 1000ac2:	d95a      	bls.n	1000b7a <ocrypto_sha256+0x2d2>
 1000ac4:	283f      	cmp	r0, #63	; 0x3f
 1000ac6:	d82d      	bhi.n	1000b24 <ocrypto_sha256+0x27c>
 1000ac8:	2200      	movs	r2, #0
 1000aca:	a932      	add	r1, sp, #200	; 0xc8
 1000acc:	4408      	add	r0, r1
 1000ace:	2b3e      	cmp	r3, #62	; 0x3e
 1000ad0:	f103 0102 	add.w	r1, r3, #2
 1000ad4:	f800 2c48 	strb.w	r2, [r0, #-72]
 1000ad8:	d024      	beq.n	1000b24 <ocrypto_sha256+0x27c>
 1000ada:	a832      	add	r0, sp, #200	; 0xc8
 1000adc:	4401      	add	r1, r0
 1000ade:	2b3d      	cmp	r3, #61	; 0x3d
 1000ae0:	f801 2c48 	strb.w	r2, [r1, #-72]
 1000ae4:	f103 0103 	add.w	r1, r3, #3
 1000ae8:	d01c      	beq.n	1000b24 <ocrypto_sha256+0x27c>
 1000aea:	4401      	add	r1, r0
 1000aec:	2b3c      	cmp	r3, #60	; 0x3c
 1000aee:	f801 2c48 	strb.w	r2, [r1, #-72]
 1000af2:	f103 0104 	add.w	r1, r3, #4
 1000af6:	d015      	beq.n	1000b24 <ocrypto_sha256+0x27c>
 1000af8:	4401      	add	r1, r0
 1000afa:	2b3b      	cmp	r3, #59	; 0x3b
 1000afc:	f801 2c48 	strb.w	r2, [r1, #-72]
 1000b00:	f103 0105 	add.w	r1, r3, #5
 1000b04:	d00e      	beq.n	1000b24 <ocrypto_sha256+0x27c>
 1000b06:	4401      	add	r1, r0
 1000b08:	2b3a      	cmp	r3, #58	; 0x3a
 1000b0a:	f801 2c48 	strb.w	r2, [r1, #-72]
 1000b0e:	f103 0106 	add.w	r1, r3, #6
 1000b12:	d007      	beq.n	1000b24 <ocrypto_sha256+0x27c>
 1000b14:	4603      	mov	r3, r0
 1000b16:	293e      	cmp	r1, #62	; 0x3e
 1000b18:	440b      	add	r3, r1
 1000b1a:	f803 2c48 	strb.w	r2, [r3, #-72]
 1000b1e:	d101      	bne.n	1000b24 <ocrypto_sha256+0x27c>
 1000b20:	f88d 20bf 	strb.w	r2, [sp, #191]	; 0xbf
 1000b24:	f10d 0880 	add.w	r8, sp, #128	; 0x80
 1000b28:	4641      	mov	r1, r8
 1000b2a:	4630      	mov	r0, r6
 1000b2c:	f002 ff44 	bl	10039b8 <sha256_blocks.constprop.0>
 1000b30:	283a      	cmp	r0, #58	; 0x3a
 1000b32:	9c31      	ldr	r4, [sp, #196]	; 0xc4
 1000b34:	f63f af25 	bhi.w	1000982 <ocrypto_sha256+0xda>
 1000b38:	1c43      	adds	r3, r0, #1
 1000b3a:	2b3b      	cmp	r3, #59	; 0x3b
 1000b3c:	f1c0 023a 	rsb	r2, r0, #58	; 0x3a
 1000b40:	f1c0 013b 	rsb	r1, r0, #59	; 0x3b
 1000b44:	bf88      	it	hi
 1000b46:	2101      	movhi	r1, #1
 1000b48:	2a02      	cmp	r2, #2
 1000b4a:	f67f af08 	bls.w	100095e <ocrypto_sha256+0xb6>
 1000b4e:	2300      	movs	r3, #0
 1000b50:	f100 0280 	add.w	r2, r0, #128	; 0x80
 1000b54:	50b3      	str	r3, [r6, r2]
 1000b56:	088b      	lsrs	r3, r1, #2
 1000b58:	4432      	add	r2, r6
 1000b5a:	2b01      	cmp	r3, #1
 1000b5c:	f102 0204 	add.w	r2, r2, #4
 1000b60:	f47f aed1 	bne.w	1000906 <ocrypto_sha256+0x5e>
 1000b64:	e6f5      	b.n	1000952 <ocrypto_sha256+0xaa>
 1000b66:	2280      	movs	r2, #128	; 0x80
 1000b68:	9030      	str	r0, [sp, #192]	; 0xc0
 1000b6a:	213a      	movs	r1, #58	; 0x3a
 1000b6c:	2001      	movs	r0, #1
 1000b6e:	9c31      	ldr	r4, [sp, #196]	; 0xc4
 1000b70:	eb0d 0802 	add.w	r8, sp, r2
 1000b74:	f88d 2080 	strb.w	r2, [sp, #128]	; 0x80
 1000b78:	e7e9      	b.n	1000b4e <ocrypto_sha256+0x2a6>
 1000b7a:	9c31      	ldr	r4, [sp, #196]	; 0xc4
 1000b7c:	f10d 0880 	add.w	r8, sp, #128	; 0x80
 1000b80:	e7da      	b.n	1000b38 <ocrypto_sha256+0x290>
 1000b82:	bf00      	nop
 1000b84:	f3af 8000 	nop.w
 1000b88:	6a09e667 	.word	0x6a09e667
 1000b8c:	bb67ae85 	.word	0xbb67ae85
 1000b90:	3c6ef372 	.word	0x3c6ef372
 1000b94:	a54ff53a 	.word	0xa54ff53a
 1000b98:	510e527f 	.word	0x510e527f
 1000b9c:	9b05688c 	.word	0x9b05688c
 1000ba0:	1f83d9ab 	.word	0x1f83d9ab
 1000ba4:	5be0cd19 	.word	0x5be0cd19

01000ba8 <main>:
#include <dfu/pcd.h>
#include <zephyr/device.h>
#include <zephyr/devicetree.h>

void main(void)
{
 1000ba8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 1000bac:	b085      	sub	sp, #20
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
	return z_device_is_ready(dev);
 1000bae:	4832      	ldr	r0, [pc, #200]	; (1000c78 <main+0xd0>)
 1000bb0:	f003 fa4b 	bl	100404a <z_device_is_ready>
	int err;
	const struct device *fdev = DEVICE_DT_GET(DT_CHOSEN(zephyr_flash_controller));

	if (!device_is_ready(fdev)) {
 1000bb4:	b928      	cbnz	r0, 1000bc2 <main+0x1a>
		printk("Flash device not ready\n");
 1000bb6:	4831      	ldr	r0, [pc, #196]	; (1000c7c <main+0xd4>)
	bl_boot(fw_info_find(s0_addr));
	return;

failure:
	pcd_fw_copy_invalidate();
}
 1000bb8:	b005      	add	sp, #20
 1000bba:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		printk("Flash device not ready\n");
 1000bbe:	f002 bf48 	b.w	1003a52 <printk>
	err = fprotect_area(PM_B0N_CONTAINER_ADDRESS, PM_B0N_CONTAINER_SIZE);
 1000bc2:	f44f 4108 	mov.w	r1, #34816	; 0x8800
 1000bc6:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
 1000bca:	f003 f997 	bl	1003efc <fprotect_area>
	if (err) {
 1000bce:	b138      	cbz	r0, 1000be0 <main+0x38>
		printk("Failed to protect b0n flash, cancel startup\n\r");
 1000bd0:	482b      	ldr	r0, [pc, #172]	; (1000c80 <main+0xd8>)
 1000bd2:	f002 ff3e 	bl	1003a52 <printk>
}
 1000bd6:	b005      	add	sp, #20
 1000bd8:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	pcd_fw_copy_invalidate();
 1000bdc:	f002 b9c6 	b.w	1002f6c <pcd_fw_copy_invalidate>
	uint32_t s0_addr = s0_address_read();
 1000be0:	f002 f98c 	bl	1002efc <s0_address_read>
 1000be4:	4605      	mov	r5, r0
	if (pcd_fw_copy_status_get() == PCD_STATUS_COPY) {
 1000be6:	f002 f9c9 	bl	1002f7c <pcd_fw_copy_status_get>
 1000bea:	b9e8      	cbnz	r0, 1000c28 <main+0x80>
		uint32_t update_addr = (uint32_t)pcd_cmd_data_ptr_get();
 1000bec:	f003 f9fe 	bl	1003fec <pcd_cmd_data_ptr_get>
 1000bf0:	4604      	mov	r4, r0
		valid = bl_validate_firmware(s0_addr, update_addr);
 1000bf2:	4601      	mov	r1, r0
 1000bf4:	4628      	mov	r0, r5
 1000bf6:	f003 f9ab 	bl	1003f50 <bl_validate_firmware>
		if (!valid) {
 1000bfa:	b910      	cbnz	r0, 1000c02 <main+0x5a>
			printk("Unable to find valid firmware inside %p\n\r",
 1000bfc:	4621      	mov	r1, r4
			printk("Unable to find valid firmware inside %p\n\r",
 1000bfe:	4821      	ldr	r0, [pc, #132]	; (1000c84 <main+0xdc>)
 1000c00:	e005      	b.n	1000c0e <main+0x66>
		err = pcd_fw_copy(fdev);
 1000c02:	481d      	ldr	r0, [pc, #116]	; (1000c78 <main+0xd0>)
 1000c04:	f002 f9cc 	bl	1002fa0 <pcd_fw_copy>
		if (err != 0) {
 1000c08:	4601      	mov	r1, r0
 1000c0a:	b118      	cbz	r0, 1000c14 <main+0x6c>
			printk("Failed to transfer image: %d\n\r", err);
 1000c0c:	481e      	ldr	r0, [pc, #120]	; (1000c88 <main+0xe0>)
		printk("Failed to protect app flash: %d\n\r", err);
 1000c0e:	f002 ff20 	bl	1003a52 <printk>
		goto failure;
 1000c12:	e7e0      	b.n	1000bd6 <main+0x2e>
		valid = bl_validate_firmware(s0_addr, s0_addr);
 1000c14:	4629      	mov	r1, r5
 1000c16:	4628      	mov	r0, r5
 1000c18:	f003 f99a 	bl	1003f50 <bl_validate_firmware>
		if (valid) {
 1000c1c:	b110      	cbz	r0, 1000c24 <main+0x7c>
			pcd_fw_copy_done();
 1000c1e:	f002 f9fb 	bl	1003018 <pcd_fw_copy_done>
		while (1)
 1000c22:	e7fe      	b.n	1000c22 <main+0x7a>
			printk("Unable to find valid firmware inside %p\n\r",
 1000c24:	4629      	mov	r1, r5
 1000c26:	e7ea      	b.n	1000bfe <main+0x56>
	err = fprotect_area(PM_APP_ADDRESS, PM_APP_SIZE);
 1000c28:	f44f 315e 	mov.w	r1, #227328	; 0x37800
 1000c2c:	4817      	ldr	r0, [pc, #92]	; (1000c8c <main+0xe4>)
 1000c2e:	f003 f965 	bl	1003efc <fprotect_area>
	if (err) {
 1000c32:	4601      	mov	r1, r0
 1000c34:	b108      	cbz	r0, 1000c3a <main+0x92>
		printk("Failed to protect app flash: %d\n\r", err);
 1000c36:	4816      	ldr	r0, [pc, #88]	; (1000c90 <main+0xe8>)
 1000c38:	e7e9      	b.n	1000c0e <main+0x66>
 */
static inline const struct fw_info *fw_info_find(uint32_t firmware_address)
{
	const struct fw_info *finfo;

	for (uint32_t i = 0; i < FW_INFO_OFFSET_COUNT; i++) {
 1000c3a:	4604      	mov	r4, r0
 1000c3c:	f8df 9054 	ldr.w	r9, [pc, #84]	; 1000c94 <main+0xec>
	const uint32_t fw_info_magic[] = {FIRMWARE_INFO_MAGIC};
 1000c40:	f8df 8054 	ldr.w	r8, [pc, #84]	; 1000c98 <main+0xf0>
 1000c44:	af01      	add	r7, sp, #4
		finfo = fw_info_check(firmware_address +
						fw_info_allowed_offsets[i]);
 1000c46:	f859 6b04 	ldr.w	r6, [r9], #4
	const uint32_t fw_info_magic[] = {FIRMWARE_INFO_MAGIC};
 1000c4a:	e898 0007 	ldmia.w	r8, {r0, r1, r2}
	finfo = (const struct fw_info *)(fw_info_addr);
 1000c4e:	442e      	add	r6, r5
	const uint32_t fw_info_magic[] = {FIRMWARE_INFO_MAGIC};
 1000c50:	e887 0007 	stmia.w	r7, {r0, r1, r2}
	if (memcmp(finfo->magic, fw_info_magic, CONFIG_FW_INFO_MAGIC_LEN)
 1000c54:	220c      	movs	r2, #12
 1000c56:	4639      	mov	r1, r7
 1000c58:	4630      	mov	r0, r6
 1000c5a:	f003 f850 	bl	1003cfe <memcmp>
 1000c5e:	b900      	cbnz	r0, 1000c62 <main+0xba>
		if (finfo) {
 1000c60:	b91e      	cbnz	r6, 1000c6a <main+0xc2>
	for (uint32_t i = 0; i < FW_INFO_OFFSET_COUNT; i++) {
 1000c62:	3401      	adds	r4, #1
 1000c64:	2c05      	cmp	r4, #5
 1000c66:	d1ee      	bne.n	1000c46 <main+0x9e>
			return finfo;
		}
	}
	return NULL;
 1000c68:	2600      	movs	r6, #0
	bl_boot(fw_info_find(s0_addr));
 1000c6a:	4630      	mov	r0, r6
}
 1000c6c:	b005      	add	sp, #20
 1000c6e:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	bl_boot(fw_info_find(s0_addr));
 1000c72:	f001 bfed 	b.w	1002c50 <bl_boot>
 1000c76:	bf00      	nop
 1000c78:	010040c4 	.word	0x010040c4
 1000c7c:	01004418 	.word	0x01004418
 1000c80:	01004430 	.word	0x01004430
 1000c84:	0100445e 	.word	0x0100445e
 1000c88:	01004488 	.word	0x01004488
 1000c8c:	01008800 	.word	0x01008800
 1000c90:	010044a7 	.word	0x010044a7
 1000c94:	01004258 	.word	0x01004258
 1000c98:	01004210 	.word	0x01004210

01000c9c <sys_notify_finalize>:
	return rv;
}

sys_notify_generic_callback sys_notify_finalize(struct sys_notify *notify,
						    int res)
{
 1000c9c:	b538      	push	{r3, r4, r5, lr}
};

/** @internal */
static inline uint32_t sys_notify_get_method(const struct sys_notify *notify)
{
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
 1000c9e:	6844      	ldr	r4, [r0, #4]
 1000ca0:	4605      	mov	r5, r0

	return method & SYS_NOTIFY_METHOD_MASK;
 1000ca2:	f004 0403 	and.w	r4, r4, #3

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
	switch (method) {
 1000ca6:	2c03      	cmp	r4, #3
	notify->result = res;
 1000ca8:	6081      	str	r1, [r0, #8]
	switch (method) {
 1000caa:	d002      	beq.n	1000cb2 <sys_notify_finalize+0x16>
 1000cac:	b12c      	cbz	r4, 1000cba <sys_notify_finalize+0x1e>
 1000cae:	2000      	movs	r0, #0
 1000cb0:	e000      	b.n	1000cb4 <sys_notify_finalize+0x18>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		rv = notify->method.callback;
 1000cb2:	6800      	ldr	r0, [r0, #0]
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
 1000cb4:	2300      	movs	r3, #0
 1000cb6:	606b      	str	r3, [r5, #4]
	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
 1000cb8:	bd38      	pop	{r3, r4, r5, pc}
		__ASSERT_NO_MSG(false);
 1000cba:	2245      	movs	r2, #69	; 0x45
 1000cbc:	4904      	ldr	r1, [pc, #16]	; (1000cd0 <sys_notify_finalize+0x34>)
 1000cbe:	4805      	ldr	r0, [pc, #20]	; (1000cd4 <sys_notify_finalize+0x38>)
 1000cc0:	f002 ff99 	bl	1003bf6 <assert_print>
 1000cc4:	2145      	movs	r1, #69	; 0x45
 1000cc6:	4802      	ldr	r0, [pc, #8]	; (1000cd0 <sys_notify_finalize+0x34>)
 1000cc8:	f002 ff8e 	bl	1003be8 <assert_post_action>
 1000ccc:	e7ef      	b.n	1000cae <sys_notify_finalize+0x12>
 1000cce:	bf00      	nop
 1000cd0:	010044c9 	.word	0x010044c9
 1000cd4:	010044ec 	.word	0x010044ec

01000cd8 <char_out>:
}

static int char_out(int c, void *ctx_p)
{
	(void) ctx_p;
	return _char_out(c);
 1000cd8:	4b01      	ldr	r3, [pc, #4]	; (1000ce0 <char_out+0x8>)
 1000cda:	681b      	ldr	r3, [r3, #0]
 1000cdc:	4718      	bx	r3
 1000cde:	bf00      	nop
 1000ce0:	21000000 	.word	0x21000000

01000ce4 <vprintk>:
}

void vprintk(const char *fmt, va_list ap)
{
 1000ce4:	b507      	push	{r0, r1, r2, lr}
 1000ce6:	460b      	mov	r3, r1
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);
#else
static inline
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)
{
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
 1000ce8:	2100      	movs	r1, #0
 1000cea:	4602      	mov	r2, r0
 1000cec:	9100      	str	r1, [sp, #0]
 1000cee:	4803      	ldr	r0, [pc, #12]	; (1000cfc <vprintk+0x18>)
 1000cf0:	f000 f9e4 	bl	10010bc <z_cbvprintf_impl>

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
 1000cf4:	b003      	add	sp, #12
 1000cf6:	f85d fb04 	ldr.w	pc, [sp], #4
 1000cfa:	bf00      	nop
 1000cfc:	01000cd9 	.word	0x01000cd9

01000d00 <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
 1000d00:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
 1000d04:	f8b0 8018 	ldrh.w	r8, [r0, #24]
{
 1000d08:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(evt != EVT_NOP);

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
 1000d0a:	f018 0f08 	tst.w	r8, #8
{
 1000d0e:	4692      	mov	sl, r2
	if (processing) {
 1000d10:	d00e      	beq.n	1000d30 <process_event+0x30>
		if (evt == EVT_COMPLETE) {
 1000d12:	2901      	cmp	r1, #1
			mgr->flags |= ONOFF_FLAG_COMPLETE;
 1000d14:	bf0c      	ite	eq
 1000d16:	f048 0810 	orreq.w	r8, r8, #16
		} else {
			__ASSERT_NO_MSG(evt == EVT_RECHECK);

			mgr->flags |= ONOFF_FLAG_RECHECK;
 1000d1a:	f048 0820 	orrne.w	r8, r8, #32
 1000d1e:	f8a0 8018 	strh.w	r8, [r0, #24]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
 1000d22:	f38a 8811 	msr	BASEPRI, sl
 1000d26:	f3bf 8f6f 	isb	sy
		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
}
 1000d2a:	b003      	add	sp, #12
 1000d2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		__ASSERT_NO_MSG(false);
 1000d30:	4fb0      	ldr	r7, [pc, #704]	; (1000ff4 <process_event+0x2f4>)
 1000d32:	f8df 92c4 	ldr.w	r9, [pc, #708]	; 1000ff8 <process_event+0x2f8>
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
 1000d36:	f008 0807 	and.w	r8, r8, #7
		if (evt == EVT_RECHECK) {
 1000d3a:	2902      	cmp	r1, #2
 1000d3c:	d106      	bne.n	1000d4c <process_event+0x4c>
			evt = process_recheck(mgr);
 1000d3e:	4620      	mov	r0, r4
 1000d40:	f002 fe94 	bl	1003a6c <process_recheck>
		if (evt == EVT_NOP) {
 1000d44:	2800      	cmp	r0, #0
 1000d46:	d0ec      	beq.n	1000d22 <process_event+0x22>
		if (evt == EVT_COMPLETE) {
 1000d48:	2801      	cmp	r0, #1
 1000d4a:	d161      	bne.n	1000e10 <process_event+0x110>
			res = mgr->last_res;
 1000d4c:	f8d4 b014 	ldr.w	fp, [r4, #20]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
 1000d50:	8b22      	ldrh	r2, [r4, #24]
	if (res < 0) {
 1000d52:	f1bb 0f00 	cmp.w	fp, #0
 1000d56:	da17      	bge.n	1000d88 <process_event+0x88>
 *
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
 1000d58:	2600      	movs	r6, #0
		*clients = mgr->clients;
 1000d5a:	6825      	ldr	r5, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1000d5c:	f022 0207 	bic.w	r2, r2, #7
	list->tail = NULL;
 1000d60:	e9c4 6600 	strd	r6, r6, [r4]
 1000d64:	f042 0201 	orr.w	r2, r2, #1
	mgr->flags = (state & ONOFF_STATE_MASK)
 1000d68:	8322      	strh	r2, [r4, #24]
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
 1000d6a:	8b21      	ldrh	r1, [r4, #24]
 1000d6c:	f001 0207 	and.w	r2, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
 1000d70:	4542      	cmp	r2, r8
 1000d72:	d003      	beq.n	1000d7c <process_event+0x7c>
		if (do_monitors
 1000d74:	68a0      	ldr	r0, [r4, #8]
 1000d76:	2800      	cmp	r0, #0
 1000d78:	f040 80ee 	bne.w	1000f58 <process_event+0x258>
		    || !sys_slist_is_empty(&clients)
 1000d7c:	b915      	cbnz	r5, 1000d84 <process_event+0x84>
		    || (transit != NULL)) {
 1000d7e:	2e00      	cmp	r6, #0
 1000d80:	f000 8105 	beq.w	1000f8e <process_event+0x28e>
 1000d84:	2000      	movs	r0, #0
 1000d86:	e0e8      	b.n	1000f5a <process_event+0x25a>
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
 1000d88:	f002 0107 	and.w	r1, r2, #7
		   || (state == ONOFF_STATE_RESETTING)) {
 1000d8c:	1f48      	subs	r0, r1, #5
	} else if ((state == ONOFF_STATE_TO_ON)
 1000d8e:	2801      	cmp	r0, #1
 1000d90:	d820      	bhi.n	1000dd4 <process_event+0xd4>
	list->head = NULL;
 1000d92:	2000      	movs	r0, #0
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1000d94:	f022 0207 	bic.w	r2, r2, #7
		if (state == ONOFF_STATE_TO_ON) {
 1000d98:	2906      	cmp	r1, #6
		*clients = mgr->clients;
 1000d9a:	6825      	ldr	r5, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1000d9c:	b292      	uxth	r2, r2
	list->tail = NULL;
 1000d9e:	e9c4 0000 	strd	r0, r0, [r4]
		if (state == ONOFF_STATE_TO_ON) {
 1000da2:	d10a      	bne.n	1000dba <process_event+0xba>
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
 1000da4:	b13d      	cbz	r5, 1000db6 <process_event+0xb6>
 1000da6:	4628      	mov	r0, r5
 1000da8:	8b61      	ldrh	r1, [r4, #26]

#define SYS_SLIST_STATIC_INIT(ptr_to_list) {NULL, NULL}

static inline sys_snode_t *z_snode_next_peek(sys_snode_t *node)
{
	return node->next;
 1000daa:	6800      	ldr	r0, [r0, #0]
				mgr->refs += 1U;
 1000dac:	3101      	adds	r1, #1
 1000dae:	b289      	uxth	r1, r1
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
 1000db0:	2800      	cmp	r0, #0
 1000db2:	d1fa      	bne.n	1000daa <process_event+0xaa>
 1000db4:	8361      	strh	r1, [r4, #26]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1000db6:	f042 0202 	orr.w	r2, r2, #2
		if (process_recheck(mgr) != EVT_NOP) {
 1000dba:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
 1000dbc:	8322      	strh	r2, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
 1000dbe:	f002 fe55 	bl	1003a6c <process_recheck>
 1000dc2:	4606      	mov	r6, r0
 1000dc4:	2800      	cmp	r0, #0
 1000dc6:	d0d0      	beq.n	1000d6a <process_event+0x6a>
			mgr->flags |= ONOFF_FLAG_RECHECK;
 1000dc8:	8b22      	ldrh	r2, [r4, #24]
 1000dca:	f042 0220 	orr.w	r2, r2, #32
 1000dce:	8322      	strh	r2, [r4, #24]
		onoff_transition_fn transit = NULL;
 1000dd0:	2600      	movs	r6, #0
 1000dd2:	e7ca      	b.n	1000d6a <process_event+0x6a>
	} else if (state == ONOFF_STATE_TO_OFF) {
 1000dd4:	2904      	cmp	r1, #4
 1000dd6:	d10d      	bne.n	1000df4 <process_event+0xf4>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1000dd8:	f022 0207 	bic.w	r2, r2, #7
 1000ddc:	b292      	uxth	r2, r2
		if (process_recheck(mgr) != EVT_NOP) {
 1000dde:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
 1000de0:	8322      	strh	r2, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
 1000de2:	f002 fe43 	bl	1003a6c <process_recheck>
 1000de6:	4605      	mov	r5, r0
 1000de8:	b180      	cbz	r0, 1000e0c <process_event+0x10c>
			mgr->flags |= ONOFF_FLAG_RECHECK;
 1000dea:	f042 0220 	orr.w	r2, r2, #32
 1000dee:	2500      	movs	r5, #0
 1000df0:	8322      	strh	r2, [r4, #24]
 1000df2:	e7ed      	b.n	1000dd0 <process_event+0xd0>
		__ASSERT_NO_MSG(false);
 1000df4:	f240 121b 	movw	r2, #283	; 0x11b
 1000df8:	4639      	mov	r1, r7
 1000dfa:	4648      	mov	r0, r9
 1000dfc:	f002 fefb 	bl	1003bf6 <assert_print>
 1000e00:	f240 111b 	movw	r1, #283	; 0x11b
 1000e04:	4638      	mov	r0, r7
 1000e06:	f002 feef 	bl	1003be8 <assert_post_action>
 1000e0a:	2500      	movs	r5, #0
		onoff_transition_fn transit = NULL;
 1000e0c:	462e      	mov	r6, r5
 1000e0e:	e7ac      	b.n	1000d6a <process_event+0x6a>
		} else if (evt == EVT_START) {
 1000e10:	2803      	cmp	r0, #3
 1000e12:	d131      	bne.n	1000e78 <process_event+0x178>
			__ASSERT_NO_MSG(state == ONOFF_STATE_OFF);
 1000e14:	f1b8 0f00 	cmp.w	r8, #0
 1000e18:	d00a      	beq.n	1000e30 <process_event+0x130>
 1000e1a:	4639      	mov	r1, r7
 1000e1c:	4648      	mov	r0, r9
 1000e1e:	f44f 72ab 	mov.w	r2, #342	; 0x156
 1000e22:	f002 fee8 	bl	1003bf6 <assert_print>
 1000e26:	f44f 71ab 	mov.w	r1, #342	; 0x156
 1000e2a:	4638      	mov	r0, r7
 1000e2c:	f002 fedc 	bl	1003be8 <assert_post_action>
			__ASSERT_NO_MSG(!sys_slist_is_empty(&mgr->clients));
 1000e30:	6823      	ldr	r3, [r4, #0]
 1000e32:	b953      	cbnz	r3, 1000e4a <process_event+0x14a>
 1000e34:	4639      	mov	r1, r7
 1000e36:	4648      	mov	r0, r9
 1000e38:	f240 1257 	movw	r2, #343	; 0x157
 1000e3c:	f002 fedb 	bl	1003bf6 <assert_print>
 1000e40:	f240 1157 	movw	r1, #343	; 0x157
 1000e44:	4638      	mov	r0, r7
 1000e46:	f002 fecf 	bl	1003be8 <assert_post_action>
			transit = mgr->transitions->start;
 1000e4a:	6923      	ldr	r3, [r4, #16]
 1000e4c:	681e      	ldr	r6, [r3, #0]
			__ASSERT_NO_MSG(transit != NULL);
 1000e4e:	b956      	cbnz	r6, 1000e66 <process_event+0x166>
 1000e50:	4639      	mov	r1, r7
 1000e52:	4648      	mov	r0, r9
 1000e54:	f44f 72ad 	mov.w	r2, #346	; 0x15a
 1000e58:	f002 fecd 	bl	1003bf6 <assert_print>
 1000e5c:	f44f 71ad 	mov.w	r1, #346	; 0x15a
 1000e60:	4638      	mov	r0, r7
 1000e62:	f002 fec1 	bl	1003be8 <assert_post_action>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1000e66:	8b23      	ldrh	r3, [r4, #24]
 1000e68:	f023 0307 	bic.w	r3, r3, #7
 1000e6c:	f043 0306 	orr.w	r3, r3, #6
}
 1000e70:	2500      	movs	r5, #0
	mgr->flags = (state & ONOFF_STATE_MASK)
 1000e72:	8323      	strh	r3, [r4, #24]
		res = 0;
 1000e74:	46ab      	mov	fp, r5
}
 1000e76:	e778      	b.n	1000d6a <process_event+0x6a>
		} else if (evt == EVT_STOP) {
 1000e78:	2804      	cmp	r0, #4
 1000e7a:	d12e      	bne.n	1000eda <process_event+0x1da>
			__ASSERT_NO_MSG(state == ONOFF_STATE_ON);
 1000e7c:	f1b8 0f02 	cmp.w	r8, #2
 1000e80:	d00a      	beq.n	1000e98 <process_event+0x198>
 1000e82:	4639      	mov	r1, r7
 1000e84:	4648      	mov	r0, r9
 1000e86:	f240 125d 	movw	r2, #349	; 0x15d
 1000e8a:	f002 feb4 	bl	1003bf6 <assert_print>
 1000e8e:	f240 115d 	movw	r1, #349	; 0x15d
 1000e92:	4638      	mov	r0, r7
 1000e94:	f002 fea8 	bl	1003be8 <assert_post_action>
			__ASSERT_NO_MSG(mgr->refs == 0);
 1000e98:	8b63      	ldrh	r3, [r4, #26]
 1000e9a:	b153      	cbz	r3, 1000eb2 <process_event+0x1b2>
 1000e9c:	4639      	mov	r1, r7
 1000e9e:	4648      	mov	r0, r9
 1000ea0:	f44f 72af 	mov.w	r2, #350	; 0x15e
 1000ea4:	f002 fea7 	bl	1003bf6 <assert_print>
 1000ea8:	f44f 71af 	mov.w	r1, #350	; 0x15e
 1000eac:	4638      	mov	r0, r7
 1000eae:	f002 fe9b 	bl	1003be8 <assert_post_action>
			transit = mgr->transitions->stop;
 1000eb2:	6923      	ldr	r3, [r4, #16]
 1000eb4:	685e      	ldr	r6, [r3, #4]
			__ASSERT_NO_MSG(transit != NULL);
 1000eb6:	b956      	cbnz	r6, 1000ece <process_event+0x1ce>
 1000eb8:	4639      	mov	r1, r7
 1000eba:	4648      	mov	r0, r9
 1000ebc:	f240 1261 	movw	r2, #353	; 0x161
 1000ec0:	f002 fe99 	bl	1003bf6 <assert_print>
 1000ec4:	f240 1161 	movw	r1, #353	; 0x161
 1000ec8:	4638      	mov	r0, r7
 1000eca:	f002 fe8d 	bl	1003be8 <assert_post_action>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1000ece:	8b23      	ldrh	r3, [r4, #24]
 1000ed0:	f023 0307 	bic.w	r3, r3, #7
 1000ed4:	f043 0304 	orr.w	r3, r3, #4
 1000ed8:	e7ca      	b.n	1000e70 <process_event+0x170>
		} else if (evt == EVT_RESET) {
 1000eda:	2805      	cmp	r0, #5
 1000edc:	d12e      	bne.n	1000f3c <process_event+0x23c>
			__ASSERT_NO_MSG(state == ONOFF_STATE_ERROR);
 1000ede:	f1b8 0f01 	cmp.w	r8, #1
 1000ee2:	d00a      	beq.n	1000efa <process_event+0x1fa>
 1000ee4:	4639      	mov	r1, r7
 1000ee6:	4648      	mov	r0, r9
 1000ee8:	f44f 72b2 	mov.w	r2, #356	; 0x164
 1000eec:	f002 fe83 	bl	1003bf6 <assert_print>
 1000ef0:	f44f 71b2 	mov.w	r1, #356	; 0x164
 1000ef4:	4638      	mov	r0, r7
 1000ef6:	f002 fe77 	bl	1003be8 <assert_post_action>
			__ASSERT_NO_MSG(!sys_slist_is_empty(&mgr->clients));
 1000efa:	6823      	ldr	r3, [r4, #0]
 1000efc:	b953      	cbnz	r3, 1000f14 <process_event+0x214>
 1000efe:	4639      	mov	r1, r7
 1000f00:	4648      	mov	r0, r9
 1000f02:	f240 1265 	movw	r2, #357	; 0x165
 1000f06:	f002 fe76 	bl	1003bf6 <assert_print>
 1000f0a:	f240 1165 	movw	r1, #357	; 0x165
 1000f0e:	4638      	mov	r0, r7
 1000f10:	f002 fe6a 	bl	1003be8 <assert_post_action>
			transit = mgr->transitions->reset;
 1000f14:	6923      	ldr	r3, [r4, #16]
 1000f16:	689e      	ldr	r6, [r3, #8]
			__ASSERT_NO_MSG(transit != NULL);
 1000f18:	b956      	cbnz	r6, 1000f30 <process_event+0x230>
 1000f1a:	4639      	mov	r1, r7
 1000f1c:	4648      	mov	r0, r9
 1000f1e:	f44f 72b4 	mov.w	r2, #360	; 0x168
 1000f22:	f002 fe68 	bl	1003bf6 <assert_print>
 1000f26:	f44f 71b4 	mov.w	r1, #360	; 0x168
 1000f2a:	4638      	mov	r0, r7
 1000f2c:	f002 fe5c 	bl	1003be8 <assert_post_action>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1000f30:	8b23      	ldrh	r3, [r4, #24]
 1000f32:	f023 0307 	bic.w	r3, r3, #7
 1000f36:	f043 0305 	orr.w	r3, r3, #5
 1000f3a:	e799      	b.n	1000e70 <process_event+0x170>
			__ASSERT_NO_MSG(false);
 1000f3c:	2500      	movs	r5, #0
 1000f3e:	f240 126b 	movw	r2, #363	; 0x16b
 1000f42:	4639      	mov	r1, r7
 1000f44:	4648      	mov	r0, r9
 1000f46:	f002 fe56 	bl	1003bf6 <assert_print>
 1000f4a:	f240 116b 	movw	r1, #363	; 0x16b
 1000f4e:	4638      	mov	r0, r7
 1000f50:	f002 fe4a 	bl	1003be8 <assert_post_action>
		onoff_transition_fn transit = NULL;
 1000f54:	462e      	mov	r6, r5
 1000f56:	e78d      	b.n	1000e74 <process_event+0x174>
				   && !sys_slist_is_empty(&mgr->monitors);
 1000f58:	2001      	movs	r0, #1
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
 1000f5a:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
 1000f5e:	8321      	strh	r1, [r4, #24]
 1000f60:	f38a 8811 	msr	BASEPRI, sl
 1000f64:	f3bf 8f6f 	isb	sy
			if (do_monitors) {
 1000f68:	bb00      	cbnz	r0, 1000fac <process_event+0x2ac>
	while (!sys_slist_is_empty(list)) {
 1000f6a:	2d00      	cmp	r5, #0
 1000f6c:	d131      	bne.n	1000fd2 <process_event+0x2d2>
			if (transit != NULL) {
 1000f6e:	b116      	cbz	r6, 1000f76 <process_event+0x276>
				transit(mgr, transition_complete);
 1000f70:	4620      	mov	r0, r4
 1000f72:	4922      	ldr	r1, [pc, #136]	; (1000ffc <process_event+0x2fc>)
 1000f74:	47b0      	blx	r6
	__asm__ volatile(
 1000f76:	f04f 0320 	mov.w	r3, #32
 1000f7a:	f3ef 8a11 	mrs	sl, BASEPRI
 1000f7e:	f383 8812 	msr	BASEPRI_MAX, r3
 1000f82:	f3bf 8f6f 	isb	sy
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
 1000f86:	8b23      	ldrh	r3, [r4, #24]
 1000f88:	f023 0308 	bic.w	r3, r3, #8
 1000f8c:	8323      	strh	r3, [r4, #24]
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
 1000f8e:	8b23      	ldrh	r3, [r4, #24]
 1000f90:	06da      	lsls	r2, r3, #27
 1000f92:	d527      	bpl.n	1000fe4 <process_event+0x2e4>
			evt = EVT_COMPLETE;
 1000f94:	2101      	movs	r1, #1
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
 1000f96:	f023 0310 	bic.w	r3, r3, #16
 1000f9a:	8323      	strh	r3, [r4, #24]
		state = mgr->flags & ONOFF_STATE_MASK;
 1000f9c:	f8b4 8018 	ldrh.w	r8, [r4, #24]
 1000fa0:	f008 0807 	and.w	r8, r8, #7
	} while (evt != EVT_NOP);
 1000fa4:	2900      	cmp	r1, #0
 1000fa6:	f47f aec8 	bne.w	1000d3a <process_event+0x3a>
out:
 1000faa:	e6ba      	b.n	1000d22 <process_event+0x22>
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
 1000fac:	68a1      	ldr	r1, [r4, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
 1000fae:	2900      	cmp	r1, #0
 1000fb0:	d0db      	beq.n	1000f6a <process_event+0x26a>
	return node->next;
 1000fb2:	f8d1 8000 	ldr.w	r8, [r1]
		mon->callback(mgr, mon, state, res);
 1000fb6:	465b      	mov	r3, fp
 1000fb8:	4620      	mov	r0, r4
 1000fba:	f8d1 a004 	ldr.w	sl, [r1, #4]
 1000fbe:	9201      	str	r2, [sp, #4]
 1000fc0:	47d0      	blx	sl
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
 1000fc2:	9a01      	ldr	r2, [sp, #4]
 1000fc4:	f1b8 0f00 	cmp.w	r8, #0
 1000fc8:	d0cf      	beq.n	1000f6a <process_event+0x26a>
 1000fca:	4641      	mov	r1, r8
 1000fcc:	f8d8 8000 	ldr.w	r8, [r8]
 1000fd0:	e7f1      	b.n	1000fb6 <process_event+0x2b6>
 1000fd2:	4629      	mov	r1, r5
		notify_one(mgr, cli, state, res);
 1000fd4:	465b      	mov	r3, fp
 1000fd6:	4620      	mov	r0, r4
 1000fd8:	9201      	str	r2, [sp, #4]
 1000fda:	682d      	ldr	r5, [r5, #0]
 1000fdc:	f002 fd62 	bl	1003aa4 <notify_one>
	while (!sys_slist_is_empty(list)) {
 1000fe0:	9a01      	ldr	r2, [sp, #4]
 1000fe2:	e7c2      	b.n	1000f6a <process_event+0x26a>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
 1000fe4:	f013 0120 	ands.w	r1, r3, #32
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
 1000fe8:	bf1e      	ittt	ne
 1000fea:	f023 0320 	bicne.w	r3, r3, #32
			evt = EVT_RECHECK;
 1000fee:	2102      	movne	r1, #2
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
 1000ff0:	8323      	strhne	r3, [r4, #24]
			evt = EVT_RECHECK;
 1000ff2:	e7d3      	b.n	1000f9c <process_event+0x29c>
 1000ff4:	01004504 	.word	0x01004504
 1000ff8:	010044ec 	.word	0x010044ec
 1000ffc:	01003ad1 	.word	0x01003ad1

01001000 <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
 1001000:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1001004:	4604      	mov	r4, r0
 1001006:	460f      	mov	r7, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
 1001008:	f002 fd70 	bl	1003aec <validate_args>

	if (rv < 0) {
 100100c:	1e05      	subs	r5, r0, #0
 100100e:	db32      	blt.n	1001076 <onoff_request+0x76>
 1001010:	f04f 0320 	mov.w	r3, #32
 1001014:	f3ef 8811 	mrs	r8, BASEPRI
 1001018:	f383 8812 	msr	BASEPRI_MAX, r3
 100101c:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
 1001020:	f64f 71ff 	movw	r1, #65535	; 0xffff
 1001024:	8b63      	ldrh	r3, [r4, #26]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
 1001026:	8b22      	ldrh	r2, [r4, #24]
	if (mgr->refs == SERVICE_REFS_MAX) {
 1001028:	428b      	cmp	r3, r1
 100102a:	f002 0607 	and.w	r6, r2, #7
 100102e:	d03a      	beq.n	10010a6 <onoff_request+0xa6>
		rv = -EAGAIN;
		goto out;
	}

	rv = state;
	if (state == ONOFF_STATE_ON) {
 1001030:	2e02      	cmp	r6, #2
 1001032:	d10f      	bne.n	1001054 <onoff_request+0x54>
		/* Increment reference count, notify in exit */
		notify = true;
		mgr->refs += 1U;
 1001034:	3301      	adds	r3, #1
 1001036:	8363      	strh	r3, [r4, #26]
	rv = state;
 1001038:	4635      	mov	r5, r6
		notify = true;
 100103a:	2301      	movs	r3, #1
	__asm__ volatile(
 100103c:	f388 8811 	msr	BASEPRI, r8
 1001040:	f3bf 8f6f 	isb	sy
	if (start) {
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);

		if (notify) {
 1001044:	b1bb      	cbz	r3, 1001076 <onoff_request+0x76>
			notify_one(mgr, cli, state, 0);
 1001046:	2300      	movs	r3, #0
 1001048:	4632      	mov	r2, r6
 100104a:	4639      	mov	r1, r7
 100104c:	4620      	mov	r0, r4
 100104e:	f002 fd29 	bl	1003aa4 <notify_one>
 1001052:	e010      	b.n	1001076 <onoff_request+0x76>
	} else if ((state == ONOFF_STATE_OFF)
 1001054:	0793      	lsls	r3, r2, #30
 1001056:	d001      	beq.n	100105c <onoff_request+0x5c>
		   || (state == ONOFF_STATE_TO_ON)) {
 1001058:	2e06      	cmp	r6, #6
 100105a:	d10f      	bne.n	100107c <onoff_request+0x7c>
	parent->next = child;
 100105c:	2300      	movs	r3, #0
 100105e:	603b      	str	r3, [r7, #0]
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_tail(sys_slist_t *list)
{
	return list->tail;
 1001060:	6863      	ldr	r3, [r4, #4]
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
 1001062:	b9eb      	cbnz	r3, 10010a0 <onoff_request+0xa0>
	list->head = node;
 1001064:	e9c4 7700 	strd	r7, r7, [r4]
	if (start) {
 1001068:	4635      	mov	r5, r6
 100106a:	b9f6      	cbnz	r6, 10010aa <onoff_request+0xaa>
		process_event(mgr, EVT_RECHECK, key);
 100106c:	4642      	mov	r2, r8
 100106e:	2102      	movs	r1, #2
 1001070:	4620      	mov	r0, r4
 1001072:	f7ff fe45 	bl	1000d00 <process_event>
		}
	}

	return rv;
}
 1001076:	4628      	mov	r0, r5
 1001078:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (state == ONOFF_STATE_RESETTING) {
 100107c:	2e05      	cmp	r6, #5
 100107e:	d016      	beq.n	10010ae <onoff_request+0xae>
		__ASSERT_NO_MSG(state == ONOFF_STATE_ERROR);
 1001080:	2e01      	cmp	r6, #1
 1001082:	d00a      	beq.n	100109a <onoff_request+0x9a>
 1001084:	490b      	ldr	r1, [pc, #44]	; (10010b4 <onoff_request+0xb4>)
 1001086:	480c      	ldr	r0, [pc, #48]	; (10010b8 <onoff_request+0xb8>)
 1001088:	f44f 72e4 	mov.w	r2, #456	; 0x1c8
 100108c:	f002 fdb3 	bl	1003bf6 <assert_print>
 1001090:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 1001094:	4807      	ldr	r0, [pc, #28]	; (10010b4 <onoff_request+0xb4>)
 1001096:	f002 fda7 	bl	1003be8 <assert_post_action>
		rv = -EIO;
 100109a:	f06f 0504 	mvn.w	r5, #4
 100109e:	e004      	b.n	10010aa <onoff_request+0xaa>
	parent->next = child;
 10010a0:	601f      	str	r7, [r3, #0]
	list->tail = node;
 10010a2:	6067      	str	r7, [r4, #4]
}
 10010a4:	e7e0      	b.n	1001068 <onoff_request+0x68>
		rv = -EAGAIN;
 10010a6:	f06f 050a 	mvn.w	r5, #10
 10010aa:	2300      	movs	r3, #0
 10010ac:	e7c6      	b.n	100103c <onoff_request+0x3c>
		rv = -ENOTSUP;
 10010ae:	f06f 0585 	mvn.w	r5, #133	; 0x85
 10010b2:	e7fa      	b.n	10010aa <onoff_request+0xaa>
 10010b4:	01004504 	.word	0x01004504
 10010b8:	010044ec 	.word	0x010044ec

010010bc <z_cbvprintf_impl>:
	return (int)count;
}

int z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *fp,
		     va_list ap, uint32_t flags)
{
 10010bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10010c0:	468b      	mov	fp, r1
 10010c2:	4692      	mov	sl, r2
 10010c4:	461c      	mov	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
 10010c6:	2500      	movs	r5, #0
{
 10010c8:	b091      	sub	sp, #68	; 0x44
 10010ca:	9002      	str	r0, [sp, #8]
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
 10010cc:	f89a 0000 	ldrb.w	r0, [sl]
 10010d0:	b908      	cbnz	r0, 10010d6 <z_cbvprintf_impl+0x1a>
			OUTC(' ');
			--width;
		}
	}

	return count;
 10010d2:	4628      	mov	r0, r5
 10010d4:	e363      	b.n	100179e <z_cbvprintf_impl+0x6e2>
		if (*fp != '%') {
 10010d6:	2825      	cmp	r0, #37	; 0x25
			OUTC(*fp++);
 10010d8:	f10a 0701 	add.w	r7, sl, #1
		if (*fp != '%') {
 10010dc:	d007      	beq.n	10010ee <z_cbvprintf_impl+0x32>
			OUTC('%');
 10010de:	4659      	mov	r1, fp
 10010e0:	9b02      	ldr	r3, [sp, #8]
 10010e2:	4798      	blx	r3
 10010e4:	2800      	cmp	r0, #0
 10010e6:	f2c0 835a 	blt.w	100179e <z_cbvprintf_impl+0x6e2>
 10010ea:	3501      	adds	r5, #1
			break;
 10010ec:	e212      	b.n	1001514 <z_cbvprintf_impl+0x458>
		} state = {
 10010ee:	2218      	movs	r2, #24
 10010f0:	2100      	movs	r1, #0
 10010f2:	a80a      	add	r0, sp, #40	; 0x28
 10010f4:	f002 fe1f 	bl	1003d36 <memset>
	if (*sp == '%') {
 10010f8:	f89a 3001 	ldrb.w	r3, [sl, #1]
 10010fc:	2b25      	cmp	r3, #37	; 0x25
 10010fe:	d078      	beq.n	10011f2 <z_cbvprintf_impl+0x136>
 1001100:	2200      	movs	r2, #0
 1001102:	4610      	mov	r0, r2
 1001104:	4696      	mov	lr, r2
 1001106:	4694      	mov	ip, r2
 1001108:	4616      	mov	r6, r2
 100110a:	4639      	mov	r1, r7
		switch (*sp) {
 100110c:	f817 3b01 	ldrb.w	r3, [r7], #1
 1001110:	2b2b      	cmp	r3, #43	; 0x2b
 1001112:	f000 809d 	beq.w	1001250 <z_cbvprintf_impl+0x194>
 1001116:	f200 8094 	bhi.w	1001242 <z_cbvprintf_impl+0x186>
 100111a:	2b20      	cmp	r3, #32
 100111c:	f000 809b 	beq.w	1001256 <z_cbvprintf_impl+0x19a>
 1001120:	2b23      	cmp	r3, #35	; 0x23
 1001122:	f000 809b 	beq.w	100125c <z_cbvprintf_impl+0x1a0>
 1001126:	b12e      	cbz	r6, 1001134 <z_cbvprintf_impl+0x78>
 1001128:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
 100112c:	f046 0604 	orr.w	r6, r6, #4
 1001130:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
 1001134:	f1bc 0f00 	cmp.w	ip, #0
 1001138:	d005      	beq.n	1001146 <z_cbvprintf_impl+0x8a>
 100113a:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
 100113e:	f046 0608 	orr.w	r6, r6, #8
 1001142:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
 1001146:	f1be 0f00 	cmp.w	lr, #0
 100114a:	d005      	beq.n	1001158 <z_cbvprintf_impl+0x9c>
 100114c:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
 1001150:	f046 0610 	orr.w	r6, r6, #16
 1001154:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
 1001158:	b128      	cbz	r0, 1001166 <z_cbvprintf_impl+0xaa>
 100115a:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
 100115e:	f040 0020 	orr.w	r0, r0, #32
 1001162:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
 1001166:	b12a      	cbz	r2, 1001174 <z_cbvprintf_impl+0xb8>
 1001168:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
 100116c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 1001170:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (conv->flag_zero && conv->flag_dash) {
 1001174:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
 1001178:	f002 0044 	and.w	r0, r2, #68	; 0x44
 100117c:	2844      	cmp	r0, #68	; 0x44
 100117e:	d103      	bne.n	1001188 <z_cbvprintf_impl+0xcc>
		conv->flag_zero = false;
 1001180:	f36f 1286 	bfc	r2, #6, #1
 1001184:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	conv->width_present = true;
 1001188:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
 100118c:	2b2a      	cmp	r3, #42	; 0x2a
	conv->width_present = true;
 100118e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 1001192:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
 1001196:	d17b      	bne.n	1001290 <z_cbvprintf_impl+0x1d4>
		conv->width_star = true;
 1001198:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
			++sp;
 100119c:	1c4b      	adds	r3, r1, #1
		conv->width_star = true;
 100119e:	f042 0201 	orr.w	r2, r2, #1
 10011a2:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	conv->prec_present = (*sp == '.');
 10011a6:	781a      	ldrb	r2, [r3, #0]
 10011a8:	2a2e      	cmp	r2, #46	; 0x2e
 10011aa:	bf0c      	ite	eq
 10011ac:	2101      	moveq	r1, #1
 10011ae:	2100      	movne	r1, #0
 10011b0:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
 10011b4:	f361 0241 	bfi	r2, r1, #1, #1
 10011b8:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	if (!conv->prec_present) {
 10011bc:	d174      	bne.n	10012a8 <z_cbvprintf_impl+0x1ec>
	if (*sp == '*') {
 10011be:	785a      	ldrb	r2, [r3, #1]
 10011c0:	2a2a      	cmp	r2, #42	; 0x2a
 10011c2:	d06a      	beq.n	100129a <z_cbvprintf_impl+0x1de>
	size_t val = 0;
 10011c4:	2100      	movs	r1, #0
		val = 10U * val + *sp++ - '0';
 10011c6:	260a      	movs	r6, #10
	++sp;
 10011c8:	3301      	adds	r3, #1
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
 10011ca:	4618      	mov	r0, r3
 10011cc:	f810 2b01 	ldrb.w	r2, [r0], #1
 10011d0:	f1a2 0730 	sub.w	r7, r2, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
 10011d4:	2f09      	cmp	r7, #9
 10011d6:	f240 808e 	bls.w	10012f6 <z_cbvprintf_impl+0x23a>
	conv->unsupported |= ((conv->prec_value < 0)
 10011da:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	conv->prec_value = prec;
 10011de:	910e      	str	r1, [sp, #56]	; 0x38
	conv->unsupported |= ((conv->prec_value < 0)
 10011e0:	f3c2 0040 	ubfx	r0, r2, #1, #1
 10011e4:	ea40 71d1 	orr.w	r1, r0, r1, lsr #31
 10011e8:	f361 0241 	bfi	r2, r1, #1, #1
 10011ec:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
 10011f0:	e05a      	b.n	10012a8 <z_cbvprintf_impl+0x1ec>
		conv->specifier = *sp++;
 10011f2:	f10a 0702 	add.w	r7, sl, #2
 10011f6:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
		if (conv->width_star) {
 10011fa:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
 10011fe:	07d9      	lsls	r1, r3, #31
 1001200:	f140 8149 	bpl.w	1001496 <z_cbvprintf_impl+0x3da>
			width = va_arg(ap, int);
 1001204:	f854 9b04 	ldr.w	r9, [r4], #4
			if (width < 0) {
 1001208:	f1b9 0f00 	cmp.w	r9, #0
 100120c:	da07      	bge.n	100121e <z_cbvprintf_impl+0x162>
				conv->flag_dash = true;
 100120e:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				width = -width;
 1001212:	f1c9 0900 	rsb	r9, r9, #0
				conv->flag_dash = true;
 1001216:	f042 0204 	orr.w	r2, r2, #4
 100121a:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
		if (conv->prec_star) {
 100121e:	075a      	lsls	r2, r3, #29
 1001220:	f140 8142 	bpl.w	10014a8 <z_cbvprintf_impl+0x3ec>
			int arg = va_arg(ap, int);
 1001224:	f854 8b04 	ldr.w	r8, [r4], #4
			if (arg < 0) {
 1001228:	f1b8 0f00 	cmp.w	r8, #0
 100122c:	f280 8141 	bge.w	10014b2 <z_cbvprintf_impl+0x3f6>
				conv->prec_present = false;
 1001230:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
 1001234:	f36f 0341 	bfc	r3, #1, #1
 1001238:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		int precision = -1;
 100123c:	f04f 38ff 	mov.w	r8, #4294967295
 1001240:	e137      	b.n	10014b2 <z_cbvprintf_impl+0x3f6>
		switch (*sp) {
 1001242:	2b2d      	cmp	r3, #45	; 0x2d
 1001244:	d00c      	beq.n	1001260 <z_cbvprintf_impl+0x1a4>
 1001246:	2b30      	cmp	r3, #48	; 0x30
 1001248:	f47f af6d 	bne.w	1001126 <z_cbvprintf_impl+0x6a>
			conv->flag_zero = true;
 100124c:	2201      	movs	r2, #1
	} while (loop);
 100124e:	e75c      	b.n	100110a <z_cbvprintf_impl+0x4e>
			conv->flag_plus = true;
 1001250:	f04f 0c01 	mov.w	ip, #1
 1001254:	e759      	b.n	100110a <z_cbvprintf_impl+0x4e>
			conv->flag_space = true;
 1001256:	f04f 0e01 	mov.w	lr, #1
 100125a:	e756      	b.n	100110a <z_cbvprintf_impl+0x4e>
			conv->flag_hash = true;
 100125c:	2001      	movs	r0, #1
 100125e:	e754      	b.n	100110a <z_cbvprintf_impl+0x4e>
		switch (*sp) {
 1001260:	2601      	movs	r6, #1
 1001262:	e752      	b.n	100110a <z_cbvprintf_impl+0x4e>
		val = 10U * val + *sp++ - '0';
 1001264:	4633      	mov	r3, r6
 1001266:	fb0c 0202 	mla	r2, ip, r2, r0
 100126a:	3a30      	subs	r2, #48	; 0x30
 100126c:	461e      	mov	r6, r3
 100126e:	f816 0b01 	ldrb.w	r0, [r6], #1
 1001272:	f1a0 0730 	sub.w	r7, r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
 1001276:	2f09      	cmp	r7, #9
 1001278:	d9f4      	bls.n	1001264 <z_cbvprintf_impl+0x1a8>
	if (sp != wp) {
 100127a:	4299      	cmp	r1, r3
 100127c:	d093      	beq.n	10011a6 <z_cbvprintf_impl+0xea>
		conv->unsupported |= ((conv->width_value < 0)
 100127e:	f89d 1030 	ldrb.w	r1, [sp, #48]	; 0x30
		conv->width_value = width;
 1001282:	920d      	str	r2, [sp, #52]	; 0x34
				      || (width != (size_t)conv->width_value));
 1001284:	0fd2      	lsrs	r2, r2, #31
		conv->unsupported |= ((conv->width_value < 0)
 1001286:	f362 0141 	bfi	r1, r2, #1, #1
 100128a:	f88d 1030 	strb.w	r1, [sp, #48]	; 0x30
 100128e:	e78a      	b.n	10011a6 <z_cbvprintf_impl+0xea>
 1001290:	460b      	mov	r3, r1
	size_t val = 0;
 1001292:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
 1001294:	f04f 0c0a 	mov.w	ip, #10
 1001298:	e7e8      	b.n	100126c <z_cbvprintf_impl+0x1b0>
		conv->prec_star = true;
 100129a:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
		return ++sp;
 100129e:	3302      	adds	r3, #2
		conv->prec_star = true;
 10012a0:	f042 0204 	orr.w	r2, r2, #4
 10012a4:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	switch (*sp) {
 10012a8:	461f      	mov	r7, r3
 10012aa:	f817 2b01 	ldrb.w	r2, [r7], #1
 10012ae:	2a6c      	cmp	r2, #108	; 0x6c
 10012b0:	d041      	beq.n	1001336 <z_cbvprintf_impl+0x27a>
 10012b2:	d825      	bhi.n	1001300 <z_cbvprintf_impl+0x244>
 10012b4:	2a68      	cmp	r2, #104	; 0x68
 10012b6:	d02b      	beq.n	1001310 <z_cbvprintf_impl+0x254>
 10012b8:	2a6a      	cmp	r2, #106	; 0x6a
 10012ba:	d046      	beq.n	100134a <z_cbvprintf_impl+0x28e>
 10012bc:	2a4c      	cmp	r2, #76	; 0x4c
 10012be:	d04c      	beq.n	100135a <z_cbvprintf_impl+0x29e>
 10012c0:	461f      	mov	r7, r3
	conv->specifier = *sp++;
 10012c2:	f817 2b01 	ldrb.w	r2, [r7], #1
		if (conv->length_mod == LENGTH_UPPER_L) {
 10012c6:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
	switch (conv->specifier) {
 10012ca:	2a78      	cmp	r2, #120	; 0x78
	conv->specifier = *sp++;
 10012cc:	f88d 2033 	strb.w	r2, [sp, #51]	; 0x33
	switch (conv->specifier) {
 10012d0:	f200 80d9 	bhi.w	1001486 <z_cbvprintf_impl+0x3ca>
 10012d4:	2a57      	cmp	r2, #87	; 0x57
 10012d6:	d84d      	bhi.n	1001374 <z_cbvprintf_impl+0x2b8>
 10012d8:	2a41      	cmp	r2, #65	; 0x41
 10012da:	d003      	beq.n	10012e4 <z_cbvprintf_impl+0x228>
 10012dc:	3a45      	subs	r2, #69	; 0x45
 10012de:	2a02      	cmp	r2, #2
 10012e0:	f200 80d1 	bhi.w	1001486 <z_cbvprintf_impl+0x3ca>
		conv->specifier_cat = SPECIFIER_FP;
 10012e4:	2204      	movs	r2, #4
 10012e6:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
 10012ea:	f362 0302 	bfi	r3, r2, #0, #3
 10012ee:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
			unsupported = true;
 10012f2:	2301      	movs	r3, #1
			break;
 10012f4:	e09e      	b.n	1001434 <z_cbvprintf_impl+0x378>
		val = 10U * val + *sp++ - '0';
 10012f6:	fb06 2101 	mla	r1, r6, r1, r2
 10012fa:	4603      	mov	r3, r0
 10012fc:	3930      	subs	r1, #48	; 0x30
 10012fe:	e764      	b.n	10011ca <z_cbvprintf_impl+0x10e>
	switch (*sp) {
 1001300:	2a74      	cmp	r2, #116	; 0x74
 1001302:	d026      	beq.n	1001352 <z_cbvprintf_impl+0x296>
 1001304:	2a7a      	cmp	r2, #122	; 0x7a
 1001306:	d1db      	bne.n	10012c0 <z_cbvprintf_impl+0x204>
		conv->length_mod = LENGTH_Z;
 1001308:	2206      	movs	r2, #6
 100130a:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
 100130e:	e00d      	b.n	100132c <z_cbvprintf_impl+0x270>
		if (*++sp == 'h') {
 1001310:	785a      	ldrb	r2, [r3, #1]
 1001312:	2a68      	cmp	r2, #104	; 0x68
 1001314:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
 1001318:	d106      	bne.n	1001328 <z_cbvprintf_impl+0x26c>
			conv->length_mod = LENGTH_HH;
 100131a:	2101      	movs	r1, #1
			conv->length_mod = LENGTH_LL;
 100131c:	f361 02c6 	bfi	r2, r1, #3, #4
 1001320:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
			++sp;
 1001324:	1c9f      	adds	r7, r3, #2
 1001326:	e7cc      	b.n	10012c2 <z_cbvprintf_impl+0x206>
			conv->length_mod = LENGTH_H;
 1001328:	4613      	mov	r3, r2
 100132a:	2202      	movs	r2, #2
		conv->length_mod = LENGTH_T;
 100132c:	f362 03c6 	bfi	r3, r2, #3, #4
 1001330:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		break;
 1001334:	e7c5      	b.n	10012c2 <z_cbvprintf_impl+0x206>
		if (*++sp == 'l') {
 1001336:	785a      	ldrb	r2, [r3, #1]
 1001338:	2a6c      	cmp	r2, #108	; 0x6c
 100133a:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
 100133e:	d101      	bne.n	1001344 <z_cbvprintf_impl+0x288>
			conv->length_mod = LENGTH_LL;
 1001340:	2104      	movs	r1, #4
 1001342:	e7eb      	b.n	100131c <z_cbvprintf_impl+0x260>
			conv->length_mod = LENGTH_L;
 1001344:	4613      	mov	r3, r2
 1001346:	2203      	movs	r2, #3
 1001348:	e7f0      	b.n	100132c <z_cbvprintf_impl+0x270>
		conv->length_mod = LENGTH_J;
 100134a:	2205      	movs	r2, #5
 100134c:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
 1001350:	e7ec      	b.n	100132c <z_cbvprintf_impl+0x270>
		conv->length_mod = LENGTH_T;
 1001352:	2207      	movs	r2, #7
 1001354:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
 1001358:	e7e8      	b.n	100132c <z_cbvprintf_impl+0x270>
		conv->unsupported = true;
 100135a:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
 100135e:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 1001362:	f023 0302 	bic.w	r3, r3, #2
 1001366:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 100136a:	f043 0302 	orr.w	r3, r3, #2
 100136e:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
		break;
 1001372:	e7a6      	b.n	10012c2 <z_cbvprintf_impl+0x206>
	switch (conv->specifier) {
 1001374:	f1a2 0158 	sub.w	r1, r2, #88	; 0x58
 1001378:	2920      	cmp	r1, #32
 100137a:	f200 8084 	bhi.w	1001486 <z_cbvprintf_impl+0x3ca>
 100137e:	a001      	add	r0, pc, #4	; (adr r0, 1001384 <z_cbvprintf_impl+0x2c8>)
 1001380:	f850 f021 	ldr.w	pc, [r0, r1, lsl #2]
 1001384:	01001449 	.word	0x01001449
 1001388:	01001487 	.word	0x01001487
 100138c:	01001487 	.word	0x01001487
 1001390:	01001487 	.word	0x01001487
 1001394:	01001487 	.word	0x01001487
 1001398:	01001487 	.word	0x01001487
 100139c:	01001487 	.word	0x01001487
 10013a0:	01001487 	.word	0x01001487
 10013a4:	01001487 	.word	0x01001487
 10013a8:	010012e5 	.word	0x010012e5
 10013ac:	01001487 	.word	0x01001487
 10013b0:	01001449 	.word	0x01001449
 10013b4:	01001409 	.word	0x01001409
 10013b8:	010012e5 	.word	0x010012e5
 10013bc:	010012e5 	.word	0x010012e5
 10013c0:	010012e5 	.word	0x010012e5
 10013c4:	01001487 	.word	0x01001487
 10013c8:	01001409 	.word	0x01001409
 10013cc:	01001487 	.word	0x01001487
 10013d0:	01001487 	.word	0x01001487
 10013d4:	01001487 	.word	0x01001487
 10013d8:	01001487 	.word	0x01001487
 10013dc:	01001451 	.word	0x01001451
 10013e0:	01001449 	.word	0x01001449
 10013e4:	0100146d 	.word	0x0100146d
 10013e8:	01001487 	.word	0x01001487
 10013ec:	01001487 	.word	0x01001487
 10013f0:	0100146d 	.word	0x0100146d
 10013f4:	01001487 	.word	0x01001487
 10013f8:	01001449 	.word	0x01001449
 10013fc:	01001487 	.word	0x01001487
 1001400:	01001487 	.word	0x01001487
 1001404:	01001449 	.word	0x01001449
		conv->specifier_cat = SPECIFIER_SINT;
 1001408:	2001      	movs	r0, #1
 100140a:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
 100140e:	f003 0378 	and.w	r3, r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_UINT;
 1001412:	f360 0102 	bfi	r1, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
 1001416:	2b40      	cmp	r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_UINT;
 1001418:	f88d 1032 	strb.w	r1, [sp, #50]	; 0x32
			conv->invalid = true;
 100141c:	bf02      	ittt	eq
 100141e:	f89d 1030 	ldrbeq.w	r1, [sp, #48]	; 0x30
 1001422:	f041 0101 	orreq.w	r1, r1, #1
 1001426:	f88d 1030 	strbeq.w	r1, [sp, #48]	; 0x30
		if (conv->specifier == 'c') {
 100142a:	2a63      	cmp	r2, #99	; 0x63
 100142c:	d131      	bne.n	1001492 <z_cbvprintf_impl+0x3d6>
			unsupported = (conv->length_mod != LENGTH_NONE);
 100142e:	3b00      	subs	r3, #0
 1001430:	bf18      	it	ne
 1001432:	2301      	movne	r3, #1
	conv->unsupported |= unsupported;
 1001434:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
 1001438:	f3c2 0140 	ubfx	r1, r2, #1, #1
 100143c:	430b      	orrs	r3, r1
 100143e:	f363 0241 	bfi	r2, r3, #1, #1
 1001442:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
 1001446:	e6d8      	b.n	10011fa <z_cbvprintf_impl+0x13e>
		conv->specifier_cat = SPECIFIER_UINT;
 1001448:	2002      	movs	r0, #2
 100144a:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
 100144e:	e7de      	b.n	100140e <z_cbvprintf_impl+0x352>
		conv->specifier_cat = SPECIFIER_PTR;
 1001450:	2103      	movs	r1, #3
 1001452:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
 1001456:	f003 0378 	and.w	r3, r3, #120	; 0x78
 100145a:	f1a3 0040 	sub.w	r0, r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_PTR;
 100145e:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
 1001462:	4243      	negs	r3, r0
		conv->specifier_cat = SPECIFIER_PTR;
 1001464:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
 1001468:	4143      	adcs	r3, r0
 100146a:	e7e3      	b.n	1001434 <z_cbvprintf_impl+0x378>
		conv->specifier_cat = SPECIFIER_PTR;
 100146c:	2103      	movs	r1, #3
 100146e:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod != LENGTH_NONE) {
 1001472:	f013 0f78 	tst.w	r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
 1001476:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod != LENGTH_NONE) {
 100147a:	bf14      	ite	ne
 100147c:	2301      	movne	r3, #1
 100147e:	2300      	moveq	r3, #0
		conv->specifier_cat = SPECIFIER_PTR;
 1001480:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod != LENGTH_NONE) {
 1001484:	e7d6      	b.n	1001434 <z_cbvprintf_impl+0x378>
		conv->invalid = true;
 1001486:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
 100148a:	f043 0301 	orr.w	r3, r3, #1
 100148e:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
	bool unsupported = false;
 1001492:	2300      	movs	r3, #0
 1001494:	e7ce      	b.n	1001434 <z_cbvprintf_impl+0x378>
		} else if (conv->width_present) {
 1001496:	f99d 2030 	ldrsb.w	r2, [sp, #48]	; 0x30
 100149a:	2a00      	cmp	r2, #0
		int width = -1;
 100149c:	bfac      	ite	ge
 100149e:	f04f 39ff 	movge.w	r9, #4294967295
			width = conv->width_value;
 10014a2:	f8dd 9034 	ldrlt.w	r9, [sp, #52]	; 0x34
 10014a6:	e6ba      	b.n	100121e <z_cbvprintf_impl+0x162>
		} else if (conv->prec_present) {
 10014a8:	079b      	lsls	r3, r3, #30
 10014aa:	f57f aec7 	bpl.w	100123c <z_cbvprintf_impl+0x180>
			precision = conv->prec_value;
 10014ae:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
		conv->pad0_value = 0;
 10014b2:	2300      	movs	r3, #0
		conv->pad0_pre_exp = 0;
 10014b4:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
			= (enum specifier_cat_enum)conv->specifier_cat;
 10014b8:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
			= (enum length_mod_enum)conv->length_mod;
 10014bc:	f89d 1031 	ldrb.w	r1, [sp, #49]	; 0x31
		enum specifier_cat_enum specifier_cat
 10014c0:	f003 0307 	and.w	r3, r3, #7
		if (specifier_cat == SPECIFIER_SINT) {
 10014c4:	2b01      	cmp	r3, #1
			= (enum length_mod_enum)conv->length_mod;
 10014c6:	f3c1 01c3 	ubfx	r1, r1, #3, #4
		if (specifier_cat == SPECIFIER_SINT) {
 10014ca:	d135      	bne.n	1001538 <z_cbvprintf_impl+0x47c>
			switch (length_mod) {
 10014cc:	1ecb      	subs	r3, r1, #3
 10014ce:	2b04      	cmp	r3, #4
 10014d0:	d822      	bhi.n	1001518 <z_cbvprintf_impl+0x45c>
 10014d2:	e8df f003 	tbb	[pc, r3]
 10014d6:	0903      	.short	0x0903
 10014d8:	2109      	.short	0x2109
 10014da:	21          	.byte	0x21
 10014db:	00          	.byte	0x00
					value->sint = va_arg(ap, long);
 10014dc:	f854 3b04 	ldr.w	r3, [r4], #4
				value->sint = (short)value->sint;
 10014e0:	17da      	asrs	r2, r3, #31
 10014e2:	e9cd 320a 	strd	r3, r2, [sp, #40]	; 0x28
 10014e6:	e006      	b.n	10014f6 <z_cbvprintf_impl+0x43a>
					(sint_value_type)va_arg(ap, intmax_t);
 10014e8:	3407      	adds	r4, #7
 10014ea:	f024 0407 	bic.w	r4, r4, #7
				value->sint =
 10014ee:	e8f4 2302 	ldrd	r2, r3, [r4], #8
 10014f2:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
		if (conv->invalid || conv->unsupported) {
 10014f6:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
 10014fa:	f013 0603 	ands.w	r6, r3, #3
 10014fe:	d059      	beq.n	10015b4 <z_cbvprintf_impl+0x4f8>
			OUTS(sp, fp);
 1001500:	463b      	mov	r3, r7
 1001502:	4652      	mov	r2, sl
 1001504:	4659      	mov	r1, fp
 1001506:	9802      	ldr	r0, [sp, #8]
 1001508:	f002 fb58 	bl	1003bbc <outs>
 100150c:	2800      	cmp	r0, #0
 100150e:	f2c0 8146 	blt.w	100179e <z_cbvprintf_impl+0x6e2>
 1001512:	4405      	add	r5, r0
			continue;
 1001514:	46ba      	mov	sl, r7
 1001516:	e5d9      	b.n	10010cc <z_cbvprintf_impl+0x10>
					(sint_value_type)va_arg(ap, ptrdiff_t);
 1001518:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
 100151c:	2901      	cmp	r1, #1
					(sint_value_type)va_arg(ap, ptrdiff_t);
 100151e:	ea4f 72e3 	mov.w	r2, r3, asr #31
 1001522:	e9cd 320a 	strd	r3, r2, [sp, #40]	; 0x28
			if (length_mod == LENGTH_HH) {
 1001526:	d102      	bne.n	100152e <z_cbvprintf_impl+0x472>
				value->sint = (signed char)value->sint;
 1001528:	f99d 3028 	ldrsb.w	r3, [sp, #40]	; 0x28
 100152c:	e7d8      	b.n	10014e0 <z_cbvprintf_impl+0x424>
			} else if (length_mod == LENGTH_H) {
 100152e:	2902      	cmp	r1, #2
 1001530:	d1e1      	bne.n	10014f6 <z_cbvprintf_impl+0x43a>
				value->sint = (short)value->sint;
 1001532:	f9bd 3028 	ldrsh.w	r3, [sp, #40]	; 0x28
 1001536:	e7d3      	b.n	10014e0 <z_cbvprintf_impl+0x424>
		} else if (specifier_cat == SPECIFIER_UINT) {
 1001538:	2b02      	cmp	r3, #2
 100153a:	d129      	bne.n	1001590 <z_cbvprintf_impl+0x4d4>
			switch (length_mod) {
 100153c:	1ecb      	subs	r3, r1, #3
 100153e:	2b04      	cmp	r3, #4
 1001540:	d813      	bhi.n	100156a <z_cbvprintf_impl+0x4ae>
 1001542:	e8df f003 	tbb	[pc, r3]
 1001546:	0a03      	.short	0x0a03
 1001548:	120a      	.short	0x120a
 100154a:	12          	.byte	0x12
 100154b:	00          	.byte	0x00
				if ((!WCHAR_IS_SIGNED)
 100154c:	2300      	movs	r3, #0
					value->uint = (wchar_t)va_arg(ap,
 100154e:	6822      	ldr	r2, [r4, #0]
				value->sint = va_arg(ap, int);
 1001550:	1d20      	adds	r0, r4, #4
					value->uint = (wchar_t)va_arg(ap,
 1001552:	920a      	str	r2, [sp, #40]	; 0x28
 1001554:	930b      	str	r3, [sp, #44]	; 0x2c
					(uint_value_type)va_arg(ap, size_t);
 1001556:	4604      	mov	r4, r0
 1001558:	e7cd      	b.n	10014f6 <z_cbvprintf_impl+0x43a>
					(uint_value_type)va_arg(ap,
 100155a:	1de0      	adds	r0, r4, #7
 100155c:	f020 0007 	bic.w	r0, r0, #7
				value->uint =
 1001560:	e8f0 2302 	ldrd	r2, r3, [r0], #8
 1001564:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
				break;
 1001568:	e7f5      	b.n	1001556 <z_cbvprintf_impl+0x49a>
					(uint_value_type)va_arg(ap, size_t);
 100156a:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
 100156e:	2901      	cmp	r1, #1
					(uint_value_type)va_arg(ap, size_t);
 1001570:	930a      	str	r3, [sp, #40]	; 0x28
 1001572:	f04f 0300 	mov.w	r3, #0
 1001576:	930b      	str	r3, [sp, #44]	; 0x2c
			if (length_mod == LENGTH_HH) {
 1001578:	d105      	bne.n	1001586 <z_cbvprintf_impl+0x4ca>
				value->uint = (unsigned char)value->uint;
 100157a:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
				value->uint = (unsigned short)value->uint;
 100157e:	930a      	str	r3, [sp, #40]	; 0x28
 1001580:	2300      	movs	r3, #0
 1001582:	930b      	str	r3, [sp, #44]	; 0x2c
 1001584:	e7b7      	b.n	10014f6 <z_cbvprintf_impl+0x43a>
			} else if (length_mod == LENGTH_H) {
 1001586:	2902      	cmp	r1, #2
 1001588:	d1b5      	bne.n	10014f6 <z_cbvprintf_impl+0x43a>
				value->uint = (unsigned short)value->uint;
 100158a:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
 100158e:	e7f6      	b.n	100157e <z_cbvprintf_impl+0x4c2>
		} else if (specifier_cat == SPECIFIER_FP) {
 1001590:	2b04      	cmp	r3, #4
 1001592:	d109      	bne.n	10015a8 <z_cbvprintf_impl+0x4ec>
					(sint_value_type)va_arg(ap, long long);
 1001594:	1de3      	adds	r3, r4, #7
 1001596:	f023 0307 	bic.w	r3, r3, #7
 100159a:	f103 0408 	add.w	r4, r3, #8
				value->ldbl = va_arg(ap, long double);
 100159e:	e9d3 2300 	ldrd	r2, r3, [r3]
 10015a2:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
 10015a6:	e7a6      	b.n	10014f6 <z_cbvprintf_impl+0x43a>
		} else if (specifier_cat == SPECIFIER_PTR) {
 10015a8:	2b03      	cmp	r3, #3
			value->ptr = va_arg(ap, void *);
 10015aa:	bf04      	itt	eq
 10015ac:	f854 3b04 	ldreq.w	r3, [r4], #4
 10015b0:	930a      	streq	r3, [sp, #40]	; 0x28
 10015b2:	e7a0      	b.n	10014f6 <z_cbvprintf_impl+0x43a>
		switch (conv->specifier) {
 10015b4:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
 10015b8:	2878      	cmp	r0, #120	; 0x78
 10015ba:	d8ab      	bhi.n	1001514 <z_cbvprintf_impl+0x458>
 10015bc:	2862      	cmp	r0, #98	; 0x62
 10015be:	d822      	bhi.n	1001606 <z_cbvprintf_impl+0x54a>
 10015c0:	2825      	cmp	r0, #37	; 0x25
 10015c2:	f43f ad8c 	beq.w	10010de <z_cbvprintf_impl+0x22>
 10015c6:	2858      	cmp	r0, #88	; 0x58
 10015c8:	d1a4      	bne.n	1001514 <z_cbvprintf_impl+0x458>
			bps = encode_uint(value->uint, conv, buf, bpe);
 10015ca:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 10015ce:	f10d 0326 	add.w	r3, sp, #38	; 0x26
 10015d2:	9300      	str	r3, [sp, #0]
 10015d4:	aa0c      	add	r2, sp, #48	; 0x30
 10015d6:	ab04      	add	r3, sp, #16
 10015d8:	f002 faaa 	bl	1003b30 <encode_uint>
 10015dc:	4682      	mov	sl, r0
			if (precision >= 0) {
 10015de:	f1b8 0f00 	cmp.w	r8, #0
 10015e2:	f10d 0026 	add.w	r0, sp, #38	; 0x26
 10015e6:	db0c      	blt.n	1001602 <z_cbvprintf_impl+0x546>
				conv->flag_zero = false;
 10015e8:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				size_t len = bpe - bps;
 10015ec:	eba0 030a 	sub.w	r3, r0, sl
				conv->flag_zero = false;
 10015f0:	f36f 1286 	bfc	r2, #6, #1
				if (len < (size_t)precision) {
 10015f4:	4598      	cmp	r8, r3
				conv->flag_zero = false;
 10015f6:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
				if (len < (size_t)precision) {
 10015fa:	d902      	bls.n	1001602 <z_cbvprintf_impl+0x546>
					conv->pad0_value = precision - (int)len;
 10015fc:	eba8 0303 	sub.w	r3, r8, r3
 1001600:	930d      	str	r3, [sp, #52]	; 0x34
		const char *bpe = buf + sizeof(buf);
 1001602:	4680      	mov	r8, r0
 1001604:	e03e      	b.n	1001684 <z_cbvprintf_impl+0x5c8>
		switch (conv->specifier) {
 1001606:	3863      	subs	r0, #99	; 0x63
 1001608:	2815      	cmp	r0, #21
 100160a:	d883      	bhi.n	1001514 <z_cbvprintf_impl+0x458>
 100160c:	a201      	add	r2, pc, #4	; (adr r2, 1001614 <z_cbvprintf_impl+0x558>)
 100160e:	f852 f020 	ldr.w	pc, [r2, r0, lsl #2]
 1001612:	bf00      	nop
 1001614:	01001695 	.word	0x01001695
 1001618:	010016f9 	.word	0x010016f9
 100161c:	01001515 	.word	0x01001515
 1001620:	01001515 	.word	0x01001515
 1001624:	01001515 	.word	0x01001515
 1001628:	01001515 	.word	0x01001515
 100162c:	010016f9 	.word	0x010016f9
 1001630:	01001515 	.word	0x01001515
 1001634:	01001515 	.word	0x01001515
 1001638:	01001515 	.word	0x01001515
 100163c:	01001515 	.word	0x01001515
 1001640:	01001753 	.word	0x01001753
 1001644:	01001721 	.word	0x01001721
 1001648:	01001725 	.word	0x01001725
 100164c:	01001515 	.word	0x01001515
 1001650:	01001515 	.word	0x01001515
 1001654:	0100166d 	.word	0x0100166d
 1001658:	01001515 	.word	0x01001515
 100165c:	01001721 	.word	0x01001721
 1001660:	01001515 	.word	0x01001515
 1001664:	01001515 	.word	0x01001515
 1001668:	01001721 	.word	0x01001721
			if (precision >= 0) {
 100166c:	f1b8 0f00 	cmp.w	r8, #0
			bps = (const char *)value->ptr;
 1001670:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
			if (precision >= 0) {
 1001674:	db0a      	blt.n	100168c <z_cbvprintf_impl+0x5d0>
				len = strnlen(bps, precision);
 1001676:	4641      	mov	r1, r8
 1001678:	4650      	mov	r0, sl
 100167a:	f002 fb37 	bl	1003cec <strnlen>
		char sign = 0;
 100167e:	2600      	movs	r6, #0
			bpe = bps + len;
 1001680:	eb0a 0800 	add.w	r8, sl, r0
		if (bps == NULL) {
 1001684:	f1ba 0f00 	cmp.w	sl, #0
 1001688:	d10c      	bne.n	10016a4 <z_cbvprintf_impl+0x5e8>
 100168a:	e743      	b.n	1001514 <z_cbvprintf_impl+0x458>
				len = strlen(bps);
 100168c:	4650      	mov	r0, sl
 100168e:	f002 fb26 	bl	1003cde <strlen>
 1001692:	e7f4      	b.n	100167e <z_cbvprintf_impl+0x5c2>
			break;
 1001694:	2600      	movs	r6, #0
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
 1001696:	9b0a      	ldr	r3, [sp, #40]	; 0x28
			bps = buf;
 1001698:	f10d 0a10 	add.w	sl, sp, #16
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
 100169c:	f88d 3010 	strb.w	r3, [sp, #16]
			bpe = buf + 1;
 10016a0:	f10d 0811 	add.w	r8, sp, #17
		size_t nj_len = (bpe - bps);
 10016a4:	eba8 030a 	sub.w	r3, r8, sl
		if (sign != 0) {
 10016a8:	b106      	cbz	r6, 10016ac <z_cbvprintf_impl+0x5f0>
			nj_len += 1U;
 10016aa:	3301      	adds	r3, #1
		if (conv->altform_0c) {
 10016ac:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
 10016b0:	06d0      	lsls	r0, r2, #27
 10016b2:	d568      	bpl.n	1001786 <z_cbvprintf_impl+0x6ca>
			nj_len += 2U;
 10016b4:	3302      	adds	r3, #2
		if (conv->pad_fp) {
 10016b6:	0652      	lsls	r2, r2, #25
		nj_len += conv->pad0_value;
 10016b8:	990d      	ldr	r1, [sp, #52]	; 0x34
			nj_len += conv->pad0_pre_exp;
 10016ba:	bf48      	it	mi
 10016bc:	9a0e      	ldrmi	r2, [sp, #56]	; 0x38
		nj_len += conv->pad0_value;
 10016be:	440b      	add	r3, r1
			nj_len += conv->pad0_pre_exp;
 10016c0:	bf48      	it	mi
 10016c2:	189b      	addmi	r3, r3, r2
		if (width > 0) {
 10016c4:	f1b9 0f00 	cmp.w	r9, #0
 10016c8:	dd76      	ble.n	10017b8 <z_cbvprintf_impl+0x6fc>
			if (!conv->flag_dash) {
 10016ca:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
			width -= (int)nj_len;
 10016ce:	eba9 0903 	sub.w	r9, r9, r3
			if (!conv->flag_dash) {
 10016d2:	f3c2 0380 	ubfx	r3, r2, #2, #1
 10016d6:	9303      	str	r3, [sp, #12]
 10016d8:	0753      	lsls	r3, r2, #29
 10016da:	d46d      	bmi.n	10017b8 <z_cbvprintf_impl+0x6fc>
				if (conv->flag_zero) {
 10016dc:	0650      	lsls	r0, r2, #25
 10016de:	d561      	bpl.n	10017a4 <z_cbvprintf_impl+0x6e8>
					if (sign != 0) {
 10016e0:	b146      	cbz	r6, 10016f4 <z_cbvprintf_impl+0x638>
						OUTC(sign);
 10016e2:	4659      	mov	r1, fp
 10016e4:	4630      	mov	r0, r6
 10016e6:	9b02      	ldr	r3, [sp, #8]
 10016e8:	4798      	blx	r3
 10016ea:	2800      	cmp	r0, #0
 10016ec:	db57      	blt.n	100179e <z_cbvprintf_impl+0x6e2>
						sign = 0;
 10016ee:	9b03      	ldr	r3, [sp, #12]
						OUTC(sign);
 10016f0:	3501      	adds	r5, #1
						sign = 0;
 10016f2:	461e      	mov	r6, r3
					pad = '0';
 10016f4:	2330      	movs	r3, #48	; 0x30
 10016f6:	e056      	b.n	10017a6 <z_cbvprintf_impl+0x6ea>
			if (conv->flag_plus) {
 10016f8:	071e      	lsls	r6, r3, #28
 10016fa:	d40f      	bmi.n	100171c <z_cbvprintf_impl+0x660>
				sign = ' ';
 10016fc:	f013 0610 	ands.w	r6, r3, #16
 1001700:	bf18      	it	ne
 1001702:	2620      	movne	r6, #32
			sint = value->sint;
 1001704:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
			if (sint < 0) {
 1001708:	2b00      	cmp	r3, #0
 100170a:	f6bf af5e 	bge.w	10015ca <z_cbvprintf_impl+0x50e>
				value->uint = (uint_value_type)-sint;
 100170e:	4252      	negs	r2, r2
 1001710:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
				sign = '-';
 1001714:	262d      	movs	r6, #45	; 0x2d
				value->uint = (uint_value_type)-sint;
 1001716:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
 100171a:	e756      	b.n	10015ca <z_cbvprintf_impl+0x50e>
				sign = '+';
 100171c:	262b      	movs	r6, #43	; 0x2b
 100171e:	e7f1      	b.n	1001704 <z_cbvprintf_impl+0x648>
		switch (conv->specifier) {
 1001720:	2600      	movs	r6, #0
 1001722:	e752      	b.n	10015ca <z_cbvprintf_impl+0x50e>
			if (value->ptr != NULL) {
 1001724:	980a      	ldr	r0, [sp, #40]	; 0x28
 1001726:	b340      	cbz	r0, 100177a <z_cbvprintf_impl+0x6be>
				bps = encode_uint((uintptr_t)value->ptr, conv,
 1001728:	f10d 0326 	add.w	r3, sp, #38	; 0x26
 100172c:	9300      	str	r3, [sp, #0]
 100172e:	2100      	movs	r1, #0
 1001730:	ab04      	add	r3, sp, #16
 1001732:	aa0c      	add	r2, sp, #48	; 0x30
 1001734:	f002 f9fc 	bl	1003b30 <encode_uint>
				conv->altform_0c = true;
 1001738:	f8bd 3032 	ldrh.w	r3, [sp, #50]	; 0x32
				bps = encode_uint((uintptr_t)value->ptr, conv,
 100173c:	4682      	mov	sl, r0
				conv->altform_0c = true;
 100173e:	f003 03ef 	and.w	r3, r3, #239	; 0xef
 1001742:	f443 43f0 	orr.w	r3, r3, #30720	; 0x7800
 1001746:	f043 0310 	orr.w	r3, r3, #16
		char sign = 0;
 100174a:	2600      	movs	r6, #0
				conv->altform_0c = true;
 100174c:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
				goto prec_int_pad0;
 1001750:	e745      	b.n	10015de <z_cbvprintf_impl+0x522>
				store_count(conv, value->ptr, count);
 1001752:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	switch ((enum length_mod_enum)conv->length_mod) {
 1001754:	2907      	cmp	r1, #7
 1001756:	f63f aedd 	bhi.w	1001514 <z_cbvprintf_impl+0x458>
 100175a:	e8df f001 	tbb	[pc, r1]
 100175e:	040c      	.short	0x040c
 1001760:	08080c06 	.word	0x08080c06
 1001764:	0c0c      	.short	0x0c0c
		*(signed char *)dp = (signed char)count;
 1001766:	701d      	strb	r5, [r3, #0]
		break;
 1001768:	e6d4      	b.n	1001514 <z_cbvprintf_impl+0x458>
		*(short *)dp = (short)count;
 100176a:	801d      	strh	r5, [r3, #0]
		break;
 100176c:	e6d2      	b.n	1001514 <z_cbvprintf_impl+0x458>
		*(intmax_t *)dp = (intmax_t)count;
 100176e:	17ea      	asrs	r2, r5, #31
 1001770:	e9c3 5200 	strd	r5, r2, [r3]
		break;
 1001774:	e6ce      	b.n	1001514 <z_cbvprintf_impl+0x458>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
 1001776:	601d      	str	r5, [r3, #0]
		break;
 1001778:	e6cc      	b.n	1001514 <z_cbvprintf_impl+0x458>
			bps = "(nil)";
 100177a:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 1001844 <z_cbvprintf_impl+0x788>
 100177e:	4606      	mov	r6, r0
			bpe = bps + 5;
 1001780:	f10a 0805 	add.w	r8, sl, #5
 1001784:	e78e      	b.n	10016a4 <z_cbvprintf_impl+0x5e8>
		} else if (conv->altform_0) {
 1001786:	0711      	lsls	r1, r2, #28
			nj_len += 1U;
 1001788:	bf48      	it	mi
 100178a:	3301      	addmi	r3, #1
 100178c:	e793      	b.n	10016b6 <z_cbvprintf_impl+0x5fa>
					OUTC(pad);
 100178e:	4618      	mov	r0, r3
 1001790:	9303      	str	r3, [sp, #12]
 1001792:	4659      	mov	r1, fp
 1001794:	9b02      	ldr	r3, [sp, #8]
 1001796:	4798      	blx	r3
 1001798:	2800      	cmp	r0, #0
 100179a:	9b03      	ldr	r3, [sp, #12]
 100179c:	da04      	bge.n	10017a8 <z_cbvprintf_impl+0x6ec>
#undef OUTS
#undef OUTC
}
 100179e:	b011      	add	sp, #68	; 0x44
 10017a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				char pad = ' ';
 10017a4:	2320      	movs	r3, #32
 10017a6:	444d      	add	r5, r9
 10017a8:	464a      	mov	r2, r9
				while (width-- > 0) {
 10017aa:	2a00      	cmp	r2, #0
 10017ac:	eba5 0109 	sub.w	r1, r5, r9
 10017b0:	f109 39ff 	add.w	r9, r9, #4294967295
 10017b4:	dceb      	bgt.n	100178e <z_cbvprintf_impl+0x6d2>
 10017b6:	460d      	mov	r5, r1
		if (sign != 0) {
 10017b8:	b136      	cbz	r6, 10017c8 <z_cbvprintf_impl+0x70c>
			OUTC(sign);
 10017ba:	4659      	mov	r1, fp
 10017bc:	4630      	mov	r0, r6
 10017be:	9b02      	ldr	r3, [sp, #8]
 10017c0:	4798      	blx	r3
 10017c2:	2800      	cmp	r0, #0
 10017c4:	dbeb      	blt.n	100179e <z_cbvprintf_impl+0x6e2>
 10017c6:	3501      	adds	r5, #1
			if (conv->altform_0c | conv->altform_0) {
 10017c8:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
 10017cc:	06d9      	lsls	r1, r3, #27
 10017ce:	d401      	bmi.n	10017d4 <z_cbvprintf_impl+0x718>
 10017d0:	071a      	lsls	r2, r3, #28
 10017d2:	d506      	bpl.n	10017e2 <z_cbvprintf_impl+0x726>
				OUTC('0');
 10017d4:	4659      	mov	r1, fp
 10017d6:	2030      	movs	r0, #48	; 0x30
 10017d8:	9b02      	ldr	r3, [sp, #8]
 10017da:	4798      	blx	r3
 10017dc:	2800      	cmp	r0, #0
 10017de:	dbde      	blt.n	100179e <z_cbvprintf_impl+0x6e2>
 10017e0:	3501      	adds	r5, #1
			if (conv->altform_0c) {
 10017e2:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
 10017e6:	06db      	lsls	r3, r3, #27
 10017e8:	d507      	bpl.n	10017fa <z_cbvprintf_impl+0x73e>
				OUTC(conv->specifier);
 10017ea:	4659      	mov	r1, fp
 10017ec:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
 10017f0:	9b02      	ldr	r3, [sp, #8]
 10017f2:	4798      	blx	r3
 10017f4:	2800      	cmp	r0, #0
 10017f6:	dbd2      	blt.n	100179e <z_cbvprintf_impl+0x6e2>
 10017f8:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
 10017fa:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 10017fc:	442e      	add	r6, r5
 10017fe:	1b73      	subs	r3, r6, r5
 1001800:	2b00      	cmp	r3, #0
 1001802:	dc16      	bgt.n	1001832 <z_cbvprintf_impl+0x776>
			OUTS(bps, bpe);
 1001804:	4643      	mov	r3, r8
 1001806:	4652      	mov	r2, sl
 1001808:	4659      	mov	r1, fp
 100180a:	9802      	ldr	r0, [sp, #8]
 100180c:	f002 f9d6 	bl	1003bbc <outs>
 1001810:	2800      	cmp	r0, #0
 1001812:	dbc4      	blt.n	100179e <z_cbvprintf_impl+0x6e2>
 1001814:	4405      	add	r5, r0
		while (width > 0) {
 1001816:	44a9      	add	r9, r5
 1001818:	eba9 0305 	sub.w	r3, r9, r5
 100181c:	2b00      	cmp	r3, #0
 100181e:	f77f ae79 	ble.w	1001514 <z_cbvprintf_impl+0x458>
			OUTC(' ');
 1001822:	4659      	mov	r1, fp
 1001824:	2020      	movs	r0, #32
 1001826:	9b02      	ldr	r3, [sp, #8]
 1001828:	4798      	blx	r3
 100182a:	2800      	cmp	r0, #0
 100182c:	dbb7      	blt.n	100179e <z_cbvprintf_impl+0x6e2>
 100182e:	3501      	adds	r5, #1
			--width;
 1001830:	e7f2      	b.n	1001818 <z_cbvprintf_impl+0x75c>
				OUTC('0');
 1001832:	4659      	mov	r1, fp
 1001834:	2030      	movs	r0, #48	; 0x30
 1001836:	9b02      	ldr	r3, [sp, #8]
 1001838:	4798      	blx	r3
 100183a:	2800      	cmp	r0, #0
 100183c:	dbaf      	blt.n	100179e <z_cbvprintf_impl+0x6e2>
 100183e:	3501      	adds	r5, #1
 1001840:	e7dd      	b.n	10017fe <z_cbvprintf_impl+0x742>
 1001842:	bf00      	nop
 1001844:	01004526 	.word	0x01004526

01001848 <nordicsemi_nrf53_init>:
	__asm__ volatile(
 1001848:	f04f 0220 	mov.w	r2, #32
 100184c:	f3ef 8311 	mrs	r3, BASEPRI
 1001850:	f382 8812 	msr	BASEPRI_MAX, r2
 1001854:	f3bf 8f6f 	isb	sy
        NRFX_CRITICAL_SECTION_EXIT();
    }
    else
#endif
    {
        p_reg->ICACHECNF = (uint32_t)config;
 1001858:	2101      	movs	r1, #1
 100185a:	4a04      	ldr	r2, [pc, #16]	; (100186c <nordicsemi_nrf53_init+0x24>)
 100185c:	f8c2 1540 	str.w	r1, [r2, #1344]	; 0x540
	__asm__ volatile(
 1001860:	f383 8811 	msr	BASEPRI, r3
 1001864:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
 1001868:	2000      	movs	r0, #0
 100186a:	4770      	bx	lr
 100186c:	41080000 	.word	0x41080000

01001870 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
 1001870:	b120      	cbz	r0, 100187c <arch_busy_wait+0xc>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
 1001872:	4b03      	ldr	r3, [pc, #12]	; (1001880 <arch_busy_wait+0x10>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
 1001874:	0180      	lsls	r0, r0, #6
 1001876:	f043 0301 	orr.w	r3, r3, #1
 100187a:	4718      	bx	r3

void arch_busy_wait(uint32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
 100187c:	4770      	bx	lr
 100187e:	bf00      	nop
 1001880:	01004250 	.word	0x01004250

01001884 <z_arm_platform_init>:
	 */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r0, =SystemInit
	bx r0
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	b SystemInit
 1001884:	f001 bc98 	b.w	10031b8 <SystemInit>

01001888 <find_flash_total_size>:
static bool find_flash_total_size(const struct flash_pages_info *info,
				  void *data)
{
	struct _inspect_flash *ctx = (struct _inspect_flash *) data;

	if (ctx->buf_len > info->size) {
 1001888:	6842      	ldr	r2, [r0, #4]
 100188a:	680b      	ldr	r3, [r1, #0]
{
 100188c:	b510      	push	{r4, lr}
	if (ctx->buf_len > info->size) {
 100188e:	4293      	cmp	r3, r2
{
 1001890:	460c      	mov	r4, r1
	if (ctx->buf_len > info->size) {
 1001892:	d906      	bls.n	10018a2 <find_flash_total_size+0x1a>
		LOG_ERR("Buffer size is bigger than page");
 1001894:	4805      	ldr	r0, [pc, #20]	; (10018ac <find_flash_total_size+0x24>)
 1001896:	2145      	movs	r1, #69	; 0x45
 1001898:	f002 f9bb 	bl	1003c12 <z_log_minimal_printk>
		ctx->total_size = 0;
 100189c:	2000      	movs	r0, #0
 100189e:	6060      	str	r0, [r4, #4]
	}

	ctx->total_size += info->size;

	return true;
}
 10018a0:	bd10      	pop	{r4, pc}
	ctx->total_size += info->size;
 10018a2:	684b      	ldr	r3, [r1, #4]
	return true;
 10018a4:	2001      	movs	r0, #1
	ctx->total_size += info->size;
 10018a6:	4413      	add	r3, r2
 10018a8:	604b      	str	r3, [r1, #4]
	return true;
 10018aa:	e7f9      	b.n	10018a0 <find_flash_total_size+0x18>
 10018ac:	01004530 	.word	0x01004530

010018b0 <stream_flash_erase_page>:
{
 10018b0:	b530      	push	{r4, r5, lr}
 10018b2:	4605      	mov	r5, r0
 10018b4:	b085      	sub	sp, #20
	rc = flash_get_page_info_by_offs(ctx->fdev, off, &page);
 10018b6:	68c0      	ldr	r0, [r0, #12]
		union { uintptr_t x; struct flash_pages_info * val; } parm2 = { .val = info };
		return (int) arch_syscall_invoke3(parm0.x, parm1.x, parm2.x, K_SYSCALL_FLASH_GET_PAGE_INFO_BY_OFFS);
	}
#endif
	compiler_barrier();
	return z_impl_flash_get_page_info_by_offs(dev, offset, info);
 10018b8:	aa01      	add	r2, sp, #4
 10018ba:	f002 faec 	bl	1003e96 <z_impl_flash_get_page_info_by_offs>
	if (rc != 0) {
 10018be:	4604      	mov	r4, r0
 10018c0:	b138      	cbz	r0, 10018d2 <stream_flash_erase_page+0x22>
		LOG_ERR("Error %d while getting page info", rc);
 10018c2:	2145      	movs	r1, #69	; 0x45
 10018c4:	4602      	mov	r2, r0
 10018c6:	480c      	ldr	r0, [pc, #48]	; (10018f8 <stream_flash_erase_page+0x48>)
		LOG_ERR("Error %d while erasing page", rc);
 10018c8:	f002 f9a3 	bl	1003c12 <z_log_minimal_printk>
}
 10018cc:	4620      	mov	r0, r4
 10018ce:	b005      	add	sp, #20
 10018d0:	bd30      	pop	{r4, r5, pc}
	if (ctx->last_erased_page_start_offset == page.start_offset) {
 10018d2:	9901      	ldr	r1, [sp, #4]
 10018d4:	6a2b      	ldr	r3, [r5, #32]
 10018d6:	428b      	cmp	r3, r1
 10018d8:	d0f8      	beq.n	10018cc <stream_flash_erase_page+0x1c>
	rc = flash_erase(ctx->fdev, page.start_offset, page.size);
 10018da:	68e8      	ldr	r0, [r5, #12]
 10018dc:	9a02      	ldr	r2, [sp, #8]
{
	const struct flash_driver_api *api =
		(const struct flash_driver_api *)dev->api;
	int rc;

	rc = api->erase(dev, offset, size);
 10018de:	6883      	ldr	r3, [r0, #8]
 10018e0:	689b      	ldr	r3, [r3, #8]
 10018e2:	4798      	blx	r3
	if (rc != 0) {
 10018e4:	4604      	mov	r4, r0
 10018e6:	b118      	cbz	r0, 10018f0 <stream_flash_erase_page+0x40>
		LOG_ERR("Error %d while erasing page", rc);
 10018e8:	4602      	mov	r2, r0
 10018ea:	2145      	movs	r1, #69	; 0x45
 10018ec:	4803      	ldr	r0, [pc, #12]	; (10018fc <stream_flash_erase_page+0x4c>)
 10018ee:	e7eb      	b.n	10018c8 <stream_flash_erase_page+0x18>
		ctx->last_erased_page_start_offset = page.start_offset;
 10018f0:	9b01      	ldr	r3, [sp, #4]
 10018f2:	622b      	str	r3, [r5, #32]
 10018f4:	e7ea      	b.n	10018cc <stream_flash_erase_page+0x1c>
 10018f6:	bf00      	nop
 10018f8:	01004555 	.word	0x01004555
 10018fc:	0100457b 	.word	0x0100457b

01001900 <flash_sync>:
{
 1001900:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (ctx->buf_bytes == 0) {
 1001902:	6885      	ldr	r5, [r0, #8]
{
 1001904:	4604      	mov	r4, r0
	if (ctx->buf_bytes == 0) {
 1001906:	b175      	cbz	r5, 1001926 <flash_sync+0x26>
	size_t write_addr = ctx->offset + ctx->bytes_written;
 1001908:	e9d0 3604 	ldrd	r3, r6, [r0, #16]
					     write_addr + ctx->buf_bytes - 1);
 100190c:	3d01      	subs	r5, #1
	size_t write_addr = ctx->offset + ctx->bytes_written;
 100190e:	441e      	add	r6, r3
		rc = stream_flash_erase_page(ctx,
 1001910:	19a9      	adds	r1, r5, r6
 1001912:	f7ff ffcd 	bl	10018b0 <stream_flash_erase_page>
		if (rc < 0) {
 1001916:	1e05      	subs	r5, r0, #0
 1001918:	da07      	bge.n	100192a <flash_sync+0x2a>
			LOG_ERR("stream_flash_erase_page err %d offset=0x%08zx",
 100191a:	4633      	mov	r3, r6
 100191c:	462a      	mov	r2, r5
 100191e:	2145      	movs	r1, #69	; 0x45
 1001920:	482c      	ldr	r0, [pc, #176]	; (10019d4 <flash_sync+0xd4>)
		LOG_ERR("flash_write error %d offset=0x%08zx", rc,
 1001922:	f002 f976 	bl	1003c12 <z_log_minimal_printk>
}
 1001926:	4628      	mov	r0, r5
 1001928:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	fill_length = flash_get_write_block_size(ctx->fdev);
 100192a:	68e0      	ldr	r0, [r4, #12]
 100192c:	f002 f97e 	bl	1003c2c <flash_get_write_block_size>
	if (ctx->buf_bytes % fill_length) {
 1001930:	68a5      	ldr	r5, [r4, #8]
 1001932:	fbb5 f3f0 	udiv	r3, r5, r0
 1001936:	fb00 5513 	mls	r5, r0, r3, r5
 100193a:	b15d      	cbz	r5, 1001954 <flash_sync+0x54>
		fill_length -= ctx->buf_bytes % fill_length;
 100193c:	1b45      	subs	r5, r0, r5
		filler = flash_get_parameters(ctx->fdev)->erase_value;
 100193e:	68e0      	ldr	r0, [r4, #12]
static inline const struct flash_parameters *z_impl_flash_get_parameters(const struct device *dev)
{
	const struct flash_driver_api *api =
		(const struct flash_driver_api *)dev->api;

	return api->get_parameters(dev);
 1001940:	6883      	ldr	r3, [r0, #8]
 1001942:	68db      	ldr	r3, [r3, #12]
 1001944:	4798      	blx	r3
		memset(ctx->buf + ctx->buf_bytes, filler, fill_length);
 1001946:	6827      	ldr	r7, [r4, #0]
 1001948:	68a3      	ldr	r3, [r4, #8]
 100194a:	7901      	ldrb	r1, [r0, #4]
 100194c:	462a      	mov	r2, r5
 100194e:	18f8      	adds	r0, r7, r3
 1001950:	f002 f9f1 	bl	1003d36 <memset>
	buf_bytes_aligned = ctx->buf_bytes + fill_length;
 1001954:	68a3      	ldr	r3, [r4, #8]
	rc = flash_write(ctx->fdev, write_addr, ctx->buf, buf_bytes_aligned);
 1001956:	68e0      	ldr	r0, [r4, #12]
 1001958:	6822      	ldr	r2, [r4, #0]
	buf_bytes_aligned = ctx->buf_bytes + fill_length;
 100195a:	442b      	add	r3, r5
	rc = api->write(dev, offset, data, len);
 100195c:	6881      	ldr	r1, [r0, #8]
 100195e:	684d      	ldr	r5, [r1, #4]
 1001960:	4631      	mov	r1, r6
 1001962:	47a8      	blx	r5
	if (rc != 0) {
 1001964:	4605      	mov	r5, r0
 1001966:	b120      	cbz	r0, 1001972 <flash_sync+0x72>
		LOG_ERR("flash_write error %d offset=0x%08zx", rc,
 1001968:	4602      	mov	r2, r0
 100196a:	4633      	mov	r3, r6
 100196c:	2145      	movs	r1, #69	; 0x45
 100196e:	481a      	ldr	r0, [pc, #104]	; (10019d8 <flash_sync+0xd8>)
 1001970:	e7d7      	b.n	1001922 <flash_sync+0x22>
	if (ctx->callback) {
 1001972:	69e3      	ldr	r3, [r4, #28]
 1001974:	b9e3      	cbnz	r3, 10019b0 <flash_sync+0xb0>
	ctx->bytes_written += ctx->buf_bytes;
 1001976:	6923      	ldr	r3, [r4, #16]
 1001978:	68a2      	ldr	r2, [r4, #8]
 100197a:	4413      	add	r3, r2
 100197c:	6123      	str	r3, [r4, #16]
	ctx->buf_bytes = 0U;
 100197e:	2300      	movs	r3, #0
 1001980:	60a3      	str	r3, [r4, #8]
	return rc;
 1001982:	e7d0      	b.n	1001926 <flash_sync+0x26>
			ctx->buf[i] = ~ctx->buf[i];
 1001984:	5c53      	ldrb	r3, [r2, r1]
 1001986:	43db      	mvns	r3, r3
 1001988:	5453      	strb	r3, [r2, r1]
		for (int i = 0; i < ctx->buf_bytes; i++) {
 100198a:	3101      	adds	r1, #1
 100198c:	68a3      	ldr	r3, [r4, #8]
			ctx->buf[i] = ~ctx->buf[i];
 100198e:	6822      	ldr	r2, [r4, #0]
		for (int i = 0; i < ctx->buf_bytes; i++) {
 1001990:	428b      	cmp	r3, r1
 1001992:	d8f7      	bhi.n	1001984 <flash_sync+0x84>
		rc = flash_read(ctx->fdev, write_addr, ctx->buf,
 1001994:	68e0      	ldr	r0, [r4, #12]
	return api->read(dev, offset, data, len);
 1001996:	6881      	ldr	r1, [r0, #8]
 1001998:	680f      	ldr	r7, [r1, #0]
 100199a:	4631      	mov	r1, r6
 100199c:	47b8      	blx	r7
		if (rc != 0) {
 100199e:	4607      	mov	r7, r0
 10019a0:	b140      	cbz	r0, 10019b4 <flash_sync+0xb4>
			LOG_ERR("flash read failed: %d", rc);
 10019a2:	4602      	mov	r2, r0
 10019a4:	2145      	movs	r1, #69	; 0x45
 10019a6:	480d      	ldr	r0, [pc, #52]	; (10019dc <flash_sync+0xdc>)
 10019a8:	f002 f933 	bl	1003c12 <z_log_minimal_printk>
			return rc;
 10019ac:	463d      	mov	r5, r7
 10019ae:	e7ba      	b.n	1001926 <flash_sync+0x26>
		for (int i = 0; i < ctx->buf_bytes; i++) {
 10019b0:	4601      	mov	r1, r0
 10019b2:	e7eb      	b.n	100198c <flash_sync+0x8c>
		rc = ctx->callback(ctx->buf, ctx->buf_bytes, write_addr);
 10019b4:	4632      	mov	r2, r6
 10019b6:	69e3      	ldr	r3, [r4, #28]
 10019b8:	68a1      	ldr	r1, [r4, #8]
 10019ba:	6820      	ldr	r0, [r4, #0]
 10019bc:	4798      	blx	r3
		if (rc != 0) {
 10019be:	4606      	mov	r6, r0
 10019c0:	2800      	cmp	r0, #0
 10019c2:	d0d8      	beq.n	1001976 <flash_sync+0x76>
			LOG_ERR("callback failed: %d", rc);
 10019c4:	4602      	mov	r2, r0
 10019c6:	2145      	movs	r1, #69	; 0x45
 10019c8:	4805      	ldr	r0, [pc, #20]	; (10019e0 <flash_sync+0xe0>)
 10019ca:	f002 f922 	bl	1003c12 <z_log_minimal_printk>
			return rc;
 10019ce:	4635      	mov	r5, r6
 10019d0:	e7a9      	b.n	1001926 <flash_sync+0x26>
 10019d2:	bf00      	nop
 10019d4:	0100459c 	.word	0x0100459c
 10019d8:	010045cf 	.word	0x010045cf
 10019dc:	010045f8 	.word	0x010045f8
 10019e0:	01004613 	.word	0x01004613

010019e4 <stream_flash_init>:

int stream_flash_init(struct stream_flash_ctx *ctx, const struct device *fdev,
		      uint8_t *buf, size_t buf_len, size_t offset, size_t size,
		      stream_flash_callback_t cb)
{
 10019e4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 10019e8:	460d      	mov	r5, r1
 10019ea:	e9dd 860a 	ldrd	r8, r6, [sp, #40]	; 0x28
 10019ee:	4691      	mov	r9, r2
 10019f0:	461f      	mov	r7, r3
	if (!ctx || !fdev || !buf) {
 10019f2:	4604      	mov	r4, r0
 10019f4:	b920      	cbnz	r0, 1001a00 <stream_flash_init+0x1c>
	}

	if ((offset + size) > inspect_flash_ctx.total_size ||
	    offset % flash_get_write_block_size(fdev)) {
		LOG_ERR("Incorrect parameter");
		return -EFAULT;
 10019f6:	f06f 000d 	mvn.w	r0, #13
#ifdef CONFIG_STREAM_FLASH_ERASE
	ctx->last_erased_page_start_offset = -1;
#endif

	return 0;
}
 10019fa:	b003      	add	sp, #12
 10019fc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (!ctx || !fdev || !buf) {
 1001a00:	2900      	cmp	r1, #0
 1001a02:	d0f8      	beq.n	10019f6 <stream_flash_init+0x12>
 1001a04:	2a00      	cmp	r2, #0
 1001a06:	d0f6      	beq.n	10019f6 <stream_flash_init+0x12>
	struct _inspect_flash inspect_flash_ctx = {
 1001a08:	9300      	str	r3, [sp, #0]
 1001a0a:	2300      	movs	r3, #0
	if (buf_len % flash_get_write_block_size(fdev)) {
 1001a0c:	4608      	mov	r0, r1
	struct _inspect_flash inspect_flash_ctx = {
 1001a0e:	9301      	str	r3, [sp, #4]
	if (buf_len % flash_get_write_block_size(fdev)) {
 1001a10:	f002 f90c 	bl	1003c2c <flash_get_write_block_size>
 1001a14:	fbb7 f3f0 	udiv	r3, r7, r0
 1001a18:	fb03 7010 	mls	r0, r3, r0, r7
 1001a1c:	b120      	cbz	r0, 1001a28 <stream_flash_init+0x44>
		LOG_ERR("Buffer size is not aligned to minimal write-block-size");
 1001a1e:	2145      	movs	r1, #69	; 0x45
 1001a20:	4817      	ldr	r0, [pc, #92]	; (1001a80 <stream_flash_init+0x9c>)
		LOG_ERR("Incorrect parameter");
 1001a22:	f002 f8f6 	bl	1003c12 <z_log_minimal_printk>
 1001a26:	e7e6      	b.n	10019f6 <stream_flash_init+0x12>
	flash_page_foreach(fdev, find_flash_total_size, &inspect_flash_ctx);
 1001a28:	466a      	mov	r2, sp
 1001a2a:	4628      	mov	r0, r5
 1001a2c:	4915      	ldr	r1, [pc, #84]	; (1001a84 <stream_flash_init+0xa0>)
 1001a2e:	f002 fa36 	bl	1003e9e <flash_page_foreach>
	if (inspect_flash_ctx.total_size == 0) {
 1001a32:	9b01      	ldr	r3, [sp, #4]
 1001a34:	2b00      	cmp	r3, #0
 1001a36:	d0de      	beq.n	10019f6 <stream_flash_init+0x12>
	if ((offset + size) > inspect_flash_ctx.total_size ||
 1001a38:	eb06 0208 	add.w	r2, r6, r8
 1001a3c:	4293      	cmp	r3, r2
 1001a3e:	d202      	bcs.n	1001a46 <stream_flash_init+0x62>
		LOG_ERR("Incorrect parameter");
 1001a40:	2145      	movs	r1, #69	; 0x45
 1001a42:	4811      	ldr	r0, [pc, #68]	; (1001a88 <stream_flash_init+0xa4>)
 1001a44:	e7ed      	b.n	1001a22 <stream_flash_init+0x3e>
	    offset % flash_get_write_block_size(fdev)) {
 1001a46:	4628      	mov	r0, r5
 1001a48:	f002 f8f0 	bl	1003c2c <flash_get_write_block_size>
 1001a4c:	fbb8 f3f0 	udiv	r3, r8, r0
 1001a50:	fb03 8010 	mls	r0, r3, r0, r8
	if ((offset + size) > inspect_flash_ctx.total_size ||
 1001a54:	2800      	cmp	r0, #0
 1001a56:	d1f3      	bne.n	1001a40 <stream_flash_init+0x5c>
	ctx->buf_len = buf_len;
 1001a58:	e9c4 9700 	strd	r9, r7, [r4]
	ctx->fdev = fdev;
 1001a5c:	60e5      	str	r5, [r4, #12]
	ctx->bytes_written = 0;
 1001a5e:	6120      	str	r0, [r4, #16]
	ctx->buf_bytes = 0U;
 1001a60:	60a0      	str	r0, [r4, #8]
	ctx->offset = offset;
 1001a62:	f8c4 8014 	str.w	r8, [r4, #20]
	ctx->available = (size == 0 ? inspect_flash_ctx.total_size - offset :
 1001a66:	b916      	cbnz	r6, 1001a6e <stream_flash_init+0x8a>
 1001a68:	9e01      	ldr	r6, [sp, #4]
 1001a6a:	eba6 0608 	sub.w	r6, r6, r8
	ctx->callback = cb;
 1001a6e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
	return 0;
 1001a70:	2000      	movs	r0, #0
	ctx->callback = cb;
 1001a72:	61e3      	str	r3, [r4, #28]
	ctx->last_erased_page_start_offset = -1;
 1001a74:	f04f 33ff 	mov.w	r3, #4294967295
	ctx->available = (size == 0 ? inspect_flash_ctx.total_size - offset :
 1001a78:	61a6      	str	r6, [r4, #24]
	ctx->last_erased_page_start_offset = -1;
 1001a7a:	6223      	str	r3, [r4, #32]
	return 0;
 1001a7c:	e7bd      	b.n	10019fa <stream_flash_init+0x16>
 1001a7e:	bf00      	nop
 1001a80:	0100462c 	.word	0x0100462c
 1001a84:	01001889 	.word	0x01001889
 1001a88:	01004668 	.word	0x01004668

01001a8c <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
 1001a8c:	4901      	ldr	r1, [pc, #4]	; (1001a94 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
 1001a8e:	2210      	movs	r2, #16
	str	r2, [r1]
 1001a90:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
 1001a92:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
 1001a94:	e000ed10 	.word	0xe000ed10

01001a98 <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
 1001a98:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
 1001a9a:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
 1001a9c:	f381 8811 	msr	BASEPRI, r1

	wfe
 1001aa0:	bf20      	wfe

	msr	BASEPRI, r0
 1001aa2:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
 1001aa6:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
 1001aa8:	4770      	bx	lr
 1001aaa:	bf00      	nop

01001aac <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
 1001aac:	b537      	push	{r0, r1, r2, r4, r5, lr}
 1001aae:	4605      	mov	r5, r0

	if (esf != NULL) {
 1001ab0:	460c      	mov	r4, r1
 1001ab2:	b1c9      	cbz	r1, 1001ae8 <z_arm_fatal_error+0x3c>
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
 1001ab4:	688b      	ldr	r3, [r1, #8]
 1001ab6:	4810      	ldr	r0, [pc, #64]	; (1001af8 <z_arm_fatal_error+0x4c>)
 1001ab8:	9300      	str	r3, [sp, #0]
 1001aba:	e9d1 2300 	ldrd	r2, r3, [r1]
 1001abe:	2145      	movs	r1, #69	; 0x45
 1001ac0:	f002 f8a7 	bl	1003c12 <z_log_minimal_printk>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
 1001ac4:	6963      	ldr	r3, [r4, #20]
 1001ac6:	2145      	movs	r1, #69	; 0x45
 1001ac8:	9300      	str	r3, [sp, #0]
 1001aca:	e9d4 2303 	ldrd	r2, r3, [r4, #12]
 1001ace:	480b      	ldr	r0, [pc, #44]	; (1001afc <z_arm_fatal_error+0x50>)
 1001ad0:	f002 f89f 	bl	1003c12 <z_log_minimal_printk>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
 1001ad4:	2145      	movs	r1, #69	; 0x45
 1001ad6:	69e2      	ldr	r2, [r4, #28]
 1001ad8:	4809      	ldr	r0, [pc, #36]	; (1001b00 <z_arm_fatal_error+0x54>)
 1001ada:	f002 f89a 	bl	1003c12 <z_log_minimal_printk>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
 1001ade:	2145      	movs	r1, #69	; 0x45
 1001ae0:	69a2      	ldr	r2, [r4, #24]
 1001ae2:	4808      	ldr	r0, [pc, #32]	; (1001b04 <z_arm_fatal_error+0x58>)
 1001ae4:	f002 f895 	bl	1003c12 <z_log_minimal_printk>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
 1001ae8:	4621      	mov	r1, r4
 1001aea:	4628      	mov	r0, r5
}
 1001aec:	b003      	add	sp, #12
 1001aee:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	z_fatal_error(reason, esf);
 1001af2:	f001 bd9b 	b.w	100362c <z_fatal_error>
 1001af6:	bf00      	nop
 1001af8:	0100468e 	.word	0x0100468e
 1001afc:	010046c2 	.word	0x010046c2
 1001b00:	010046f6 	.word	0x010046f6
 1001b04:	0100470a 	.word	0x0100470a

01001b08 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
 1001b08:	b243      	sxtb	r3, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 1001b0a:	2b00      	cmp	r3, #0
 1001b0c:	db08      	blt.n	1001b20 <arch_irq_enable+0x18>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 1001b0e:	2201      	movs	r2, #1
 1001b10:	f000 001f 	and.w	r0, r0, #31
 1001b14:	fa02 f000 	lsl.w	r0, r2, r0
 1001b18:	4a02      	ldr	r2, [pc, #8]	; (1001b24 <arch_irq_enable+0x1c>)
 1001b1a:	095b      	lsrs	r3, r3, #5
 1001b1c:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
 1001b20:	4770      	bx	lr
 1001b22:	bf00      	nop
 1001b24:	e000e100 	.word	0xe000e100

01001b28 <arch_irq_is_enabled>:
	NVIC_DisableIRQ((IRQn_Type)irq);
}

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
 1001b28:	4b05      	ldr	r3, [pc, #20]	; (1001b40 <arch_irq_is_enabled+0x18>)
 1001b2a:	0942      	lsrs	r2, r0, #5
 1001b2c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 1001b30:	2301      	movs	r3, #1
 1001b32:	f000 001f 	and.w	r0, r0, #31
 1001b36:	fa03 f000 	lsl.w	r0, r3, r0
}
 1001b3a:	4010      	ands	r0, r2
 1001b3c:	4770      	bx	lr
 1001b3e:	bf00      	nop
 1001b40:	e000e100 	.word	0xe000e100

01001b44 <z_arm_irq_priority_set>:
 * The priority is verified if ASSERT_ON is enabled. The maximum number
 * of priority levels is a little complex, as there are some hardware
 * priority levels which are reserved.
 */
void z_arm_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
 1001b44:	b538      	push	{r3, r4, r5, lr}
			prio = _EXC_ZERO_LATENCY_IRQS_PRIO;
		} else {
			/* Use caller supplied prio level as-is */
		}
	} else {
		prio += _IRQ_PRIO_OFFSET;
 1001b46:	1c4c      	adds	r4, r1, #1
	/* The last priority level is also used by PendSV exception, but
	 * allow other interrupts to use the same level, even if it ends up
	 * affecting performance (can still be useful on systems with a
	 * reduced set of priorities, like Cortex-M0/M0+).
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
 1001b48:	2c07      	cmp	r4, #7
{
 1001b4a:	4605      	mov	r5, r0
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
 1001b4c:	d908      	bls.n	1001b60 <z_arm_irq_priority_set+0x1c>
 1001b4e:	490d      	ldr	r1, [pc, #52]	; (1001b84 <z_arm_irq_priority_set+0x40>)
 1001b50:	480d      	ldr	r0, [pc, #52]	; (1001b88 <z_arm_irq_priority_set+0x44>)
 1001b52:	225b      	movs	r2, #91	; 0x5b
 1001b54:	f002 f84f 	bl	1003bf6 <assert_print>
 1001b58:	215b      	movs	r1, #91	; 0x5b
 1001b5a:	480a      	ldr	r0, [pc, #40]	; (1001b84 <z_arm_irq_priority_set+0x40>)
 1001b5c:	f002 f844 	bl	1003be8 <assert_post_action>
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
 1001b60:	b26b      	sxtb	r3, r5
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 1001b62:	2b00      	cmp	r3, #0
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1001b64:	bfac      	ite	ge
 1001b66:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1001b6a:	4b08      	ldrlt	r3, [pc, #32]	; (1001b8c <z_arm_irq_priority_set+0x48>)
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1001b6c:	ea4f 1444 	mov.w	r4, r4, lsl #5
 1001b70:	b2e4      	uxtb	r4, r4
 1001b72:	bfab      	itete	ge
 1001b74:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1001b78:	f005 050f 	andlt.w	r5, r5, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1001b7c:	f883 4300 	strbge.w	r4, [r3, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1001b80:	555c      	strblt	r4, [r3, r5]
}
 1001b82:	bd38      	pop	{r3, r4, r5, pc}
 1001b84:	0100473d 	.word	0x0100473d
 1001b88:	010044ec 	.word	0x010044ec
 1001b8c:	e000ed14 	.word	0xe000ed14

01001b90 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
 1001b90:	bf30      	wfi
    b z_SysNmiOnReset
 1001b92:	f7ff bffd 	b.w	1001b90 <z_SysNmiOnReset>
 1001b96:	bf00      	nop

01001b98 <z_arm_prep_c>:
 *
 * This routine prepares for the execution of and runs C code.
 *
 */
void z_arm_prep_c(void)
{
 1001b98:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
 1001b9a:	4b08      	ldr	r3, [pc, #32]	; (1001bbc <z_arm_prep_c+0x24>)
 1001b9c:	4a08      	ldr	r2, [pc, #32]	; (1001bc0 <z_arm_prep_c+0x28>)
 1001b9e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 1001ba2:	6093      	str	r3, [r2, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 1001ba4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 1001ba8:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
 1001bac:	f001 fda2 	bl	10036f4 <z_bss_zero>
	z_data_copy();
 1001bb0:	f001 fde2 	bl	1003778 <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
 1001bb4:	f000 fa56 	bl	1002064 <z_arm_interrupt_init>
	z_cstart();
 1001bb8:	f001 fda8 	bl	100370c <z_cstart>
 1001bbc:	01000000 	.word	0x01000000
 1001bc0:	e000ed00 	.word	0xe000ed00

01001bc4 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
 1001bc4:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
 1001bc8:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
 1001bca:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
 1001bce:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
 1001bd2:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
 1001bd4:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
 1001bd8:	2902      	cmp	r1, #2
    beq _oops
 1001bda:	d0ff      	beq.n	1001bdc <_oops>

01001bdc <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
 1001bdc:	b501      	push	{r0, lr}
    push {r1, r2}
    push {r4-r11}
    mov  r1, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    bl z_do_kernel_oops
 1001bde:	f002 f86f 	bl	1003cc0 <z_do_kernel_oops>
     * the MSP to its value prior to entering the function
     */
    add sp, #40
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    pop {r0, pc}
 1001be2:	bd01      	pop	{r0, pc}

01001be4 <z_arm_switch_to_main_no_multithreading>:

#if !defined(CONFIG_MULTITHREADING) && defined(CONFIG_CPU_CORTEX_M)

FUNC_NORETURN void z_arm_switch_to_main_no_multithreading(
	k_thread_entry_t main_entry, void *p1, void *p2, void *p3)
{
 1001be4:	4604      	mov	r4, r0
 1001be6:	4608      	mov	r0, r1
 1001be8:	4611      	mov	r1, r2
 1001bea:	461a      	mov	r2, r3
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure PSPLIM is RAZ/WI
  (void)ProcStackPtrLimit;
#else
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 1001bec:	2300      	movs	r3, #0
 1001bee:	f383 880b 	msr	PSPLIM, r3
	 */
	register void *p1_inreg __asm__("r0") = p1;
	register void *p2_inreg __asm__("r1") = p2;
	register void *p3_inreg __asm__("r2") = p3;

	__asm__ volatile (
 1001bf2:	4b0a      	ldr	r3, [pc, #40]	; (1001c1c <loop+0x2>)
 1001bf4:	2520      	movs	r5, #32
 1001bf6:	f5a3 6680 	sub.w	r6, r3, #1024	; 0x400
 1001bfa:	f386 880b 	msr	PSPLIM, r6
 1001bfe:	f383 8809 	msr	PSP, r3
 1001c02:	b663      	cpsie	if
 1001c04:	f04f 0300 	mov.w	r3, #0
 1001c08:	f383 8811 	msr	BASEPRI, r3
 1001c0c:	f3bf 8f6f 	isb	sy
 1001c10:	47a0      	blx	r4
 1001c12:	f385 8811 	msr	BASEPRI, r5
 1001c16:	f3bf 8f6f 	isb	sy

01001c1a <loop>:
 1001c1a:	e7fe      	b.n	1001c1a <loop>
	, [_psplim]"r" (psplim)
#endif
	:
	);

	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
 1001c1c:	21000548 	.word	0x21000548

01001c20 <_isr_wrapper>:
 *
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
 1001c20:	b501      	push	{r0, lr}
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
 1001c22:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
 1001c26:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
 1001c2a:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
 1001c2e:	4904      	ldr	r1, [pc, #16]	; (1001c40 <_isr_wrapper+0x20>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
 1001c30:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
 1001c32:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
 1001c34:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
 1001c36:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
 1001c3a:	4902      	ldr	r1, [pc, #8]	; (1001c44 <_isr_wrapper+0x24>)
	bx r1
 1001c3c:	4708      	bx	r1
 1001c3e:	0000      	.short	0x0000
	ldr r1, =_sw_isr_table
 1001c40:	010040dc 	.word	0x010040dc
	ldr r1, =z_arm_int_exit
 1001c44:	01001c49 	.word	0x01001c49

01001c48 <z_arm_exc_exit>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
 1001c48:	4770      	bx	lr
 1001c4a:	bf00      	nop

01001c4c <usage_fault.constprop.0>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t usage_fault(const z_arch_esf_t *esf)
 1001c4c:	b538      	push	{r3, r4, r5, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
 1001c4e:	4c21      	ldr	r4, [pc, #132]	; (1001cd4 <usage_fault.constprop.0+0x88>)
	PR_FAULT_INFO("***** USAGE FAULT *****");
 1001c50:	2145      	movs	r1, #69	; 0x45
 1001c52:	4821      	ldr	r0, [pc, #132]	; (1001cd8 <usage_fault.constprop.0+0x8c>)
 1001c54:	f001 ffdd 	bl	1003c12 <z_log_minimal_printk>
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
 1001c58:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1001c5a:	019d      	lsls	r5, r3, #6
 1001c5c:	d503      	bpl.n	1001c66 <usage_fault.constprop.0+0x1a>
		PR_FAULT_INFO("  Division by zero");
 1001c5e:	2145      	movs	r1, #69	; 0x45
 1001c60:	481e      	ldr	r0, [pc, #120]	; (1001cdc <usage_fault.constprop.0+0x90>)
 1001c62:	f001 ffd6 	bl	1003c12 <z_log_minimal_printk>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
 1001c66:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1001c68:	01dc      	lsls	r4, r3, #7
 1001c6a:	d503      	bpl.n	1001c74 <usage_fault.constprop.0+0x28>
		PR_FAULT_INFO("  Unaligned memory access");
 1001c6c:	2145      	movs	r1, #69	; 0x45
 1001c6e:	481c      	ldr	r0, [pc, #112]	; (1001ce0 <usage_fault.constprop.0+0x94>)
 1001c70:	f001 ffcf 	bl	1003c12 <z_log_minimal_printk>
	}
#if defined(CONFIG_ARMV8_M_MAINLINE)
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
 1001c74:	4d17      	ldr	r5, [pc, #92]	; (1001cd4 <usage_fault.constprop.0+0x88>)
 1001c76:	6aac      	ldr	r4, [r5, #40]	; 0x28
 1001c78:	f414 1480 	ands.w	r4, r4, #1048576	; 0x100000
 1001c7c:	d004      	beq.n	1001c88 <usage_fault.constprop.0+0x3c>
		PR_FAULT_INFO("  Stack overflow (context area not valid)");
 1001c7e:	2145      	movs	r1, #69	; 0x45
 1001c80:	4818      	ldr	r0, [pc, #96]	; (1001ce4 <usage_fault.constprop.0+0x98>)
 1001c82:	f001 ffc6 	bl	1003c12 <z_log_minimal_printk>
		 * prevents the context area to be loaded on the stack upon
		 * UsageFault exception entry. As a result, we cannot rely
		 * on the reported faulty instruction address, to determine
		 * the instruction that triggered the stack overflow.
		 */
		reason = K_ERR_STACK_CHK_FAIL;
 1001c86:	2402      	movs	r4, #2
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
 1001c88:	6aab      	ldr	r3, [r5, #40]	; 0x28
 1001c8a:	0318      	lsls	r0, r3, #12
 1001c8c:	d503      	bpl.n	1001c96 <usage_fault.constprop.0+0x4a>
		PR_FAULT_INFO("  No coprocessor instructions");
 1001c8e:	2145      	movs	r1, #69	; 0x45
 1001c90:	4815      	ldr	r0, [pc, #84]	; (1001ce8 <usage_fault.constprop.0+0x9c>)
 1001c92:	f001 ffbe 	bl	1003c12 <z_log_minimal_printk>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
 1001c96:	4d0f      	ldr	r5, [pc, #60]	; (1001cd4 <usage_fault.constprop.0+0x88>)
 1001c98:	6aab      	ldr	r3, [r5, #40]	; 0x28
 1001c9a:	0359      	lsls	r1, r3, #13
 1001c9c:	d503      	bpl.n	1001ca6 <usage_fault.constprop.0+0x5a>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
 1001c9e:	2145      	movs	r1, #69	; 0x45
 1001ca0:	4812      	ldr	r0, [pc, #72]	; (1001cec <usage_fault.constprop.0+0xa0>)
 1001ca2:	f001 ffb6 	bl	1003c12 <z_log_minimal_printk>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
 1001ca6:	6aab      	ldr	r3, [r5, #40]	; 0x28
 1001ca8:	039a      	lsls	r2, r3, #14
 1001caa:	d503      	bpl.n	1001cb4 <usage_fault.constprop.0+0x68>
		PR_FAULT_INFO("  Illegal use of the EPSR");
 1001cac:	2145      	movs	r1, #69	; 0x45
 1001cae:	4810      	ldr	r0, [pc, #64]	; (1001cf0 <usage_fault.constprop.0+0xa4>)
 1001cb0:	f001 ffaf 	bl	1003c12 <z_log_minimal_printk>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
 1001cb4:	4d07      	ldr	r5, [pc, #28]	; (1001cd4 <usage_fault.constprop.0+0x88>)
 1001cb6:	6aab      	ldr	r3, [r5, #40]	; 0x28
 1001cb8:	03db      	lsls	r3, r3, #15
 1001cba:	d503      	bpl.n	1001cc4 <usage_fault.constprop.0+0x78>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
 1001cbc:	2145      	movs	r1, #69	; 0x45
 1001cbe:	480d      	ldr	r0, [pc, #52]	; (1001cf4 <usage_fault.constprop.0+0xa8>)
 1001cc0:	f001 ffa7 	bl	1003c12 <z_log_minimal_printk>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
 1001cc4:	6aab      	ldr	r3, [r5, #40]	; 0x28

	return reason;
}
 1001cc6:	4620      	mov	r0, r4
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
 1001cc8:	ea6f 4303 	mvn.w	r3, r3, lsl #16
 1001ccc:	ea6f 4313 	mvn.w	r3, r3, lsr #16
 1001cd0:	62ab      	str	r3, [r5, #40]	; 0x28
}
 1001cd2:	bd38      	pop	{r3, r4, r5, pc}
 1001cd4:	e000ed00 	.word	0xe000ed00
 1001cd8:	01004773 	.word	0x01004773
 1001cdc:	01004790 	.word	0x01004790
 1001ce0:	010047a8 	.word	0x010047a8
 1001ce4:	010047c7 	.word	0x010047c7
 1001ce8:	010047f6 	.word	0x010047f6
 1001cec:	01004819 	.word	0x01004819
 1001cf0:	01004843 	.word	0x01004843
 1001cf4:	01004862 	.word	0x01004862

01001cf8 <bus_fault.constprop.0>:
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
 1001cf8:	b570      	push	{r4, r5, r6, lr}
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
 1001cfa:	4c20      	ldr	r4, [pc, #128]	; (1001d7c <bus_fault.constprop.0+0x84>)
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
 1001cfc:	4606      	mov	r6, r0
 1001cfe:	460d      	mov	r5, r1
	PR_FAULT_INFO("***** BUS FAULT *****");
 1001d00:	481f      	ldr	r0, [pc, #124]	; (1001d80 <bus_fault.constprop.0+0x88>)
 1001d02:	2145      	movs	r1, #69	; 0x45
 1001d04:	f001 ff85 	bl	1003c12 <z_log_minimal_printk>
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
 1001d08:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1001d0a:	04db      	lsls	r3, r3, #19
 1001d0c:	d503      	bpl.n	1001d16 <bus_fault.constprop.0+0x1e>
		PR_FAULT_INFO("  Stacking error");
 1001d0e:	2145      	movs	r1, #69	; 0x45
 1001d10:	481c      	ldr	r0, [pc, #112]	; (1001d84 <bus_fault.constprop.0+0x8c>)
 1001d12:	f001 ff7e 	bl	1003c12 <z_log_minimal_printk>
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
 1001d16:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1001d18:	051c      	lsls	r4, r3, #20
 1001d1a:	d503      	bpl.n	1001d24 <bus_fault.constprop.0+0x2c>
		PR_FAULT_INFO("  Unstacking error");
 1001d1c:	2145      	movs	r1, #69	; 0x45
 1001d1e:	481a      	ldr	r0, [pc, #104]	; (1001d88 <bus_fault.constprop.0+0x90>)
 1001d20:	f001 ff77 	bl	1003c12 <z_log_minimal_printk>
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
 1001d24:	4c15      	ldr	r4, [pc, #84]	; (1001d7c <bus_fault.constprop.0+0x84>)
 1001d26:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1001d28:	0598      	lsls	r0, r3, #22
 1001d2a:	d510      	bpl.n	1001d4e <bus_fault.constprop.0+0x56>
		PR_FAULT_INFO("  Precise data bus error");
 1001d2c:	2145      	movs	r1, #69	; 0x45
 1001d2e:	4817      	ldr	r0, [pc, #92]	; (1001d8c <bus_fault.constprop.0+0x94>)
 1001d30:	f001 ff6f 	bl	1003c12 <z_log_minimal_printk>
		STORE_xFAR(bfar, SCB->BFAR);
 1001d34:	6ba2      	ldr	r2, [r4, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
 1001d36:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1001d38:	0419      	lsls	r1, r3, #16
 1001d3a:	d508      	bpl.n	1001d4e <bus_fault.constprop.0+0x56>
			PR_EXC("  BFAR Address: 0x%x", bfar);
 1001d3c:	2145      	movs	r1, #69	; 0x45
 1001d3e:	4814      	ldr	r0, [pc, #80]	; (1001d90 <bus_fault.constprop.0+0x98>)
 1001d40:	f001 ff67 	bl	1003c12 <z_log_minimal_printk>
			if (from_hard_fault != 0) {
 1001d44:	b11e      	cbz	r6, 1001d4e <bus_fault.constprop.0+0x56>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
 1001d46:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1001d48:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 1001d4c:	62a3      	str	r3, [r4, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
 1001d4e:	4c0b      	ldr	r4, [pc, #44]	; (1001d7c <bus_fault.constprop.0+0x84>)
 1001d50:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1001d52:	055a      	lsls	r2, r3, #21
 1001d54:	d503      	bpl.n	1001d5e <bus_fault.constprop.0+0x66>
		PR_FAULT_INFO("  Imprecise data bus error");
 1001d56:	2145      	movs	r1, #69	; 0x45
 1001d58:	480e      	ldr	r0, [pc, #56]	; (1001d94 <bus_fault.constprop.0+0x9c>)
 1001d5a:	f001 ff5a 	bl	1003c12 <z_log_minimal_printk>
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
 1001d5e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1001d60:	05db      	lsls	r3, r3, #23
 1001d62:	d503      	bpl.n	1001d6c <bus_fault.constprop.0+0x74>
		PR_FAULT_INFO("  Instruction bus error");
 1001d64:	2145      	movs	r1, #69	; 0x45
 1001d66:	480c      	ldr	r0, [pc, #48]	; (1001d98 <bus_fault.constprop.0+0xa0>)
 1001d68:	f001 ff53 	bl	1003c12 <z_log_minimal_printk>
	*recoverable = memory_fault_recoverable(esf, true);
 1001d6c:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
 1001d6e:	4a03      	ldr	r2, [pc, #12]	; (1001d7c <bus_fault.constprop.0+0x84>)
 1001d70:	6a93      	ldr	r3, [r2, #40]	; 0x28
 1001d72:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
 1001d76:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
 1001d78:	7028      	strb	r0, [r5, #0]
}
 1001d7a:	bd70      	pop	{r4, r5, r6, pc}
 1001d7c:	e000ed00 	.word	0xe000ed00
 1001d80:	01004892 	.word	0x01004892
 1001d84:	010048ad 	.word	0x010048ad
 1001d88:	010048c3 	.word	0x010048c3
 1001d8c:	010048db 	.word	0x010048db
 1001d90:	010048f9 	.word	0x010048f9
 1001d94:	01004913 	.word	0x01004913
 1001d98:	01004933 	.word	0x01004933

01001d9c <mem_manage_fault.constprop.0>:
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
 1001d9c:	b570      	push	{r4, r5, r6, lr}
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
 1001d9e:	4c27      	ldr	r4, [pc, #156]	; (1001e3c <mem_manage_fault.constprop.0+0xa0>)
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
 1001da0:	4606      	mov	r6, r0
 1001da2:	460d      	mov	r5, r1
	PR_FAULT_INFO("***** MPU FAULT *****");
 1001da4:	4826      	ldr	r0, [pc, #152]	; (1001e40 <mem_manage_fault.constprop.0+0xa4>)
 1001da6:	2145      	movs	r1, #69	; 0x45
 1001da8:	f001 ff33 	bl	1003c12 <z_log_minimal_printk>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
 1001dac:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1001dae:	06d8      	lsls	r0, r3, #27
 1001db0:	d503      	bpl.n	1001dba <mem_manage_fault.constprop.0+0x1e>
		PR_FAULT_INFO("  Stacking error (context area might be"
 1001db2:	2145      	movs	r1, #69	; 0x45
 1001db4:	4823      	ldr	r0, [pc, #140]	; (1001e44 <mem_manage_fault.constprop.0+0xa8>)
 1001db6:	f001 ff2c 	bl	1003c12 <z_log_minimal_printk>
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
 1001dba:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1001dbc:	0719      	lsls	r1, r3, #28
 1001dbe:	d503      	bpl.n	1001dc8 <mem_manage_fault.constprop.0+0x2c>
		PR_FAULT_INFO("  Unstacking error");
 1001dc0:	2145      	movs	r1, #69	; 0x45
 1001dc2:	4821      	ldr	r0, [pc, #132]	; (1001e48 <mem_manage_fault.constprop.0+0xac>)
 1001dc4:	f001 ff25 	bl	1003c12 <z_log_minimal_printk>
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
 1001dc8:	4c1c      	ldr	r4, [pc, #112]	; (1001e3c <mem_manage_fault.constprop.0+0xa0>)
 1001dca:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1001dcc:	079a      	lsls	r2, r3, #30
 1001dce:	d510      	bpl.n	1001df2 <mem_manage_fault.constprop.0+0x56>
		PR_FAULT_INFO("  Data Access Violation");
 1001dd0:	2145      	movs	r1, #69	; 0x45
 1001dd2:	481e      	ldr	r0, [pc, #120]	; (1001e4c <mem_manage_fault.constprop.0+0xb0>)
 1001dd4:	f001 ff1d 	bl	1003c12 <z_log_minimal_printk>
		uint32_t temp = SCB->MMFAR;
 1001dd8:	6b62      	ldr	r2, [r4, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
 1001dda:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1001ddc:	061b      	lsls	r3, r3, #24
 1001dde:	d508      	bpl.n	1001df2 <mem_manage_fault.constprop.0+0x56>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
 1001de0:	2145      	movs	r1, #69	; 0x45
 1001de2:	481b      	ldr	r0, [pc, #108]	; (1001e50 <mem_manage_fault.constprop.0+0xb4>)
 1001de4:	f001 ff15 	bl	1003c12 <z_log_minimal_printk>
			if (from_hard_fault != 0) {
 1001de8:	b11e      	cbz	r6, 1001df2 <mem_manage_fault.constprop.0+0x56>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
 1001dea:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1001dec:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 1001df0:	62a3      	str	r3, [r4, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
 1001df2:	4c12      	ldr	r4, [pc, #72]	; (1001e3c <mem_manage_fault.constprop.0+0xa0>)
 1001df4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1001df6:	07d8      	lsls	r0, r3, #31
 1001df8:	d503      	bpl.n	1001e02 <mem_manage_fault.constprop.0+0x66>
		PR_FAULT_INFO("  Instruction Access Violation");
 1001dfa:	2145      	movs	r1, #69	; 0x45
 1001dfc:	4815      	ldr	r0, [pc, #84]	; (1001e54 <mem_manage_fault.constprop.0+0xb8>)
 1001dfe:	f001 ff08 	bl	1003c12 <z_log_minimal_printk>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
 1001e02:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1001e04:	06d9      	lsls	r1, r3, #27
 1001e06:	d402      	bmi.n	1001e0e <mem_manage_fault.constprop.0+0x72>
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
 1001e08:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
 1001e0a:	079a      	lsls	r2, r3, #30
 1001e0c:	d50e      	bpl.n	1001e2c <mem_manage_fault.constprop.0+0x90>
	__ASSERT(!(SCB->CFSR & SCB_CFSR_MSTKERR_Msk),
 1001e0e:	4b0b      	ldr	r3, [pc, #44]	; (1001e3c <mem_manage_fault.constprop.0+0xa0>)
 1001e10:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 1001e12:	06db      	lsls	r3, r3, #27
 1001e14:	d50a      	bpl.n	1001e2c <mem_manage_fault.constprop.0+0x90>
 1001e16:	4910      	ldr	r1, [pc, #64]	; (1001e58 <mem_manage_fault.constprop.0+0xbc>)
 1001e18:	4810      	ldr	r0, [pc, #64]	; (1001e5c <mem_manage_fault.constprop.0+0xc0>)
 1001e1a:	f240 1259 	movw	r2, #345	; 0x159
 1001e1e:	f001 feea 	bl	1003bf6 <assert_print>
 1001e22:	f240 1159 	movw	r1, #345	; 0x159
 1001e26:	480c      	ldr	r0, [pc, #48]	; (1001e58 <mem_manage_fault.constprop.0+0xbc>)
 1001e28:	f001 fede 	bl	1003be8 <assert_post_action>
	*recoverable = memory_fault_recoverable(esf, true);
 1001e2c:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
 1001e2e:	4a03      	ldr	r2, [pc, #12]	; (1001e3c <mem_manage_fault.constprop.0+0xa0>)
 1001e30:	6a93      	ldr	r3, [r2, #40]	; 0x28
 1001e32:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
 1001e36:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
 1001e38:	7028      	strb	r0, [r5, #0]
}
 1001e3a:	bd70      	pop	{r4, r5, r6, pc}
 1001e3c:	e000ed00 	.word	0xe000ed00
 1001e40:	01004950 	.word	0x01004950
 1001e44:	0100496b 	.word	0x0100496b
 1001e48:	010048c3 	.word	0x010048c3
 1001e4c:	010049a3 	.word	0x010049a3
 1001e50:	010049c0 	.word	0x010049c0
 1001e54:	010049db 	.word	0x010049db
 1001e58:	010049ff 	.word	0x010049ff
 1001e5c:	010044ec 	.word	0x010044ec

01001e60 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
 1001e60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
 1001e64:	4b67      	ldr	r3, [pc, #412]	; (1002004 <z_arm_fault+0x1a4>)
 1001e66:	2600      	movs	r6, #0
 1001e68:	f8d3 8004 	ldr.w	r8, [r3, #4]
{
 1001e6c:	b08a      	sub	sp, #40	; 0x28
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
 1001e6e:	f3c8 0708 	ubfx	r7, r8, #0, #9
 1001e72:	f386 8811 	msr	BASEPRI, r6
 1001e76:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
 1001e7a:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
 1001e7e:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
 1001e82:	d107      	bne.n	1001e94 <z_arm_fault+0x34>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
 1001e84:	f002 030c 	and.w	r3, r2, #12
 1001e88:	2b08      	cmp	r3, #8
 1001e8a:	d110      	bne.n	1001eae <z_arm_fault+0x4e>
		PR_EXC("SPSEL in thread mode does not indicate PSP");
 1001e8c:	2145      	movs	r1, #69	; 0x45
 1001e8e:	485e      	ldr	r0, [pc, #376]	; (1002008 <z_arm_fault+0x1a8>)
 1001e90:	f001 febf 	bl	1003c12 <z_log_minimal_printk>

	/* Retrieve the Exception Stack Frame (ESF) to be supplied
	 * as argument to the remainder of the fault handling process.
	 */
	 esf = get_esf(msp, psp, exc_return, &nested_exc);
	__ASSERT(esf != NULL,
 1001e94:	f240 4205 	movw	r2, #1029	; 0x405
 1001e98:	495c      	ldr	r1, [pc, #368]	; (100200c <z_arm_fault+0x1ac>)
 1001e9a:	485d      	ldr	r0, [pc, #372]	; (1002010 <z_arm_fault+0x1b0>)
 1001e9c:	f001 feab 	bl	1003bf6 <assert_print>
 1001ea0:	f240 4105 	movw	r1, #1029	; 0x405
 1001ea4:	4859      	ldr	r0, [pc, #356]	; (100200c <z_arm_fault+0x1ac>)
 1001ea6:	f001 fe9f 	bl	1003be8 <assert_post_action>
 1001eaa:	2500      	movs	r5, #0
 1001eac:	e006      	b.n	1001ebc <z_arm_fault+0x5c>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
 1001eae:	0713      	lsls	r3, r2, #28
			ptr_esf =  (z_arch_esf_t *)psp;
 1001eb0:	bf4e      	itee	mi
 1001eb2:	460d      	movmi	r5, r1
			ptr_esf = (z_arch_esf_t *)msp;
 1001eb4:	4605      	movpl	r5, r0
			*nested_exc = true;
 1001eb6:	2601      	movpl	r6, #1
	__ASSERT(esf != NULL,
 1001eb8:	2d00      	cmp	r5, #0
 1001eba:	d0eb      	beq.n	1001e94 <z_arm_fault+0x34>
	*recoverable = false;
 1001ebc:	2400      	movs	r4, #0
	switch (fault) {
 1001ebe:	1efb      	subs	r3, r7, #3
	*recoverable = false;
 1001ec0:	f88d 4007 	strb.w	r4, [sp, #7]
	switch (fault) {
 1001ec4:	2b09      	cmp	r3, #9
 1001ec6:	f200 808a 	bhi.w	1001fde <z_arm_fault+0x17e>
 1001eca:	e8df f003 	tbb	[pc, r3]
 1001ece:	7d05      	.short	0x7d05
 1001ed0:	88886581 	.word	0x88886581
 1001ed4:	85888888 	.word	0x85888888
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
 1001ed8:	4f4a      	ldr	r7, [pc, #296]	; (1002004 <z_arm_fault+0x1a4>)
	PR_FAULT_INFO("***** HARD FAULT *****");
 1001eda:	2145      	movs	r1, #69	; 0x45
 1001edc:	484d      	ldr	r0, [pc, #308]	; (1002014 <z_arm_fault+0x1b4>)
 1001ede:	f001 fe98 	bl	1003c12 <z_log_minimal_printk>
	*recoverable = false;
 1001ee2:	f88d 4007 	strb.w	r4, [sp, #7]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
 1001ee6:	6afc      	ldr	r4, [r7, #44]	; 0x2c
 1001ee8:	f014 0402 	ands.w	r4, r4, #2
 1001eec:	d005      	beq.n	1001efa <z_arm_fault+0x9a>
		PR_EXC("  Bus fault on vector table read");
 1001eee:	2145      	movs	r1, #69	; 0x45
 1001ef0:	4849      	ldr	r0, [pc, #292]	; (1002018 <z_arm_fault+0x1b8>)
	PR_FAULT_INFO(
 1001ef2:	f001 fe8e 	bl	1003c12 <z_log_minimal_printk>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
 1001ef6:	2400      	movs	r4, #0
}
 1001ef8:	e006      	b.n	1001f08 <z_arm_fault+0xa8>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
 1001efa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 1001efc:	2b00      	cmp	r3, #0
 1001efe:	da1d      	bge.n	1001f3c <z_arm_fault+0xdc>
		PR_EXC("  Debug event");
 1001f00:	2145      	movs	r1, #69	; 0x45
 1001f02:	4846      	ldr	r0, [pc, #280]	; (100201c <z_arm_fault+0x1bc>)
 1001f04:	f001 fe85 	bl	1003c12 <z_log_minimal_printk>
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
 1001f08:	f89d 3007 	ldrb.w	r3, [sp, #7]
 1001f0c:	b99b      	cbnz	r3, 1001f36 <z_arm_fault+0xd6>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
 1001f0e:	2220      	movs	r2, #32
 1001f10:	4629      	mov	r1, r5
 1001f12:	a802      	add	r0, sp, #8
 1001f14:	f001 ff04 	bl	1003d20 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
 1001f18:	9b09      	ldr	r3, [sp, #36]	; 0x24
 1001f1a:	2e00      	cmp	r6, #0
 1001f1c:	d06c      	beq.n	1001ff8 <z_arm_fault+0x198>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
 1001f1e:	f3c3 0208 	ubfx	r2, r3, #0, #9
 1001f22:	b922      	cbnz	r2, 1001f2e <z_arm_fault+0xce>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
 1001f24:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 1001f28:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
 1001f2c:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
 1001f2e:	4620      	mov	r0, r4
 1001f30:	a902      	add	r1, sp, #8
 1001f32:	f7ff fdbb 	bl	1001aac <z_arm_fatal_error>
}
 1001f36:	b00a      	add	sp, #40	; 0x28
 1001f38:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
 1001f3c:	6afc      	ldr	r4, [r7, #44]	; 0x2c
 1001f3e:	f014 4480 	ands.w	r4, r4, #1073741824	; 0x40000000
 1001f42:	d038      	beq.n	1001fb6 <z_arm_fault+0x156>
		PR_EXC("  Fault escalation (see below)");
 1001f44:	2145      	movs	r1, #69	; 0x45
 1001f46:	4836      	ldr	r0, [pc, #216]	; (1002020 <z_arm_fault+0x1c0>)
 1001f48:	f001 fe63 	bl	1003c12 <z_log_minimal_printk>
	uint16_t fault_insn = *(ret_addr - 1);
 1001f4c:	69ab      	ldr	r3, [r5, #24]
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
 1001f4e:	f833 2c02 	ldrh.w	r2, [r3, #-2]
 1001f52:	f64d 7302 	movw	r3, #57090	; 0xdf02
 1001f56:	429a      	cmp	r2, r3
 1001f58:	d106      	bne.n	1001f68 <z_arm_fault+0x108>
			PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
 1001f5a:	2145      	movs	r1, #69	; 0x45
 1001f5c:	682a      	ldr	r2, [r5, #0]
 1001f5e:	4831      	ldr	r0, [pc, #196]	; (1002024 <z_arm_fault+0x1c4>)
 1001f60:	f001 fe57 	bl	1003c12 <z_log_minimal_printk>
			reason = esf->basic.r0;
 1001f64:	682c      	ldr	r4, [r5, #0]
 1001f66:	e7cf      	b.n	1001f08 <z_arm_fault+0xa8>
		} else if ((SCB->CFSR & SCB_CFSR_MEMFAULTSR_Msk) != 0) {
 1001f68:	6abb      	ldr	r3, [r7, #40]	; 0x28
 1001f6a:	b2db      	uxtb	r3, r3
 1001f6c:	b133      	cbz	r3, 1001f7c <z_arm_fault+0x11c>
			reason = mem_manage_fault(esf, 1, recoverable);
 1001f6e:	2001      	movs	r0, #1
 1001f70:	f10d 0107 	add.w	r1, sp, #7
		reason = mem_manage_fault(esf, 0, recoverable);
 1001f74:	f7ff ff12 	bl	1001d9c <mem_manage_fault.constprop.0>
		reason = bus_fault(esf, 0, recoverable);
 1001f78:	4604      	mov	r4, r0
		break;
 1001f7a:	e7c5      	b.n	1001f08 <z_arm_fault+0xa8>
		} else if ((SCB->CFSR & SCB_CFSR_BUSFAULTSR_Msk) != 0) {
 1001f7c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 1001f7e:	f413 4f7f 	tst.w	r3, #65280	; 0xff00
 1001f82:	d005      	beq.n	1001f90 <z_arm_fault+0x130>
			reason = bus_fault(esf, 1, recoverable);
 1001f84:	2001      	movs	r0, #1
 1001f86:	f10d 0107 	add.w	r1, sp, #7
		reason = bus_fault(esf, 0, recoverable);
 1001f8a:	f7ff feb5 	bl	1001cf8 <bus_fault.constprop.0>
 1001f8e:	e7f3      	b.n	1001f78 <z_arm_fault+0x118>
		} else if ((SCB->CFSR & SCB_CFSR_USGFAULTSR_Msk) != 0) {
 1001f90:	6abc      	ldr	r4, [r7, #40]	; 0x28
 1001f92:	0c24      	lsrs	r4, r4, #16
 1001f94:	0424      	lsls	r4, r4, #16
 1001f96:	b114      	cbz	r4, 1001f9e <z_arm_fault+0x13e>
		reason = usage_fault(esf);
 1001f98:	f7ff fe58 	bl	1001c4c <usage_fault.constprop.0>
 1001f9c:	e7ec      	b.n	1001f78 <z_arm_fault+0x118>
			__ASSERT(0,
 1001f9e:	491b      	ldr	r1, [pc, #108]	; (100200c <z_arm_fault+0x1ac>)
 1001fa0:	f240 22d7 	movw	r2, #727	; 0x2d7
 1001fa4:	481a      	ldr	r0, [pc, #104]	; (1002010 <z_arm_fault+0x1b0>)
 1001fa6:	f001 fe26 	bl	1003bf6 <assert_print>
 1001faa:	f240 21d7 	movw	r1, #727	; 0x2d7
		__ASSERT(0,
 1001fae:	4817      	ldr	r0, [pc, #92]	; (100200c <z_arm_fault+0x1ac>)
 1001fb0:	f001 fe1a 	bl	1003be8 <assert_post_action>
 1001fb4:	e7a8      	b.n	1001f08 <z_arm_fault+0xa8>
 1001fb6:	4915      	ldr	r1, [pc, #84]	; (100200c <z_arm_fault+0x1ac>)
 1001fb8:	f240 22db 	movw	r2, #731	; 0x2db
 1001fbc:	4814      	ldr	r0, [pc, #80]	; (1002010 <z_arm_fault+0x1b0>)
 1001fbe:	f001 fe1a 	bl	1003bf6 <assert_print>
 1001fc2:	f240 21db 	movw	r1, #731	; 0x2db
 1001fc6:	e7f2      	b.n	1001fae <z_arm_fault+0x14e>
		reason = mem_manage_fault(esf, 0, recoverable);
 1001fc8:	2000      	movs	r0, #0
 1001fca:	f10d 0107 	add.w	r1, sp, #7
 1001fce:	e7d1      	b.n	1001f74 <z_arm_fault+0x114>
		reason = bus_fault(esf, 0, recoverable);
 1001fd0:	2000      	movs	r0, #0
 1001fd2:	f10d 0107 	add.w	r1, sp, #7
 1001fd6:	e7d8      	b.n	1001f8a <z_arm_fault+0x12a>
	PR_FAULT_INFO(
 1001fd8:	2145      	movs	r1, #69	; 0x45
 1001fda:	4813      	ldr	r0, [pc, #76]	; (1002028 <z_arm_fault+0x1c8>)
 1001fdc:	e789      	b.n	1001ef2 <z_arm_fault+0x92>
	PR_FAULT_INFO("***** %s %d) *****",
 1001fde:	4913      	ldr	r1, [pc, #76]	; (100202c <z_arm_fault+0x1cc>)
 1001fe0:	f418 7ff8 	tst.w	r8, #496	; 0x1f0
 1001fe4:	4a12      	ldr	r2, [pc, #72]	; (1002030 <z_arm_fault+0x1d0>)
 1001fe6:	4813      	ldr	r0, [pc, #76]	; (1002034 <z_arm_fault+0x1d4>)
 1001fe8:	bf08      	it	eq
 1001fea:	460a      	moveq	r2, r1
 1001fec:	f1a7 0310 	sub.w	r3, r7, #16
 1001ff0:	2145      	movs	r1, #69	; 0x45
 1001ff2:	f001 fe0e 	bl	1003c12 <z_log_minimal_printk>
 1001ff6:	e77e      	b.n	1001ef6 <z_arm_fault+0x96>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
 1001ff8:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
 1001ffc:	f023 0301 	bic.w	r3, r3, #1
 1002000:	e794      	b.n	1001f2c <z_arm_fault+0xcc>
 1002002:	bf00      	nop
 1002004:	e000ed00 	.word	0xe000ed00
 1002008:	01004a67 	.word	0x01004a67
 100200c:	010049ff 	.word	0x010049ff
 1002010:	010044ec 	.word	0x010044ec
 1002014:	01004a97 	.word	0x01004a97
 1002018:	01004ab3 	.word	0x01004ab3
 100201c:	01004ad9 	.word	0x01004ad9
 1002020:	01004aec 	.word	0x01004aec
 1002024:	01004b10 	.word	0x01004b10
 1002028:	01004b31 	.word	0x01004b31
 100202c:	01004a39 	.word	0x01004a39
 1002030:	01004a4e 	.word	0x01004a4e
 1002034:	01004b5a 	.word	0x01004b5a

01002038 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
 1002038:	4b04      	ldr	r3, [pc, #16]	; (100204c <z_arm_fault_init+0x14>)
 100203a:	695a      	ldr	r2, [r3, #20]
 100203c:	f042 0210 	orr.w	r2, r2, #16
 1002040:	615a      	str	r2, [r3, #20]
	 *
	 * For Non-Secure Firmware this could allow the Non-Secure Main
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
 1002042:	695a      	ldr	r2, [r3, #20]
 1002044:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 1002048:	615a      	str	r2, [r3, #20]
#endif /* CONFIG_BUILTIN_STACK_GUARD */
#ifdef CONFIG_TRAP_UNALIGNED_ACCESS
	SCB->CCR |= SCB_CCR_UNALIGN_TRP_Msk;
#endif /* CONFIG_TRAP_UNALIGNED_ACCESS */
}
 100204a:	4770      	bx	lr
 100204c:	e000ed00 	.word	0xe000ed00

01002050 <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
 1002050:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
 1002054:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
 1002058:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
 100205a:	4672      	mov	r2, lr
	bl z_arm_fault
 100205c:	f7ff ff00 	bl	1001e60 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
 1002060:	bd01      	pop	{r0, pc}
 1002062:	bf00      	nop

01002064 <z_arm_interrupt_init>:
 *
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
 1002064:	2300      	movs	r3, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1002066:	2120      	movs	r1, #32
 1002068:	4803      	ldr	r0, [pc, #12]	; (1002078 <z_arm_interrupt_init+0x14>)
 100206a:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
 100206c:	3301      	adds	r3, #1
 100206e:	2b1e      	cmp	r3, #30
 1002070:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
 1002074:	d1f9      	bne.n	100206a <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
 1002076:	4770      	bx	lr
 1002078:	e000e100 	.word	0xe000e100

0100207c <__start>:
    strb r0, [r1]
#endif /* CONFIG_DEBUG_THREAD_INFO */

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
    /* Reset CONTROL register */
    movs.n r0, #0
 100207c:	2000      	movs	r0, #0
    msr CONTROL, r0
 100207e:	f380 8814 	msr	CONTROL, r0
    isb
 1002082:	f3bf 8f6f 	isb	sy
#if defined(CONFIG_CPU_CORTEX_M_HAS_SPLIM)
    /* Clear SPLIM registers */
    movs.n r0, #0
 1002086:	2000      	movs	r0, #0
    msr MSPLIM, r0
 1002088:	f380 880a 	msr	MSPLIM, r0
    msr PSPLIM, r0
 100208c:	f380 880b 	msr	PSPLIM, r0
#if defined(CONFIG_PM_S2RAM)
    bl arch_pm_s2ram_resume
#endif /* CONFIG_PM_S2RAM */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_arm_platform_init
 1002090:	f7ff fbf8 	bl	1001884 <z_arm_platform_init>
#endif

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
#if defined(CONFIG_CPU_HAS_ARM_MPU)
    /* Disable MPU */
    movs.n r0, #0
 1002094:	2000      	movs	r0, #0
    ldr r1, =_SCS_MPU_CTRL
 1002096:	490e      	ldr	r1, [pc, #56]	; (10020d0 <__start+0x54>)
    str r0, [r1]
 1002098:	6008      	str	r0, [r1, #0]
    dsb
 100209a:	f3bf 8f4f 	dsb	sy
#endif /* CONFIG_CPU_HAS_ARM_MPU */
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
 100209e:	480d      	ldr	r0, [pc, #52]	; (10020d4 <__start+0x58>)
    msr msp, r0
 10020a0:	f380 8808 	msr	MSP, r0

    /* Initialize core architecture registers and system blocks */
    bl z_arm_init_arch_hw_at_boot
 10020a4:	f000 f83e 	bl	1002124 <z_arm_init_arch_hw_at_boot>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
 10020a8:	2020      	movs	r0, #32
    msr BASEPRI, r0
 10020aa:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
 10020ae:	480a      	ldr	r0, [pc, #40]	; (10020d8 <__start+0x5c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
 10020b0:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
 10020b4:	1840      	adds	r0, r0, r1
    msr PSP, r0
 10020b6:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
 10020ba:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
 10020be:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
 10020c0:	4308      	orrs	r0, r1
    msr CONTROL, r0
 10020c2:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
 10020c6:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
 10020ca:	f7ff fd65 	bl	1001b98 <z_arm_prep_c>
 10020ce:	0000      	.short	0x0000
    ldr r1, =_SCS_MPU_CTRL
 10020d0:	e000ed94 	.word	0xe000ed94
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
 10020d4:	21000548 	.word	0x21000548
    ldr r0, =z_interrupt_stacks
 10020d8:	21000548 	.word	0x21000548

010020dc <sys_arch_reboot>:
  __ASM volatile ("dsb 0xF":::"memory");
 10020dc:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 10020e0:	4905      	ldr	r1, [pc, #20]	; (10020f8 <sys_arch_reboot+0x1c>)
 10020e2:	4b06      	ldr	r3, [pc, #24]	; (10020fc <sys_arch_reboot+0x20>)
 10020e4:	68ca      	ldr	r2, [r1, #12]
 10020e6:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 10020ea:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 10020ec:	60cb      	str	r3, [r1, #12]
 10020ee:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 10020f2:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 10020f4:	e7fd      	b.n	10020f2 <sys_arch_reboot+0x16>
 10020f6:	bf00      	nop
 10020f8:	e000ed00 	.word	0xe000ed00
 10020fc:	05fa0004 	.word	0x05fa0004

01002100 <z_arm_clear_arm_mpu_config>:
	int i;

	int num_regions =
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);

	for (i = 0; i < num_regions; i++) {
 1002100:	2300      	movs	r3, #0
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegionEx(MPU_Type* mpu, uint32_t rnr)
{
  mpu->RNR = rnr;
  mpu->RLAR = 0U;
 1002102:	4618      	mov	r0, r3
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);
 1002104:	4906      	ldr	r1, [pc, #24]	; (1002120 <z_arm_clear_arm_mpu_config+0x20>)
 1002106:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
	int num_regions =
 100210a:	f3c2 2207 	ubfx	r2, r2, #8, #8
	for (i = 0; i < num_regions; i++) {
 100210e:	4293      	cmp	r3, r2
 1002110:	d100      	bne.n	1002114 <z_arm_clear_arm_mpu_config+0x14>
		ARM_MPU_ClrRegion(i);
	}
}
 1002112:	4770      	bx	lr
  mpu->RNR = rnr;
 1002114:	f8c1 3098 	str.w	r3, [r1, #152]	; 0x98
  mpu->RLAR = 0U;
 1002118:	f8c1 00a0 	str.w	r0, [r1, #160]	; 0xa0
	for (i = 0; i < num_regions; i++) {
 100211c:	3301      	adds	r3, #1
 100211e:	e7f6      	b.n	100210e <z_arm_clear_arm_mpu_config+0xe>
 1002120:	e000ed00 	.word	0xe000ed00

01002124 <z_arm_init_arch_hw_at_boot>:
 * This routine resets Cortex-M system control block
 * components and core registers.
 *
 */
void z_arm_init_arch_hw_at_boot(void)
{
 1002124:	b510      	push	{r4, lr}
  __ASM volatile ("cpsid i" : : : "memory");
 1002126:	b672      	cpsid	i
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 1002128:	2400      	movs	r4, #0
 100212a:	f384 8813 	msr	FAULTMASK, r4

	/* Initialize System Control Block components */

#if defined(CONFIG_CPU_HAS_ARM_MPU) || defined(CONFIG_CPU_HAS_NXP_MPU)
	/* Clear MPU region configuration */
	z_arm_clear_arm_mpu_config();
 100212e:	f7ff ffe7 	bl	1002100 <z_arm_clear_arm_mpu_config>
 1002132:	4623      	mov	r3, r4
#endif /* CONFIG_CPU_HAS_ARM_MPU */

	/* Disable NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
		NVIC->ICER[i] = 0xFFFFFFFF;
 1002134:	f04f 30ff 	mov.w	r0, #4294967295
 1002138:	4a0b      	ldr	r2, [pc, #44]	; (1002168 <z_arm_init_arch_hw_at_boot+0x44>)
 100213a:	f103 0120 	add.w	r1, r3, #32
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
 100213e:	3301      	adds	r3, #1
 1002140:	2b10      	cmp	r3, #16
		NVIC->ICER[i] = 0xFFFFFFFF;
 1002142:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
 1002146:	d1f8      	bne.n	100213a <z_arm_init_arch_hw_at_boot+0x16>
 1002148:	2300      	movs	r3, #0
	}
	/* Clear pending NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
		NVIC->ICPR[i] = 0xFFFFFFFF;
 100214a:	f04f 30ff 	mov.w	r0, #4294967295
 100214e:	f103 0160 	add.w	r1, r3, #96	; 0x60
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
 1002152:	3301      	adds	r3, #1
 1002154:	2b10      	cmp	r3, #16
		NVIC->ICPR[i] = 0xFFFFFFFF;
 1002156:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
 100215a:	d1f8      	bne.n	100214e <z_arm_init_arch_hw_at_boot+0x2a>
  __ASM volatile ("cpsie i" : : : "memory");
 100215c:	b662      	cpsie	i
  __ASM volatile ("dsb 0xF":::"memory");
 100215e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 1002162:	f3bf 8f6f 	isb	sy
	/* Restore Interrupts */
	__enable_irq();

	__DSB();
	__ISB();
}
 1002166:	bd10      	pop	{r4, pc}
 1002168:	e000e100 	.word	0xe000e100

0100216c <onoff_start>:
static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
	int err;

	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
 100216c:	2340      	movs	r3, #64	; 0x40
{
 100216e:	b573      	push	{r0, r1, r4, r5, r6, lr}
	size_t offset = (size_t)(mgr - data->mgr);
 1002170:	4c0b      	ldr	r4, [pc, #44]	; (10021a0 <onoff_start+0x34>)
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
 1002172:	9300      	str	r3, [sp, #0]
	size_t offset = (size_t)(mgr - data->mgr);
 1002174:	1b04      	subs	r4, r0, r4
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
 1002176:	460b      	mov	r3, r1
{
 1002178:	460d      	mov	r5, r1
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
 100217a:	490a      	ldr	r1, [pc, #40]	; (10021a4 <onoff_start+0x38>)
	size_t offset = (size_t)(mgr - data->mgr);
 100217c:	10a4      	asrs	r4, r4, #2
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
 100217e:	4361      	muls	r1, r4
{
 1002180:	4606      	mov	r6, r0
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
 1002182:	4a09      	ldr	r2, [pc, #36]	; (10021a8 <onoff_start+0x3c>)
 1002184:	4809      	ldr	r0, [pc, #36]	; (10021ac <onoff_start+0x40>)
 1002186:	f001 fdf2 	bl	1003d6e <async_start>
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
 100218a:	1e01      	subs	r1, r0, #0
 100218c:	da05      	bge.n	100219a <onoff_start+0x2e>
		notify(mgr, err);
 100218e:	4630      	mov	r0, r6
 1002190:	462b      	mov	r3, r5
	}
}
 1002192:	b002      	add	sp, #8
 1002194:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		notify(mgr, err);
 1002198:	4718      	bx	r3
}
 100219a:	b002      	add	sp, #8
 100219c:	bd70      	pop	{r4, r5, r6, pc}
 100219e:	bf00      	nop
 10021a0:	210000c8 	.word	0x210000c8
 10021a4:	b6db6db7 	.word	0xb6db6db7
 10021a8:	01003de3 	.word	0x01003de3
 10021ac:	010040ac 	.word	0x010040ac

010021b0 <get_status>:
{
 10021b0:	b538      	push	{r3, r4, r5, lr}
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
 10021b2:	b2cc      	uxtb	r4, r1
 10021b4:	2c01      	cmp	r4, #1
{
 10021b6:	4605      	mov	r5, r0
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
 10021b8:	d908      	bls.n	10021cc <get_status+0x1c>
 10021ba:	4908      	ldr	r1, [pc, #32]	; (10021dc <get_status+0x2c>)
 10021bc:	4808      	ldr	r0, [pc, #32]	; (10021e0 <get_status+0x30>)
 10021be:	2279      	movs	r2, #121	; 0x79
 10021c0:	f001 fd19 	bl	1003bf6 <assert_print>
 10021c4:	2179      	movs	r1, #121	; 0x79
 10021c6:	4805      	ldr	r0, [pc, #20]	; (10021dc <get_status+0x2c>)
 10021c8:	f001 fd0e 	bl	1003be8 <assert_post_action>
	return GET_STATUS(get_sub_data(dev, type)->flags);
 10021cc:	230c      	movs	r3, #12
 10021ce:	6929      	ldr	r1, [r5, #16]
 10021d0:	fb04 1403 	mla	r4, r4, r3, r1
 10021d4:	6c20      	ldr	r0, [r4, #64]	; 0x40
}
 10021d6:	f000 0007 	and.w	r0, r0, #7
 10021da:	bd38      	pop	{r3, r4, r5, pc}
 10021dc:	01004b72 	.word	0x01004b72
 10021e0:	010044ec 	.word	0x010044ec

010021e4 <stop>:
{
 10021e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 10021e6:	b2cc      	uxtb	r4, r1
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
 10021e8:	2c01      	cmp	r4, #1
{
 10021ea:	4605      	mov	r5, r0
 10021ec:	4617      	mov	r7, r2
	struct nrf_clock_control_data *data = dev->data;
 10021ee:	6906      	ldr	r6, [r0, #16]
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
 10021f0:	d90a      	bls.n	1002208 <stop+0x24>
 10021f2:	4918      	ldr	r1, [pc, #96]	; (1002254 <stop+0x70>)
 10021f4:	4818      	ldr	r0, [pc, #96]	; (1002258 <stop+0x74>)
 10021f6:	f240 124d 	movw	r2, #333	; 0x14d
 10021fa:	f001 fcfc 	bl	1003bf6 <assert_print>
 10021fe:	f240 114d 	movw	r1, #333	; 0x14d
 1002202:	4814      	ldr	r0, [pc, #80]	; (1002254 <stop+0x70>)
 1002204:	f001 fcf0 	bl	1003be8 <assert_post_action>
	__asm__ volatile(
 1002208:	f04f 0320 	mov.w	r3, #32
 100220c:	f3ef 8111 	mrs	r1, BASEPRI
 1002210:	f383 8812 	msr	BASEPRI_MAX, r3
 1002214:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
 1002218:	220c      	movs	r2, #12
 100221a:	fb02 6304 	mla	r3, r2, r4, r6
 100221e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
	if ((current_ctx != 0) && (current_ctx != ctx)) {
 1002220:	f013 03c0 	ands.w	r3, r3, #192	; 0xc0
 1002224:	d001      	beq.n	100222a <stop+0x46>
 1002226:	429f      	cmp	r7, r3
 1002228:	d111      	bne.n	100224e <stop+0x6a>
		*flags = CLOCK_CONTROL_STATUS_OFF;
 100222a:	2301      	movs	r3, #1
	int err = 0;
 100222c:	2000      	movs	r0, #0
		*flags = CLOCK_CONTROL_STATUS_OFF;
 100222e:	fb02 6604 	mla	r6, r2, r4, r6
 1002232:	6433      	str	r3, [r6, #64]	; 0x40
	__asm__ volatile(
 1002234:	f381 8811 	msr	BASEPRI, r1
 1002238:	f3bf 8f6f 	isb	sy
	if (err < 0) {
 100223c:	b930      	cbnz	r0, 100224c <stop+0x68>
	get_sub_config(dev, type)->stop();
 100223e:	230c      	movs	r3, #12
 1002240:	6869      	ldr	r1, [r5, #4]
 1002242:	fb03 1404 	mla	r4, r3, r4, r1
 1002246:	6863      	ldr	r3, [r4, #4]
 1002248:	4798      	blx	r3
	return 0;
 100224a:	2000      	movs	r0, #0
}
 100224c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		err = -EPERM;
 100224e:	f04f 30ff 	mov.w	r0, #4294967295
 1002252:	e7ef      	b.n	1002234 <stop+0x50>
 1002254:	01004b72 	.word	0x01004b72
 1002258:	010044ec 	.word	0x010044ec

0100225c <onoff_stop>:
	size_t offset = (size_t)(mgr - data->mgr);
 100225c:	4b08      	ldr	r3, [pc, #32]	; (1002280 <onoff_stop+0x24>)
{
 100225e:	b570      	push	{r4, r5, r6, lr}
	size_t offset = (size_t)(mgr - data->mgr);
 1002260:	1ac3      	subs	r3, r0, r3
{
 1002262:	460d      	mov	r5, r1
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
 1002264:	4907      	ldr	r1, [pc, #28]	; (1002284 <onoff_stop+0x28>)
	size_t offset = (size_t)(mgr - data->mgr);
 1002266:	109b      	asrs	r3, r3, #2
{
 1002268:	4604      	mov	r4, r0
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
 100226a:	4359      	muls	r1, r3
 100226c:	2240      	movs	r2, #64	; 0x40
 100226e:	4806      	ldr	r0, [pc, #24]	; (1002288 <onoff_stop+0x2c>)
 1002270:	f7ff ffb8 	bl	10021e4 <stop>
	notify(mgr, res);
 1002274:	462b      	mov	r3, r5
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
 1002276:	4601      	mov	r1, r0
	notify(mgr, res);
 1002278:	4620      	mov	r0, r4
}
 100227a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	notify(mgr, res);
 100227e:	4718      	bx	r3
 1002280:	210000c8 	.word	0x210000c8
 1002284:	b6db6db7 	.word	0xb6db6db7
 1002288:	010040ac 	.word	0x010040ac

0100228c <clk_init>:
#endif /* NRF_CLOCK_HAS_HFCLKAUDIO */
#endif
}

static int clk_init(const struct device *dev)
{
 100228c:	b570      	push	{r4, r5, r6, lr}
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
 100228e:	2200      	movs	r2, #0
 1002290:	2101      	movs	r1, #1
{
 1002292:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
 1002294:	2005      	movs	r0, #5
 1002296:	f7ff fc55 	bl	1001b44 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);

	nrfx_err = nrfx_clock_init(clock_event_handler);
 100229a:	480f      	ldr	r0, [pc, #60]	; (10022d8 <clk_init+0x4c>)
 100229c:	f001 f83c 	bl	1003318 <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
 10022a0:	4b0e      	ldr	r3, [pc, #56]	; (10022dc <clk_init+0x50>)
 10022a2:	4298      	cmp	r0, r3
 10022a4:	d115      	bne.n	10022d2 <clk_init+0x46>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
 10022a6:	f001 f859 	bl	100335c <nrfx_clock_enable>
	struct nrf_clock_control_data *data = dev->data;
 10022aa:	6926      	ldr	r6, [r4, #16]
	for (enum clock_control_nrf_type i = 0;
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		struct nrf_clock_control_sub_data *subdata =
						get_sub_data(dev, i);

		err = onoff_manager_init(get_onoff_manager(dev, i),
 10022ac:	490c      	ldr	r1, [pc, #48]	; (10022e0 <clk_init+0x54>)
 10022ae:	4630      	mov	r0, r6
 10022b0:	f001 fc2b 	bl	1003b0a <onoff_manager_init>
					 &transitions);
		if (err < 0) {
 10022b4:	2800      	cmp	r0, #0
 10022b6:	db0b      	blt.n	10022d0 <clk_init+0x44>
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
 10022b8:	2501      	movs	r5, #1
	struct nrf_clock_control_data *data = dev->data;
 10022ba:	6924      	ldr	r4, [r4, #16]
		err = onoff_manager_init(get_onoff_manager(dev, i),
 10022bc:	4908      	ldr	r1, [pc, #32]	; (10022e0 <clk_init+0x54>)
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
 10022be:	6435      	str	r5, [r6, #64]	; 0x40
		err = onoff_manager_init(get_onoff_manager(dev, i),
 10022c0:	f104 001c 	add.w	r0, r4, #28
 10022c4:	f001 fc21 	bl	1003b0a <onoff_manager_init>
		if (err < 0) {
 10022c8:	2800      	cmp	r0, #0
 10022ca:	db01      	blt.n	10022d0 <clk_init+0x44>
	}

	return 0;
 10022cc:	2000      	movs	r0, #0
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
 10022ce:	64e5      	str	r5, [r4, #76]	; 0x4c
}
 10022d0:	bd70      	pop	{r4, r5, r6, pc}
		return -EIO;
 10022d2:	f06f 0004 	mvn.w	r0, #4
 10022d6:	e7fb      	b.n	10022d0 <clk_init+0x44>
 10022d8:	01002319 	.word	0x01002319
 10022dc:	0bad0000 	.word	0x0bad0000
 10022e0:	010042a0 	.word	0x010042a0

010022e4 <clkstarted_handle.constprop.0>:
static void clkstarted_handle(const struct device *dev,
 10022e4:	4601      	mov	r1, r0
	clock_control_cb_t callback = sub_data->cb;
 10022e6:	230c      	movs	r3, #12
	sub_data->cb = NULL;
 10022e8:	2200      	movs	r2, #0
	clock_control_cb_t callback = sub_data->cb;
 10022ea:	434b      	muls	r3, r1
 10022ec:	4808      	ldr	r0, [pc, #32]	; (1002310 <clkstarted_handle.constprop.0+0x2c>)
static void clkstarted_handle(const struct device *dev,
 10022ee:	b570      	push	{r4, r5, r6, lr}
	clock_control_cb_t callback = sub_data->cb;
 10022f0:	18c4      	adds	r4, r0, r3
	set_on_state(&sub_data->flags);
 10022f2:	3340      	adds	r3, #64	; 0x40
	void *user_data = sub_data->user_data;
 10022f4:	e9d4 560e 	ldrd	r5, r6, [r4, #56]	; 0x38
	set_on_state(&sub_data->flags);
 10022f8:	4418      	add	r0, r3
	sub_data->cb = NULL;
 10022fa:	63a2      	str	r2, [r4, #56]	; 0x38
	set_on_state(&sub_data->flags);
 10022fc:	f001 fd24 	bl	1003d48 <set_on_state>
	if (callback) {
 1002300:	b12d      	cbz	r5, 100230e <clkstarted_handle.constprop.0+0x2a>
		callback(dev, (clock_control_subsys_t)type, user_data);
 1002302:	4632      	mov	r2, r6
 1002304:	462b      	mov	r3, r5
}
 1002306:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		callback(dev, (clock_control_subsys_t)type, user_data);
 100230a:	4802      	ldr	r0, [pc, #8]	; (1002314 <clkstarted_handle.constprop.0+0x30>)
 100230c:	4718      	bx	r3
}
 100230e:	bd70      	pop	{r4, r5, r6, pc}
 1002310:	210000c8 	.word	0x210000c8
 1002314:	010040ac 	.word	0x010040ac

01002318 <clock_event_handler>:
	switch (event) {
 1002318:	2801      	cmp	r0, #1
{
 100231a:	b508      	push	{r3, lr}
	switch (event) {
 100231c:	d006      	beq.n	100232c <clock_event_handler+0x14>
 100231e:	2803      	cmp	r0, #3
 1002320:	d008      	beq.n	1002334 <clock_event_handler+0x1c>
 1002322:	b9a0      	cbnz	r0, 100234e <clock_event_handler+0x36>
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
 1002324:	4b0f      	ldr	r3, [pc, #60]	; (1002364 <clock_event_handler+0x4c>)
 1002326:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 1002328:	075b      	lsls	r3, r3, #29
 100232a:	d119      	bne.n	1002360 <clock_event_handler+0x48>
}
 100232c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
 1002330:	f7ff bfd8 	b.w	10022e4 <clkstarted_handle.constprop.0>
			__ASSERT_NO_MSG(false);
 1002334:	490c      	ldr	r1, [pc, #48]	; (1002368 <clock_event_handler+0x50>)
 1002336:	f240 225e 	movw	r2, #606	; 0x25e
 100233a:	480c      	ldr	r0, [pc, #48]	; (100236c <clock_event_handler+0x54>)
 100233c:	f001 fc5b 	bl	1003bf6 <assert_print>
 1002340:	f240 215e 	movw	r1, #606	; 0x25e
}
 1002344:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		__ASSERT_NO_MSG(0);
 1002348:	4807      	ldr	r0, [pc, #28]	; (1002368 <clock_event_handler+0x50>)
 100234a:	f001 bc4d 	b.w	1003be8 <assert_post_action>
 100234e:	4906      	ldr	r1, [pc, #24]	; (1002368 <clock_event_handler+0x50>)
 1002350:	f240 2262 	movw	r2, #610	; 0x262
 1002354:	4805      	ldr	r0, [pc, #20]	; (100236c <clock_event_handler+0x54>)
 1002356:	f001 fc4e 	bl	1003bf6 <assert_print>
 100235a:	f240 2162 	movw	r1, #610	; 0x262
 100235e:	e7f1      	b.n	1002344 <clock_event_handler+0x2c>
}
 1002360:	bd08      	pop	{r3, pc}
 1002362:	bf00      	nop
 1002364:	210000c8 	.word	0x210000c8
 1002368:	01004b72 	.word	0x01004b72
 100236c:	010044ec 	.word	0x010044ec

01002370 <generic_hfclk_start>:
{
 1002370:	b508      	push	{r3, lr}
	__asm__ volatile(
 1002372:	f04f 0320 	mov.w	r3, #32
 1002376:	f3ef 8111 	mrs	r1, BASEPRI
 100237a:	f383 8812 	msr	BASEPRI_MAX, r3
 100237e:	f3bf 8f6f 	isb	sy
	hfclk_users |= HF_USER_GENERIC;
 1002382:	4a11      	ldr	r2, [pc, #68]	; (10023c8 <generic_hfclk_start+0x58>)
 1002384:	6813      	ldr	r3, [r2, #0]
 1002386:	f043 0002 	orr.w	r0, r3, #2
	if (hfclk_users & HF_USER_BT) {
 100238a:	f013 0301 	ands.w	r3, r3, #1
	hfclk_users |= HF_USER_GENERIC;
 100238e:	6010      	str	r0, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
 1002390:	d00b      	beq.n	10023aa <generic_hfclk_start+0x3a>
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            if (p_clk_src != NULL)
            {
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
 1002392:	4a0e      	ldr	r2, [pc, #56]	; (10023cc <generic_hfclk_start+0x5c>)
 1002394:	f8d2 340c 	ldr.w	r3, [r2, #1036]	; 0x40c
                                        >> CLOCK_HFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
 1002398:	f8d2 240c 	ldr.w	r2, [r2, #1036]	; 0x40c
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
 100239c:	f013 0301 	ands.w	r3, r3, #1
 10023a0:	d003      	beq.n	10023aa <generic_hfclk_start+0x3a>
			set_on_state(get_hf_flags());
 10023a2:	480b      	ldr	r0, [pc, #44]	; (10023d0 <generic_hfclk_start+0x60>)
 10023a4:	f001 fcd0 	bl	1003d48 <set_on_state>
			already_started = true;
 10023a8:	2301      	movs	r3, #1
	__asm__ volatile(
 10023aa:	f381 8811 	msr	BASEPRI, r1
 10023ae:	f3bf 8f6f 	isb	sy
	if (already_started) {
 10023b2:	b123      	cbz	r3, 10023be <generic_hfclk_start+0x4e>
}
 10023b4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(CLOCK_DEVICE,
 10023b8:	2000      	movs	r0, #0
 10023ba:	f7ff bf93 	b.w	10022e4 <clkstarted_handle.constprop.0>
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
 10023be:	2001      	movs	r0, #1
}
 10023c0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 10023c4:	f000 bff0 	b.w	10033a8 <nrfx_clock_start>
 10023c8:	21000118 	.word	0x21000118
 10023cc:	41005000 	.word	0x41005000
 10023d0:	21000108 	.word	0x21000108

010023d4 <generic_hfclk_stop>:
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 10023d4:	4b07      	ldr	r3, [pc, #28]	; (10023f4 <generic_hfclk_stop+0x20>)
 10023d6:	e8d3 2fef 	ldaex	r2, [r3]
 10023da:	f022 0102 	bic.w	r1, r2, #2
 10023de:	e8c3 1fe0 	stlex	r0, r1, [r3]
 10023e2:	2800      	cmp	r0, #0
 10023e4:	d1f7      	bne.n	10023d6 <generic_hfclk_stop+0x2>
	if (atomic_and(&hfclk_users, ~HF_USER_GENERIC) & HF_USER_BT) {
 10023e6:	07d3      	lsls	r3, r2, #31
 10023e8:	d402      	bmi.n	10023f0 <generic_hfclk_stop+0x1c>
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
 10023ea:	2001      	movs	r0, #1
 10023ec:	f001 b83e 	b.w	100346c <nrfx_clock_stop>
}
 10023f0:	4770      	bx	lr
 10023f2:	bf00      	nop
 10023f4:	21000118 	.word	0x21000118

010023f8 <z_nrf_clock_control_lf_on>:
{
 10023f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
 10023fc:	2201      	movs	r2, #1
 10023fe:	4607      	mov	r7, r0
 1002400:	493f      	ldr	r1, [pc, #252]	; (1002500 <z_nrf_clock_control_lf_on+0x108>)
 1002402:	e8d1 3fef 	ldaex	r3, [r1]
 1002406:	e8c1 2fe0 	stlex	r0, r2, [r1]
 100240a:	2800      	cmp	r0, #0
 100240c:	d1f9      	bne.n	1002402 <z_nrf_clock_control_lf_on+0xa>
	if (atomic_set(&on, 1) == 0) {
 100240e:	b99b      	cbnz	r3, 1002438 <z_nrf_clock_control_lf_on+0x40>
 */
static inline void sys_notify_init_spinwait(struct sys_notify *notify)
{
	__ASSERT_NO_MSG(notify != NULL);

	*notify = (struct sys_notify){
 1002410:	493c      	ldr	r1, [pc, #240]	; (1002504 <z_nrf_clock_control_lf_on+0x10c>)
		err = onoff_request(mgr, &cli);
 1002412:	483d      	ldr	r0, [pc, #244]	; (1002508 <z_nrf_clock_control_lf_on+0x110>)
 1002414:	604b      	str	r3, [r1, #4]
 1002416:	60cb      	str	r3, [r1, #12]
 1002418:	608a      	str	r2, [r1, #8]
 100241a:	f7fe fdf1 	bl	1001000 <onoff_request>
		__ASSERT_NO_MSG(err >= 0);
 100241e:	2800      	cmp	r0, #0
 1002420:	da0a      	bge.n	1002438 <z_nrf_clock_control_lf_on+0x40>
 1002422:	493a      	ldr	r1, [pc, #232]	; (100250c <z_nrf_clock_control_lf_on+0x114>)
 1002424:	483a      	ldr	r0, [pc, #232]	; (1002510 <z_nrf_clock_control_lf_on+0x118>)
 1002426:	f44f 7208 	mov.w	r2, #544	; 0x220
 100242a:	f001 fbe4 	bl	1003bf6 <assert_print>
 100242e:	f44f 7108 	mov.w	r1, #544	; 0x220
 1002432:	4836      	ldr	r0, [pc, #216]	; (100250c <z_nrf_clock_control_lf_on+0x114>)
 1002434:	f001 fbd8 	bl	1003be8 <assert_post_action>
	switch (start_mode) {
 1002438:	b387      	cbz	r7, 100249c <z_nrf_clock_control_lf_on+0xa4>
 100243a:	1e7b      	subs	r3, r7, #1
 100243c:	2b01      	cmp	r3, #1
 100243e:	d84c      	bhi.n	10024da <z_nrf_clock_control_lf_on+0xe2>
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
 1002440:	2f01      	cmp	r7, #1
 1002442:	d106      	bne.n	1002452 <z_nrf_clock_control_lf_on+0x5a>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
 1002444:	4b33      	ldr	r3, [pc, #204]	; (1002514 <z_nrf_clock_control_lf_on+0x11c>)
 1002446:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
 100244a:	f003 0303 	and.w	r3, r3, #3
 100244e:	2b02      	cmp	r3, #2
 1002450:	d024      	beq.n	100249c <z_nrf_clock_control_lf_on+0xa4>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
 1002452:	f001 fe08 	bl	1004066 <k_is_in_isr>
 1002456:	4605      	mov	r5, r0
 1002458:	b918      	cbnz	r0, 1002462 <z_nrf_clock_control_lf_on+0x6a>
 */
static inline bool k_is_pre_kernel(void)
{
	extern bool z_sys_post_kernel; /* in init.c */

	return !z_sys_post_kernel;
 100245a:	4b2f      	ldr	r3, [pc, #188]	; (1002518 <z_nrf_clock_control_lf_on+0x120>)
	int key = isr_mode ? irq_lock() : 0;
 100245c:	781b      	ldrb	r3, [r3, #0]
 100245e:	2b00      	cmp	r3, #0
 1002460:	d148      	bne.n	10024f4 <z_nrf_clock_control_lf_on+0xfc>
	__asm__ volatile(
 1002462:	f04f 0320 	mov.w	r3, #32
 1002466:	f3ef 8611 	mrs	r6, BASEPRI
 100246a:	f383 8812 	msr	BASEPRI_MAX, r3
 100246e:	f3bf 8f6f 	isb	sy
 1002472:	2501      	movs	r5, #1
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
 1002474:	4c27      	ldr	r4, [pc, #156]	; (1002514 <z_nrf_clock_control_lf_on+0x11c>)
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 1002476:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 100251c <z_nrf_clock_control_lf_on+0x124>
 100247a:	f8d4 3418 	ldr.w	r3, [r4, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
 100247e:	f8d4 2418 	ldr.w	r2, [r4, #1048]	; 0x418
 1002482:	03d2      	lsls	r2, r2, #15
 1002484:	d50c      	bpl.n	10024a0 <z_nrf_clock_control_lf_on+0xa8>
	while (!(nrfx_clock_is_running(d, (void *)&type)
 1002486:	f003 0303 	and.w	r3, r3, #3
 100248a:	2b02      	cmp	r3, #2
 100248c:	d001      	beq.n	1002492 <z_nrf_clock_control_lf_on+0x9a>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
 100248e:	2f01      	cmp	r7, #1
 1002490:	d106      	bne.n	10024a0 <z_nrf_clock_control_lf_on+0xa8>
	if (isr_mode) {
 1002492:	b1f5      	cbz	r5, 10024d2 <z_nrf_clock_control_lf_on+0xda>
	__asm__ volatile(
 1002494:	f386 8811 	msr	BASEPRI, r6
 1002498:	f3bf 8f6f 	isb	sy
}
 100249c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 *
 * @param key Interrupt locking key obtained from irq_lock().
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
 10024a0:	4630      	mov	r0, r6
 10024a2:	f7ff faf9 	bl	1001a98 <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
 10024a6:	f8d4 3518 	ldr.w	r3, [r4, #1304]	; 0x518
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
 10024aa:	b2db      	uxtb	r3, r3
 10024ac:	2b01      	cmp	r3, #1
 10024ae:	d1e4      	bne.n	100247a <z_nrf_clock_control_lf_on+0x82>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
 10024b0:	f8d4 2104 	ldr.w	r2, [r4, #260]	; 0x104
		    && nrf_clock_event_check(NRF_CLOCK,
 10024b4:	2a00      	cmp	r2, #0
 10024b6:	d0e0      	beq.n	100247a <z_nrf_clock_control_lf_on+0x82>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 10024b8:	2200      	movs	r2, #0
 10024ba:	f8c4 2104 	str.w	r2, [r4, #260]	; 0x104
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
 10024be:	f8d4 2104 	ldr.w	r2, [r4, #260]	; 0x104
    p_reg->LFCLKSRC = (uint32_t)(source);
 10024c2:	2202      	movs	r2, #2
 10024c4:	f8c4 2518 	str.w	r2, [r4, #1304]	; 0x518
 10024c8:	2220      	movs	r2, #32
 10024ca:	f8c8 2180 	str.w	r2, [r8, #384]	; 0x180
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 10024ce:	60a3      	str	r3, [r4, #8]
}
 10024d0:	e7d3      	b.n	100247a <z_nrf_clock_control_lf_on+0x82>
    p_reg->INTENSET = mask;
 10024d2:	2302      	movs	r3, #2
 10024d4:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
}
 10024d8:	e7e0      	b.n	100249c <z_nrf_clock_control_lf_on+0xa4>
		__ASSERT_NO_MSG(false);
 10024da:	490c      	ldr	r1, [pc, #48]	; (100250c <z_nrf_clock_control_lf_on+0x114>)
 10024dc:	480c      	ldr	r0, [pc, #48]	; (1002510 <z_nrf_clock_control_lf_on+0x118>)
 10024de:	f240 2232 	movw	r2, #562	; 0x232
 10024e2:	f001 fb88 	bl	1003bf6 <assert_print>
}
 10024e6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		__ASSERT_NO_MSG(false);
 10024ea:	f240 2132 	movw	r1, #562	; 0x232
 10024ee:	4807      	ldr	r0, [pc, #28]	; (100250c <z_nrf_clock_control_lf_on+0x114>)
 10024f0:	f001 bb7a 	b.w	1003be8 <assert_post_action>
    p_reg->INTENCLR = mask;
 10024f4:	2202      	movs	r2, #2
 10024f6:	4b07      	ldr	r3, [pc, #28]	; (1002514 <z_nrf_clock_control_lf_on+0x11c>)
	int key = isr_mode ? irq_lock() : 0;
 10024f8:	4606      	mov	r6, r0
 10024fa:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
 10024fe:	e7b9      	b.n	1002474 <z_nrf_clock_control_lf_on+0x7c>
 1002500:	2100011c 	.word	0x2100011c
 1002504:	210000b8 	.word	0x210000b8
 1002508:	210000e4 	.word	0x210000e4
 100250c:	01004b72 	.word	0x01004b72
 1002510:	010044ec 	.word	0x010044ec
 1002514:	41005000 	.word	0x41005000
 1002518:	21000144 	.word	0x21000144
 100251c:	e000e100 	.word	0xe000e100

01002520 <flash_nrf_pages_layout>:

static void flash_nrf_pages_layout(const struct device *dev,
				     const struct flash_pages_layout **layout,
				     size_t *layout_size)
{
	*layout = &dev_layout;
 1002520:	4b02      	ldr	r3, [pc, #8]	; (100252c <flash_nrf_pages_layout+0xc>)
 1002522:	600b      	str	r3, [r1, #0]
	*layout_size = 1;
 1002524:	2301      	movs	r3, #1
 1002526:	6013      	str	r3, [r2, #0]
}
 1002528:	4770      	bx	lr
 100252a:	bf00      	nop
 100252c:	21000120 	.word	0x21000120

01002530 <flash_nrf_get_parameters>:
flash_nrf_get_parameters(const struct device *dev)
{
	ARG_UNUSED(dev);

	return &flash_nrf_parameters;
}
 1002530:	4800      	ldr	r0, [pc, #0]	; (1002534 <flash_nrf_get_parameters+0x4>)
 1002532:	4770      	bx	lr
 1002534:	010042c0 	.word	0x010042c0

01002538 <nrf_flash_init>:
	.page_layout = flash_nrf_pages_layout,
#endif
};

static int nrf_flash_init(const struct device *dev)
{
 1002538:	b510      	push	{r4, lr}
#ifndef CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE
	nrf_flash_sync_init();
#endif /* !CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE */

#if defined(CONFIG_FLASH_PAGE_LAYOUT)
	dev_layout.pages_count = nrfx_nvmc_flash_page_count_get();
 100253a:	f001 fd83 	bl	1004044 <nrfx_nvmc_flash_page_count_get>
 100253e:	4c03      	ldr	r4, [pc, #12]	; (100254c <nrf_flash_init+0x14>)
 1002540:	6020      	str	r0, [r4, #0]
	dev_layout.pages_size = nrfx_nvmc_flash_page_size_get();
 1002542:	f001 fd7c 	bl	100403e <nrfx_nvmc_flash_page_size_get>
 1002546:	6060      	str	r0, [r4, #4]
#endif

	return 0;
}
 1002548:	2000      	movs	r0, #0
 100254a:	bd10      	pop	{r4, pc}
 100254c:	21000120 	.word	0x21000120

01002550 <flash_nrf_erase>:
{
 1002550:	b570      	push	{r4, r5, r6, lr}
 1002552:	460c      	mov	r4, r1
 1002554:	4615      	mov	r5, r2
	uint32_t pg_size = nrfx_nvmc_flash_page_size_get();
 1002556:	f001 fd72 	bl	100403e <nrfx_nvmc_flash_page_size_get>
	if (is_regular_addr_valid(addr, size)) {
 100255a:	4629      	mov	r1, r5
	uint32_t pg_size = nrfx_nvmc_flash_page_size_get();
 100255c:	4606      	mov	r6, r0
	if (is_regular_addr_valid(addr, size)) {
 100255e:	4620      	mov	r0, r4
 1002560:	f001 fc51 	bl	1003e06 <is_regular_addr_valid>
 1002564:	b308      	cbz	r0, 10025aa <flash_nrf_erase+0x5a>
		if (((addr % pg_size) != 0) || ((size % pg_size) != 0)) {
 1002566:	fbb4 f3f6 	udiv	r3, r4, r6
 100256a:	fb06 4313 	mls	r3, r6, r3, r4
 100256e:	b923      	cbnz	r3, 100257a <flash_nrf_erase+0x2a>
 1002570:	fbb5 f0f6 	udiv	r0, r5, r6
 1002574:	fb06 5010 	mls	r0, r6, r0, r5
 1002578:	b140      	cbz	r0, 100258c <flash_nrf_erase+0x3c>
			LOG_ERR("unaligned address: 0x%08lx:%zu",
 100257a:	462b      	mov	r3, r5
 100257c:	4622      	mov	r2, r4
 100257e:	2145      	movs	r1, #69	; 0x45
 1002580:	480c      	ldr	r0, [pc, #48]	; (10025b4 <flash_nrf_erase+0x64>)
		LOG_ERR("invalid address: 0x%08lx:%zu",
 1002582:	f001 fb46 	bl	1003c12 <z_log_minimal_printk>
		return -EINVAL;
 1002586:	f06f 0015 	mvn.w	r0, #21
 100258a:	e00d      	b.n	10025a8 <flash_nrf_erase+0x58>
		if (!n_pages) {
 100258c:	42ae      	cmp	r6, r5
 100258e:	d80b      	bhi.n	10025a8 <flash_nrf_erase+0x58>

#endif /* !CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE */

static int erase_op(void *context)
{
	uint32_t pg_size = nrfx_nvmc_flash_page_size_get();
 1002590:	f001 fd55 	bl	100403e <nrfx_nvmc_flash_page_size_get>
 1002594:	4606      	mov	r6, r0
		addr += DT_REG_ADDR(SOC_NV_FLASH_NODE);
 1002596:	f104 7480 	add.w	r4, r4, #16777216	; 0x1000000
		if (nrfx_nvmc_page_partial_erase_continue()) {
			e_ctx->len -= pg_size;
			e_ctx->flash_addr += pg_size;
		}
#else
		(void)nrfx_nvmc_page_erase(e_ctx->flash_addr);
 100259a:	4620      	mov	r0, r4
 100259c:	f000 ffc2 	bl	1003524 <nrfx_nvmc_page_erase>
			}

		}
#endif /* !CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE */

	} while (e_ctx->len > 0);
 10025a0:	1bad      	subs	r5, r5, r6
 10025a2:	4434      	add	r4, r6
 10025a4:	d1f9      	bne.n	100259a <flash_nrf_erase+0x4a>
	return ret;
 10025a6:	4628      	mov	r0, r5
}
 10025a8:	bd70      	pop	{r4, r5, r6, pc}
		LOG_ERR("invalid address: 0x%08lx:%zu",
 10025aa:	462b      	mov	r3, r5
 10025ac:	4622      	mov	r2, r4
 10025ae:	2145      	movs	r1, #69	; 0x45
 10025b0:	4801      	ldr	r0, [pc, #4]	; (10025b8 <flash_nrf_erase+0x68>)
 10025b2:	e7e6      	b.n	1002582 <flash_nrf_erase+0x32>
 10025b4:	01004bd8 	.word	0x01004bd8
 10025b8:	01004bfc 	.word	0x01004bfc

010025bc <flash_nrf_write>:
{
 10025bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 10025be:	460d      	mov	r5, r1
	if (is_regular_addr_valid(addr, len)) {
 10025c0:	4619      	mov	r1, r3
 10025c2:	4628      	mov	r0, r5
{
 10025c4:	4617      	mov	r7, r2
 10025c6:	461c      	mov	r4, r3
	if (is_regular_addr_valid(addr, len)) {
 10025c8:	f001 fc1d 	bl	1003e06 <is_regular_addr_valid>
 10025cc:	b158      	cbz	r0, 10025e6 <flash_nrf_write+0x2a>
		addr += DT_REG_ADDR(SOC_NV_FLASH_NODE);
 10025ce:	f105 7580 	add.w	r5, r5, #16777216	; 0x1000000
	return (data & 0x3) ? false : true;
 10025d2:	ea45 0604 	orr.w	r6, r5, r4
	if (!is_aligned_32(addr) || (len % sizeof(uint32_t))) {
 10025d6:	f016 0603 	ands.w	r6, r6, #3
 10025da:	d00d      	beq.n	10025f8 <flash_nrf_write+0x3c>
		LOG_ERR("not word-aligned: 0x%08lx:%zu",
 10025dc:	4623      	mov	r3, r4
 10025de:	462a      	mov	r2, r5
 10025e0:	2145      	movs	r1, #69	; 0x45
 10025e2:	4810      	ldr	r0, [pc, #64]	; (1002624 <flash_nrf_write+0x68>)
 10025e4:	e003      	b.n	10025ee <flash_nrf_write+0x32>
		LOG_ERR("invalid address: 0x%08lx:%zu",
 10025e6:	4623      	mov	r3, r4
 10025e8:	462a      	mov	r2, r5
 10025ea:	2145      	movs	r1, #69	; 0x45
 10025ec:	480e      	ldr	r0, [pc, #56]	; (1002628 <flash_nrf_write+0x6c>)
		LOG_ERR("not word-aligned: 0x%08lx:%zu",
 10025ee:	f001 fb10 	bl	1003c12 <z_log_minimal_printk>
		return -EINVAL;
 10025f2:	f06f 0015 	mvn.w	r0, #21
}
 10025f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (!len) {
 10025f8:	b18c      	cbz	r4, 100261e <flash_nrf_write+0x62>
		}
#endif /* !CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE */
	}
#endif /* CONFIG_SOC_FLASH_NRF_EMULATE_ONE_BYTE_WRITE_ACCESS */
	/* Write all the 4-byte aligned data */
	while (w_ctx->len >= sizeof(uint32_t)) {
 10025fa:	f024 0403 	bic.w	r4, r4, #3
 10025fe:	42a6      	cmp	r6, r4
 1002600:	eb05 0006 	add.w	r0, r5, r6
 1002604:	d106      	bne.n	1002614 <flash_nrf_write+0x58>
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
 1002606:	4a09      	ldr	r2, [pc, #36]	; (100262c <flash_nrf_write+0x70>)
 1002608:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
	while (!nrfx_nvmc_write_done_check()) {
 100260c:	07db      	lsls	r3, r3, #31
 100260e:	d5fb      	bpl.n	1002608 <flash_nrf_write+0x4c>
	return ret;
 1002610:	2000      	movs	r0, #0
 1002612:	e7f0      	b.n	10025f6 <flash_nrf_write+0x3a>
		if (SUSPEND_POFWARN()) {
			return -ECANCELED;
		}

		nrfx_nvmc_word_write(w_ctx->flash_addr,
 1002614:	59b9      	ldr	r1, [r7, r6]
 1002616:	f000 ffb7 	bl	1003588 <nrfx_nvmc_word_write>
	w_ctx->len -= shift;
 100261a:	3604      	adds	r6, #4
}
 100261c:	e7ef      	b.n	10025fe <flash_nrf_write+0x42>
		return 0;
 100261e:	4620      	mov	r0, r4
 1002620:	e7e9      	b.n	10025f6 <flash_nrf_write+0x3a>
 1002622:	bf00      	nop
 1002624:	01004c1e 	.word	0x01004c1e
 1002628:	01004bfc 	.word	0x01004bfc
 100262c:	41080000 	.word	0x41080000

01002630 <flash_nrf_read>:
{
 1002630:	b570      	push	{r4, r5, r6, lr}
 1002632:	460d      	mov	r5, r1
	if (is_regular_addr_valid(addr, len)) {
 1002634:	4619      	mov	r1, r3
 1002636:	4628      	mov	r0, r5
{
 1002638:	4616      	mov	r6, r2
 100263a:	461c      	mov	r4, r3
	if (is_regular_addr_valid(addr, len)) {
 100263c:	f001 fbe3 	bl	1003e06 <is_regular_addr_valid>
 1002640:	b140      	cbz	r0, 1002654 <flash_nrf_read+0x24>
	if (!len) {
 1002642:	b184      	cbz	r4, 1002666 <flash_nrf_read+0x36>
	memcpy(data, (void *)addr, len);
 1002644:	4622      	mov	r2, r4
 1002646:	4630      	mov	r0, r6
 1002648:	f105 7180 	add.w	r1, r5, #16777216	; 0x1000000
 100264c:	f001 fb68 	bl	1003d20 <memcpy>
	return 0;
 1002650:	2000      	movs	r0, #0
 1002652:	e007      	b.n	1002664 <flash_nrf_read+0x34>
		LOG_ERR("invalid address: 0x%08lx:%zu",
 1002654:	4805      	ldr	r0, [pc, #20]	; (100266c <flash_nrf_read+0x3c>)
 1002656:	4623      	mov	r3, r4
 1002658:	462a      	mov	r2, r5
 100265a:	2145      	movs	r1, #69	; 0x45
 100265c:	f001 fad9 	bl	1003c12 <z_log_minimal_printk>
 1002660:	f06f 0015 	mvn.w	r0, #21
}
 1002664:	bd70      	pop	{r4, r5, r6, pc}
		return 0;
 1002666:	4620      	mov	r0, r4
 1002668:	e7fc      	b.n	1002664 <flash_nrf_read+0x34>
 100266a:	bf00      	nop
 100266c:	01004bfc 	.word	0x01004bfc

01002670 <compare_int_lock>:
#endif
}

static bool compare_int_lock(int32_t chan)
{
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
 1002670:	2301      	movs	r3, #1
 1002672:	4083      	lsls	r3, r0
{
 1002674:	b510      	push	{r4, lr}
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
 1002676:	43dc      	mvns	r4, r3
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 1002678:	4a0c      	ldr	r2, [pc, #48]	; (10026ac <compare_int_lock+0x3c>)
 100267a:	e8d2 1fef 	ldaex	r1, [r2]
 100267e:	ea01 0c04 	and.w	ip, r1, r4
 1002682:	e8c2 cfee 	stlex	lr, ip, [r2]
 1002686:	f1be 0f00 	cmp.w	lr, #0
 100268a:	d1f6      	bne.n	100267a <compare_int_lock+0xa>

	nrf_rtc_int_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
 100268c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 1002690:	fa02 f000 	lsl.w	r0, r2, r0
    p_reg->INTENSET = mask;
}

NRF_STATIC_INLINE void nrf_rtc_int_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->INTENCLR = mask;
 1002694:	4a06      	ldr	r2, [pc, #24]	; (10026b0 <compare_int_lock+0x40>)
 1002696:	f8c2 0308 	str.w	r0, [r2, #776]	; 0x308
  __ASM volatile ("dmb 0xF":::"memory");
 100269a:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("isb 0xF":::"memory");
 100269e:	f3bf 8f6f 	isb	sy

	__DMB();
	__ISB();

	return prev & BIT(chan);
 10026a2:	420b      	tst	r3, r1
}
 10026a4:	bf14      	ite	ne
 10026a6:	2001      	movne	r0, #1
 10026a8:	2000      	moveq	r0, #0
 10026aa:	bd10      	pop	{r4, pc}
 10026ac:	2100012c 	.word	0x2100012c
 10026b0:	41016000 	.word	0x41016000

010026b4 <compare_int_unlock>:
	return compare_int_lock(chan);
}

static void compare_int_unlock(int32_t chan, bool key)
{
	if (key) {
 10026b4:	b1e1      	cbz	r1, 10026f0 <compare_int_unlock+0x3c>
		atomic_or(&int_mask, BIT(chan));
 10026b6:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 10026b8:	4a0e      	ldr	r2, [pc, #56]	; (10026f4 <compare_int_unlock+0x40>)
 10026ba:	4083      	lsls	r3, r0
 10026bc:	e8d2 1fef 	ldaex	r1, [r2]
 10026c0:	4319      	orrs	r1, r3
 10026c2:	e8c2 1fec 	stlex	ip, r1, [r2]
 10026c6:	f1bc 0f00 	cmp.w	ip, #0
 10026ca:	d1f7      	bne.n	10026bc <compare_int_unlock+0x8>
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
 10026cc:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    p_reg->INTENSET = mask;
 10026d0:	4a09      	ldr	r2, [pc, #36]	; (10026f8 <compare_int_unlock+0x44>)
 10026d2:	4083      	lsls	r3, r0
 10026d4:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 10026d8:	4b08      	ldr	r3, [pc, #32]	; (10026fc <compare_int_unlock+0x48>)
 10026da:	e8d3 3faf 	lda	r3, [r3]
		if (atomic_get(&force_isr_mask) & BIT(chan)) {
 10026de:	fa23 f000 	lsr.w	r0, r3, r0
 10026e2:	07c3      	lsls	r3, r0, #31
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 10026e4:	bf42      	ittt	mi
 10026e6:	f44f 0280 	movmi.w	r2, #4194304	; 0x400000
 10026ea:	4b05      	ldrmi	r3, [pc, #20]	; (1002700 <compare_int_unlock+0x4c>)
 10026ec:	f8c3 2100 	strmi.w	r2, [r3, #256]	; 0x100
			NVIC_SetPendingIRQ(RTC_IRQn);
		}
	}
}
 10026f0:	4770      	bx	lr
 10026f2:	bf00      	nop
 10026f4:	2100012c 	.word	0x2100012c
 10026f8:	41016000 	.word	0x41016000
 10026fc:	21000128 	.word	0x21000128
 1002700:	e000e100 	.word	0xe000e100

01002704 <z_nrf_rtc_timer_read>:
	compare_int_unlock(chan, key);
}

uint64_t z_nrf_rtc_timer_read(void)
{
	uint64_t val = ((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH;
 1002704:	4b0d      	ldr	r3, [pc, #52]	; (100273c <z_nrf_rtc_timer_read+0x38>)
 1002706:	6818      	ldr	r0, [r3, #0]
 1002708:	0a01      	lsrs	r1, r0, #8
 100270a:	0600      	lsls	r0, r0, #24
  __ASM volatile ("dmb 0xF":::"memory");
 100270c:	f3bf 8f5f 	dmb	sy
    nrf_event_readback((uint8_t *)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type const * p_reg)
{
     return p_reg->COUNTER;
 1002710:	4b0b      	ldr	r3, [pc, #44]	; (1002740 <z_nrf_rtc_timer_read+0x3c>)
 1002712:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504

	__DMB();

	uint32_t cntr = counter();

	val += cntr;
 1002716:	1818      	adds	r0, r3, r0
 1002718:	f141 0100 	adc.w	r1, r1, #0

	if (cntr < OVERFLOW_RISK_RANGE_END) {
 100271c:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 1002720:	d20a      	bcs.n	1002738 <z_nrf_rtc_timer_read+0x34>
		 * due to possibility that this code preempted overflow interrupt before final write
		 * of `overflow_cnt`. Update of `anchor` occurs far in time from this moment, so
		 * `anchor` is considered valid and stable. Because of this timing there is no risk
		 * of incorrect `anchor` value caused by non-atomic read of 64-bit `anchor`.
		 */
		if (val < anchor) {
 1002722:	4b08      	ldr	r3, [pc, #32]	; (1002744 <z_nrf_rtc_timer_read+0x40>)
 1002724:	e9d3 2300 	ldrd	r2, r3, [r3]
 1002728:	4290      	cmp	r0, r2
 100272a:	eb71 0303 	sbcs.w	r3, r1, r3
 100272e:	d203      	bcs.n	1002738 <z_nrf_rtc_timer_read+0x34>
			/* Unhandled overflow, detected, let's add correction */
			val += COUNTER_SPAN;
 1002730:	f110 7080 	adds.w	r0, r0, #16777216	; 0x1000000
 1002734:	f141 0100 	adc.w	r1, r1, #0
		 * check validity using `anchor`
		 */
	}

	return val;
}
 1002738:	4770      	bx	lr
 100273a:	bf00      	nop
 100273c:	21000130 	.word	0x21000130
 1002740:	41016000 	.word	0x41016000
 1002744:	21000018 	.word	0x21000018

01002748 <compare_set>:
{
 1002748:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100274c:	b085      	sub	sp, #20
 100274e:	4616      	mov	r6, r2
 1002750:	4698      	mov	r8, r3
 1002752:	4605      	mov	r5, r0
	key = compare_int_lock(chan);
 1002754:	f7ff ff8c 	bl	1002670 <compare_int_lock>
 1002758:	9000      	str	r0, [sp, #0]
	uint64_t curr_time = z_nrf_rtc_timer_read();
 100275a:	f7ff ffd3 	bl	1002704 <z_nrf_rtc_timer_read>
	if (curr_time < target_time) {
 100275e:	42b0      	cmp	r0, r6
 1002760:	eb71 0308 	sbcs.w	r3, r1, r8
 1002764:	d276      	bcs.n	1002854 <compare_set+0x10c>
		if (target_time - curr_time > COUNTER_SPAN) {
 1002766:	4b43      	ldr	r3, [pc, #268]	; (1002874 <compare_set+0x12c>)
 1002768:	1a30      	subs	r0, r6, r0
 100276a:	eb68 0101 	sbc.w	r1, r8, r1
 100276e:	4298      	cmp	r0, r3
 1002770:	f171 0300 	sbcs.w	r3, r1, #0
 1002774:	d27b      	bcs.n	100286e <compare_set+0x126>
		if (target_time != cc_data[chan].target_time) {
 1002776:	4b40      	ldr	r3, [pc, #256]	; (1002878 <compare_set+0x130>)
 1002778:	eb03 1305 	add.w	r3, r3, r5, lsl #4
 100277c:	e9d3 ab02 	ldrd	sl, fp, [r3, #8]
 1002780:	45d8      	cmp	r8, fp
 1002782:	bf08      	it	eq
 1002784:	4556      	cmpeq	r6, sl
 1002786:	d050      	beq.n	100282a <compare_set+0xe2>
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
 1002788:	f44f 3380 	mov.w	r3, #65536	; 0x10000
	return absolute_time & COUNTER_MAX;
 100278c:	f026 427f 	bic.w	r2, r6, #4278190080	; 0xff000000
	uint32_t cc_val = abs_val & COUNTER_MAX;
 1002790:	4614      	mov	r4, r2
 1002792:	ea4f 0985 	mov.w	r9, r5, lsl #2
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
 1002796:	f105 0750 	add.w	r7, r5, #80	; 0x50
 100279a:	f109 4982 	add.w	r9, r9, #1090519040	; 0x41000000
 100279e:	00bf      	lsls	r7, r7, #2
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
 10027a0:	40ab      	lsls	r3, r5
 10027a2:	f509 39b0 	add.w	r9, r9, #90112	; 0x16000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
 10027a6:	b2bf      	uxth	r7, r7
 10027a8:	f107 4782 	add.w	r7, r7, #1090519040	; 0x41000000
 10027ac:	9301      	str	r3, [sp, #4]
    return p_reg->CC[ch];
 10027ae:	f8d9 0540 	ldr.w	r0, [r9, #1344]	; 0x540
     return p_reg->COUNTER;
 10027b2:	4b32      	ldr	r3, [pc, #200]	; (100287c <compare_set+0x134>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
 10027b4:	f507 37b0 	add.w	r7, r7, #90112	; 0x16000
     return p_reg->COUNTER;
 10027b8:	f8d3 1504 	ldr.w	r1, [r3, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
 10027bc:	1a40      	subs	r0, r0, r1
 10027be:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
 10027c2:	f021 4c7f 	bic.w	ip, r1, #4278190080	; 0xff000000
		if (counter_sub(prev_cc, now) == 1) {
 10027c6:	2801      	cmp	r0, #1
    p_reg->CC[ch] = cc_val;
 10027c8:	f8c9 c540 	str.w	ip, [r9, #1344]	; 0x540
 10027cc:	d107      	bne.n	10027de <compare_set+0x96>
 10027ce:	e9cd 2102 	strd	r2, r1, [sp, #8]
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_BUSY_WAIT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_busy_wait(usec_to_wait);
 10027d2:	2013      	movs	r0, #19
 10027d4:	f001 fc4d 	bl	1004072 <z_impl_k_busy_wait>
 10027d8:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
 10027dc:	4b27      	ldr	r3, [pc, #156]	; (100287c <compare_set+0x134>)
		if (counter_sub(cc_val, now + 2) > COUNTER_HALF_SPAN) {
 10027de:	f101 0c02 	add.w	ip, r1, #2
	return (a - b) & COUNTER_MAX;
 10027e2:	eba4 000c 	sub.w	r0, r4, ip
 10027e6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			cc_val = now + 2;
 10027ea:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 10027ee:	bf88      	it	hi
 10027f0:	4664      	movhi	r4, ip
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
 10027f2:	2000      	movs	r0, #0
 10027f4:	6038      	str	r0, [r7, #0]
 10027f6:	6838      	ldr	r0, [r7, #0]
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
 10027f8:	9801      	ldr	r0, [sp, #4]
 10027fa:	f8c3 0344 	str.w	r0, [r3, #836]	; 0x344
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
 10027fe:	f024 407f 	bic.w	r0, r4, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
 1002802:	f8c9 0540 	str.w	r0, [r9, #1344]	; 0x540
     return p_reg->COUNTER;
 1002806:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
		 (counter_sub(cc_val, now2 + 2) > COUNTER_HALF_SPAN));
 100280a:	4281      	cmp	r1, r0
 100280c:	d006      	beq.n	100281c <compare_set+0xd4>
	return (a - b) & COUNTER_MAX;
 100280e:	1a20      	subs	r0, r4, r0
 1002810:	3802      	subs	r0, #2
 1002812:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	} while ((now2 != now) &&
 1002816:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 100281a:	d819      	bhi.n	1002850 <compare_set+0x108>
	return (a - b) & COUNTER_MAX;
 100281c:	1aa4      	subs	r4, r4, r2
 100281e:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
			target_time += counter_sub(cc_set, cc_value);
 1002822:	eb14 0a06 	adds.w	sl, r4, r6
 1002826:	f148 0b00 	adc.w	fp, r8, #0
	return ret;
 100282a:	2400      	movs	r4, #0
	cc_data[chan].target_time = target_time;
 100282c:	4912      	ldr	r1, [pc, #72]	; (1002878 <compare_set+0x130>)
	cc_data[chan].callback = handler;
 100282e:	980e      	ldr	r0, [sp, #56]	; 0x38
	cc_data[chan].target_time = target_time;
 1002830:	012b      	lsls	r3, r5, #4
 1002832:	eb01 1205 	add.w	r2, r1, r5, lsl #4
	cc_data[chan].callback = handler;
 1002836:	50c8      	str	r0, [r1, r3]
	cc_data[chan].target_time = target_time;
 1002838:	e9c2 ab02 	strd	sl, fp, [r2, #8]
	cc_data[chan].user_context = user_data;
 100283c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 100283e:	6053      	str	r3, [r2, #4]
	compare_int_unlock(chan, key);
 1002840:	4628      	mov	r0, r5
 1002842:	9900      	ldr	r1, [sp, #0]
 1002844:	f7ff ff36 	bl	10026b4 <compare_int_unlock>
}
 1002848:	4620      	mov	r0, r4
 100284a:	b005      	add	sp, #20
 100284c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1002850:	4620      	mov	r0, r4
 1002852:	e7b1      	b.n	10027b8 <compare_set+0x70>
		atomic_or(&force_isr_mask, BIT(chan));
 1002854:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 1002856:	4a0a      	ldr	r2, [pc, #40]	; (1002880 <compare_set+0x138>)
 1002858:	40ab      	lsls	r3, r5
 100285a:	e8d2 1fef 	ldaex	r1, [r2]
 100285e:	4319      	orrs	r1, r3
 1002860:	e8c2 1fe0 	stlex	r0, r1, [r2]
 1002864:	2800      	cmp	r0, #0
 1002866:	d1f8      	bne.n	100285a <compare_set+0x112>
 1002868:	46b2      	mov	sl, r6
 100286a:	46c3      	mov	fp, r8
 100286c:	e7dd      	b.n	100282a <compare_set+0xe2>
			return -EINVAL;
 100286e:	f06f 0415 	mvn.w	r4, #21
 1002872:	e7e5      	b.n	1002840 <compare_set+0xf8>
 1002874:	01000001 	.word	0x01000001
 1002878:	21000020 	.word	0x21000020
 100287c:	41016000 	.word	0x41016000
 1002880:	21000128 	.word	0x21000128

01002884 <sys_clock_driver_init>:
{
	return (uint32_t)z_nrf_rtc_timer_read();
}

static int sys_clock_driver_init(const struct device *dev)
{
 1002884:	b573      	push	{r0, r1, r4, r5, r6, lr}
    p_reg->PRESCALER = val;
 1002886:	2400      	movs	r4, #0
			CLOCK_CONTROL_NRF_LF_START_STABLE);

	/* TODO: replace with counter driver to access RTC */
	nrf_rtc_prescaler_set(RTC, 0);
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
		cc_data[chan].target_time = TARGET_TIME_INVALID;
 1002888:	f04f 30ff 	mov.w	r0, #4294967295
 100288c:	f04f 31ff 	mov.w	r1, #4294967295
 1002890:	4d17      	ldr	r5, [pc, #92]	; (10028f0 <sys_clock_driver_init+0x6c>)
 1002892:	4b18      	ldr	r3, [pc, #96]	; (10028f4 <sys_clock_driver_init+0x70>)
 1002894:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
 1002898:	e9c3 0102 	strd	r0, r1, [r3, #8]
    p_reg->INTENSET = mask;
 100289c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 10028a0:	2602      	movs	r6, #2
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 10028a2:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 10028a6:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
 10028aa:	4b13      	ldr	r3, [pc, #76]	; (10028f8 <sys_clock_driver_init+0x74>)

	nrf_rtc_int_enable(RTC, NRF_RTC_INT_OVERFLOW_MASK);

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
 10028ac:	2101      	movs	r1, #1
 10028ae:	f8c5 6304 	str.w	r6, [r5, #772]	; 0x304
 10028b2:	2016      	movs	r0, #22
 10028b4:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
 10028b8:	4622      	mov	r2, r4
 10028ba:	f7ff f943 	bl	1001b44 <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
 10028be:	2016      	movs	r0, #22
 10028c0:	f7ff f922 	bl	1001b08 <arch_irq_enable>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
 10028c4:	2301      	movs	r3, #1

	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_CLEAR);
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_START);

	int_mask = BIT_MASK(CHAN_COUNT);
 10028c6:	4a0d      	ldr	r2, [pc, #52]	; (10028fc <sys_clock_driver_init+0x78>)
 10028c8:	60ab      	str	r3, [r5, #8]
 10028ca:	602b      	str	r3, [r5, #0]
 10028cc:	6013      	str	r3, [r2, #0]
     return p_reg->COUNTER;
 10028ce:	f8d5 2504 	ldr.w	r2, [r5, #1284]	; 0x504

	uint32_t initial_timeout = IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
		(COUNTER_HALF_SPAN - 1) :
		(counter() + CYC_PER_TICK);

	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
 10028d2:	4b0b      	ldr	r3, [pc, #44]	; (1002900 <sys_clock_driver_init+0x7c>)
 10028d4:	f502 7280 	add.w	r2, r2, #256	; 0x100
 10028d8:	9300      	str	r3, [sp, #0]
 10028da:	4620      	mov	r0, r4
 10028dc:	4623      	mov	r3, r4
 10028de:	9401      	str	r4, [sp, #4]
 10028e0:	f7ff ff32 	bl	1002748 <compare_set>

	z_nrf_clock_control_lf_on(mode);
 10028e4:	4630      	mov	r0, r6
 10028e6:	f7ff fd87 	bl	10023f8 <z_nrf_clock_control_lf_on>

	return 0;
}
 10028ea:	4620      	mov	r0, r4
 10028ec:	b002      	add	sp, #8
 10028ee:	bd70      	pop	{r4, r5, r6, pc}
 10028f0:	41016000 	.word	0x41016000
 10028f4:	21000020 	.word	0x21000020
 10028f8:	e000e100 	.word	0xe000e100
 10028fc:	2100012c 	.word	0x2100012c
 1002900:	01002905 	.word	0x01002905

01002904 <sys_clock_timeout_handler>:
{
 1002904:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
 1002908:	4929      	ldr	r1, [pc, #164]	; (10029b0 <sys_clock_timeout_handler+0xac>)
{
 100290a:	4605      	mov	r5, r0
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
 100290c:	e9d1 0c00 	ldrd	r0, ip, [r1]
 1002910:	1a14      	subs	r4, r2, r0
	return absolute_time & COUNTER_MAX;
 1002912:	f022 467f 	bic.w	r6, r2, #4278190080	; 0xff000000
	last_count += dticks * CYC_PER_TICK;
 1002916:	f024 02ff 	bic.w	r2, r4, #255	; 0xff
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
 100291a:	eb63 070c 	sbc.w	r7, r3, ip
	last_count += dticks * CYC_PER_TICK;
 100291e:	1812      	adds	r2, r2, r0
 1002920:	eb4c 0307 	adc.w	r3, ip, r7
 1002924:	e9c1 2300 	strd	r2, r3, [r1]
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
 1002928:	f5a6 1100 	sub.w	r1, r6, #2097152	; 0x200000
	if (in_anchor_range(cc_value)) {
 100292c:	f5b1 0f40 	cmp.w	r1, #12582912	; 0xc00000
 1002930:	d23a      	bcs.n	10029a8 <sys_clock_timeout_handler+0xa4>
		anchor = (((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH) + cc_value;
 1002932:	4920      	ldr	r1, [pc, #128]	; (10029b4 <sys_clock_timeout_handler+0xb0>)
 1002934:	6809      	ldr	r1, [r1, #0]
 1002936:	0a08      	lsrs	r0, r1, #8
 1002938:	0609      	lsls	r1, r1, #24
 100293a:	eb11 0806 	adds.w	r8, r1, r6
 100293e:	491e      	ldr	r1, [pc, #120]	; (10029b8 <sys_clock_timeout_handler+0xb4>)
 1002940:	f140 0900 	adc.w	r9, r0, #0
 1002944:	e9c1 8900 	strd	r8, r9, [r1]
		return true;
 1002948:	f04f 0801 	mov.w	r8, #1
		compare_set(chan, last_count + CYC_PER_TICK,
 100294c:	2100      	movs	r1, #0
 100294e:	9101      	str	r1, [sp, #4]
 1002950:	491a      	ldr	r1, [pc, #104]	; (10029bc <sys_clock_timeout_handler+0xb8>)
 1002952:	f512 7280 	adds.w	r2, r2, #256	; 0x100
 1002956:	f143 0300 	adc.w	r3, r3, #0
 100295a:	9100      	str	r1, [sp, #0]
 100295c:	4628      	mov	r0, r5
 100295e:	f7ff fef3 	bl	1002748 <compare_set>
	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
 1002962:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
 1002966:	f177 0300 	sbcs.w	r3, r7, #0
 100296a:	bf2c      	ite	cs
 100296c:	2001      	movcs	r0, #1
 100296e:	2000      	movcc	r0, #0
 1002970:	f000 ff5e 	bl	1003830 <sys_clock_announce>
    return p_reg->CC[ch];
 1002974:	00ab      	lsls	r3, r5, #2
 1002976:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
 100297a:	f503 33b0 	add.w	r3, r3, #90112	; 0x16000
 100297e:	f8d3 2540 	ldr.w	r2, [r3, #1344]	; 0x540
	if (cc_value == get_comparator(chan)) {
 1002982:	4296      	cmp	r6, r2
 1002984:	d10d      	bne.n	10029a2 <sys_clock_timeout_handler+0x9e>
		if (!anchor_updated) {
 1002986:	f1b8 0f00 	cmp.w	r8, #0
 100298a:	d103      	bne.n	1002994 <sys_clock_timeout_handler+0x90>
    p_reg->CC[ch] = cc_val;
 100298c:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
 1002990:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
 1002994:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    p_reg->EVTENSET = mask;
 1002998:	4b09      	ldr	r3, [pc, #36]	; (10029c0 <sys_clock_timeout_handler+0xbc>)
 100299a:	fa00 f505 	lsl.w	r5, r0, r5
 100299e:	f8c3 5344 	str.w	r5, [r3, #836]	; 0x344
}
 10029a2:	b003      	add	sp, #12
 10029a4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	return false;
 10029a8:	f04f 0800 	mov.w	r8, #0
 10029ac:	e7ce      	b.n	100294c <sys_clock_timeout_handler+0x48>
 10029ae:	bf00      	nop
 10029b0:	21000030 	.word	0x21000030
 10029b4:	21000130 	.word	0x21000130
 10029b8:	21000018 	.word	0x21000018
 10029bc:	01002905 	.word	0x01002905
 10029c0:	41016000 	.word	0x41016000

010029c4 <rtc_nrf_isr>:
    return p_reg->INTENSET & mask;
 10029c4:	4b35      	ldr	r3, [pc, #212]	; (1002a9c <rtc_nrf_isr+0xd8>)
{
 10029c6:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 10029ca:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, NRF_RTC_INT_OVERFLOW_MASK) &&
 10029ce:	0791      	lsls	r1, r2, #30
 10029d0:	d50b      	bpl.n	10029ea <rtc_nrf_isr+0x26>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
 10029d2:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 10029d6:	b142      	cbz	r2, 10029ea <rtc_nrf_isr+0x26>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
 10029d8:	2200      	movs	r2, #0
 10029da:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
		overflow_cnt++;
 10029de:	4a30      	ldr	r2, [pc, #192]	; (1002aa0 <rtc_nrf_isr+0xdc>)
 10029e0:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 10029e4:	6813      	ldr	r3, [r2, #0]
 10029e6:	3301      	adds	r3, #1
 10029e8:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
 10029ea:	f04f 0320 	mov.w	r3, #32
 10029ee:	f3ef 8111 	mrs	r1, BASEPRI
 10029f2:	f383 8812 	msr	BASEPRI_MAX, r3
 10029f6:	f3bf 8f6f 	isb	sy
    return p_reg->INTENSET & mask;
 10029fa:	4b28      	ldr	r3, [pc, #160]	; (1002a9c <rtc_nrf_isr+0xd8>)
 10029fc:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan))) {
 1002a00:	03d2      	lsls	r2, r2, #15
 1002a02:	d50e      	bpl.n	1002a22 <rtc_nrf_isr+0x5e>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 1002a04:	4a27      	ldr	r2, [pc, #156]	; (1002aa4 <rtc_nrf_isr+0xe0>)
 1002a06:	e8d2 0fef 	ldaex	r0, [r2]
 1002a0a:	f020 0401 	bic.w	r4, r0, #1
 1002a0e:	e8c2 4fe5 	stlex	r5, r4, [r2]
 1002a12:	2d00      	cmp	r5, #0
 1002a14:	d1f7      	bne.n	1002a06 <rtc_nrf_isr+0x42>
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
 1002a16:	2800      	cmp	r0, #0
 1002a18:	d137      	bne.n	1002a8a <rtc_nrf_isr+0xc6>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
 1002a1a:	f8d3 2140 	ldr.w	r2, [r3, #320]	; 0x140
		if (result) {
 1002a1e:	2a00      	cmp	r2, #0
 1002a20:	d133      	bne.n	1002a8a <rtc_nrf_isr+0xc6>
{
 1002a22:	2300      	movs	r3, #0
	__asm__ volatile(
 1002a24:	f381 8811 	msr	BASEPRI, r1
 1002a28:	f3bf 8f6f 	isb	sy
	if (channel_processing_check_and_clear(chan)) {
 1002a2c:	b353      	cbz	r3, 1002a84 <rtc_nrf_isr+0xc0>
		curr_time = z_nrf_rtc_timer_read();
 1002a2e:	f7ff fe69 	bl	1002704 <z_nrf_rtc_timer_read>
	__asm__ volatile(
 1002a32:	f04f 0320 	mov.w	r3, #32
 1002a36:	f3ef 8711 	mrs	r7, BASEPRI
 1002a3a:	f383 8812 	msr	BASEPRI_MAX, r3
 1002a3e:	f3bf 8f6f 	isb	sy
		expire_time = cc_data[chan].target_time;
 1002a42:	4b19      	ldr	r3, [pc, #100]	; (1002aa8 <rtc_nrf_isr+0xe4>)
 1002a44:	e9d3 4502 	ldrd	r4, r5, [r3, #8]
		if (curr_time >= expire_time) {
 1002a48:	42a0      	cmp	r0, r4
 1002a4a:	eb71 0205 	sbcs.w	r2, r1, r5
 1002a4e:	f04f 0200 	mov.w	r2, #0
 1002a52:	d321      	bcc.n	1002a98 <rtc_nrf_isr+0xd4>
			user_context = cc_data[chan].user_context;
 1002a54:	e9d3 1600 	ldrd	r1, r6, [r3]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
 1002a58:	f04f 38ff 	mov.w	r8, #4294967295
 1002a5c:	f04f 39ff 	mov.w	r9, #4294967295
			cc_data[chan].callback = NULL;
 1002a60:	601a      	str	r2, [r3, #0]
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
 1002a62:	f44f 3280 	mov.w	r2, #65536	; 0x10000
			cc_data[chan].target_time = TARGET_TIME_INVALID;
 1002a66:	e9c3 8902 	strd	r8, r9, [r3, #8]
 1002a6a:	4b0c      	ldr	r3, [pc, #48]	; (1002a9c <rtc_nrf_isr+0xd8>)
 1002a6c:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
	__asm__ volatile(
 1002a70:	f387 8811 	msr	BASEPRI, r7
 1002a74:	f3bf 8f6f 	isb	sy
		if (handler) {
 1002a78:	b121      	cbz	r1, 1002a84 <rtc_nrf_isr+0xc0>
			handler(chan, expire_time, user_context);
 1002a7a:	4622      	mov	r2, r4
 1002a7c:	462b      	mov	r3, r5
 1002a7e:	2000      	movs	r0, #0
 1002a80:	9600      	str	r6, [sp, #0]
 1002a82:	4788      	blx	r1
}
 1002a84:	b003      	add	sp, #12
 1002a86:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
 1002a8a:	2200      	movs	r2, #0
 1002a8c:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
 1002a90:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
 1002a94:	2301      	movs	r3, #1
}
 1002a96:	e7c5      	b.n	1002a24 <rtc_nrf_isr+0x60>
		z_nrf_rtc_timer_compare_handler_t handler = NULL;
 1002a98:	4611      	mov	r1, r2
 1002a9a:	e7e9      	b.n	1002a70 <rtc_nrf_isr+0xac>
 1002a9c:	41016000 	.word	0x41016000
 1002aa0:	21000130 	.word	0x21000130
 1002aa4:	21000128 	.word	0x21000128
 1002aa8:	21000020 	.word	0x21000020

01002aac <find_free_region>:
#include <zephyr/sys/__assert.h>
#include <zephyr/kernel.h>

/* Find the first unused ACL region. */
static int find_free_region(uint32_t *region_idx)
{
 1002aac:	b530      	push	{r4, r5, lr}
	static uint32_t idx;

	while (nrf_acl_region_perm_get(NRF_ACL, idx) != 0) {
 1002aae:	2400      	movs	r4, #0
 1002ab0:	4a0b      	ldr	r2, [pc, #44]	; (1002ae0 <find_free_region+0x34>)
}

NRF_STATIC_INLINE nrf_acl_perm_t nrf_acl_region_perm_get(NRF_ACL_Type const * p_reg,
                                                         uint32_t             region_id)
{
    return (nrf_acl_perm_t)p_reg->ACL[region_id].PERM;
 1002ab2:	4d0c      	ldr	r5, [pc, #48]	; (1002ae4 <find_free_region+0x38>)
 1002ab4:	6813      	ldr	r3, [r2, #0]
 1002ab6:	eb05 1103 	add.w	r1, r5, r3, lsl #4
 1002aba:	f8d1 1808 	ldr.w	r1, [r1, #2056]	; 0x808
 1002abe:	b2c9      	uxtb	r1, r1
 1002ac0:	b921      	cbnz	r1, 1002acc <find_free_region+0x20>
 1002ac2:	b104      	cbz	r4, 1002ac6 <find_free_region+0x1a>
 1002ac4:	6013      	str	r3, [r2, #0]
		if (idx >= ACL_REGIONS_COUNT) {
			*region_idx = idx;
			return -ENOSPC;
		}
	}
	*region_idx = idx;
 1002ac6:	6003      	str	r3, [r0, #0]
	return 0;
 1002ac8:	2000      	movs	r0, #0
 1002aca:	e008      	b.n	1002ade <find_free_region+0x32>
		idx++;
 1002acc:	3301      	adds	r3, #1
		if (idx >= ACL_REGIONS_COUNT) {
 1002ace:	2b07      	cmp	r3, #7
 1002ad0:	f04f 0401 	mov.w	r4, #1
 1002ad4:	d9ef      	bls.n	1002ab6 <find_free_region+0xa>
			*region_idx = idx;
 1002ad6:	6003      	str	r3, [r0, #0]
			return -ENOSPC;
 1002ad8:	f06f 001b 	mvn.w	r0, #27
 1002adc:	6013      	str	r3, [r2, #0]
}
 1002ade:	bd30      	pop	{r4, r5, pc}
 1002ae0:	21000134 	.word	0x21000134
 1002ae4:	41080000 	.word	0x41080000

01002ae8 <fprotect_set_permission>:
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE uint32_t nrf_ficr_codepagesize_get(NRF_FICR_Type const * p_reg)
{
#if defined(FICR_INFO_CODEPAGESIZE_CODEPAGESIZE_Msk)
    return p_reg->INFO.CODEPAGESIZE;
 1002ae8:	4b4f      	ldr	r3, [pc, #316]	; (1002c28 <fprotect_set_permission+0x140>)

static int fprotect_set_permission(uint32_t start, size_t length,
				   size_t permission)
{
 1002aea:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 1002aee:	f8d3 3220 	ldr.w	r3, [r3, #544]	; 0x220
 1002af2:	4606      	mov	r6, r0
	__ASSERT_NO_MSG(nrf_ficr_codepagesize_get(NRF_FICR) ==
 1002af4:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
{
 1002af8:	460d      	mov	r5, r1
 1002afa:	4690      	mov	r8, r2
	__ASSERT_NO_MSG(nrf_ficr_codepagesize_get(NRF_FICR) ==
 1002afc:	d008      	beq.n	1002b10 <fprotect_set_permission+0x28>
 1002afe:	494b      	ldr	r1, [pc, #300]	; (1002c2c <fprotect_set_permission+0x144>)
 1002b00:	484b      	ldr	r0, [pc, #300]	; (1002c30 <fprotect_set_permission+0x148>)
 1002b02:	2221      	movs	r2, #33	; 0x21
 1002b04:	f001 f877 	bl	1003bf6 <assert_print>
 1002b08:	2121      	movs	r1, #33	; 0x21
 1002b0a:	4848      	ldr	r0, [pc, #288]	; (1002c2c <fprotect_set_permission+0x144>)
 1002b0c:	f001 f86c 	bl	1003be8 <assert_post_action>
			CONFIG_FPROTECT_BLOCK_SIZE);

	uint32_t region_idx;
	int result = find_free_region(&region_idx);
 1002b10:	a801      	add	r0, sp, #4
 1002b12:	f7ff ffcb 	bl	1002aac <find_free_region>

	if (result != 0) {
 1002b16:	4604      	mov	r4, r0
 1002b18:	2800      	cmp	r0, #0
 1002b1a:	d17b      	bne.n	1002c14 <fprotect_set_permission+0x12c>
 1002b1c:	4b42      	ldr	r3, [pc, #264]	; (1002c28 <fprotect_set_permission+0x140>)
 1002b1e:	f8d3 1220 	ldr.w	r1, [r3, #544]	; 0x220
		return result;
	}

	if (start % nrf_ficr_codepagesize_get(NRF_FICR) != 0 ||
 1002b22:	fbb6 f2f1 	udiv	r2, r6, r1
 1002b26:	fb01 6212 	mls	r2, r1, r2, r6
 1002b2a:	2a00      	cmp	r2, #0
 1002b2c:	d176      	bne.n	1002c1c <fprotect_set_permission+0x134>
 1002b2e:	f8d3 1220 	ldr.w	r1, [r3, #544]	; 0x220
	    length % nrf_ficr_codepagesize_get(NRF_FICR) != 0 ||
 1002b32:	fbb5 f2f1 	udiv	r2, r5, r1
 1002b36:	fb01 5212 	mls	r2, r1, r2, r5
	if (start % nrf_ficr_codepagesize_get(NRF_FICR) != 0 ||
 1002b3a:	2a00      	cmp	r2, #0
 1002b3c:	d16e      	bne.n	1002c1c <fprotect_set_permission+0x134>
 1002b3e:	f8d3 2220 	ldr.w	r2, [r3, #544]	; 0x220
}

NRF_STATIC_INLINE uint32_t nrf_ficr_codesize_get(NRF_FICR_Type const * p_reg)
{
#if defined(FICR_INFO_CODESIZE_CODESIZE_Msk)
    return p_reg->INFO.CODESIZE;
 1002b42:	f8d3 3224 	ldr.w	r3, [r3, #548]	; 0x224
	    length > NRF_ACL_REGION_SIZE_MAX || length == 0) {
 1002b46:	4353      	muls	r3, r2
	    length % nrf_ficr_codepagesize_get(NRF_FICR) != 0 ||
 1002b48:	42ab      	cmp	r3, r5
 1002b4a:	d367      	bcc.n	1002c1c <fprotect_set_permission+0x134>
	    length > NRF_ACL_REGION_SIZE_MAX || length == 0) {
 1002b4c:	2d00      	cmp	r5, #0
 1002b4e:	d065      	beq.n	1002c1c <fprotect_set_permission+0x134>
		return -EINVAL;
	}

	nrf_acl_region_set(NRF_ACL, region_idx, start, length, permission);
 1002b50:	9f01      	ldr	r7, [sp, #4]
    NRFX_ASSERT(region_id < ACL_REGIONS_COUNT);
 1002b52:	2f07      	cmp	r7, #7
 1002b54:	d908      	bls.n	1002b68 <fprotect_set_permission+0x80>
 1002b56:	4937      	ldr	r1, [pc, #220]	; (1002c34 <fprotect_set_permission+0x14c>)
 1002b58:	4835      	ldr	r0, [pc, #212]	; (1002c30 <fprotect_set_permission+0x148>)
 1002b5a:	2277      	movs	r2, #119	; 0x77
 1002b5c:	f001 f84b 	bl	1003bf6 <assert_print>
 1002b60:	2177      	movs	r1, #119	; 0x77
 1002b62:	4834      	ldr	r0, [pc, #208]	; (1002c34 <fprotect_set_permission+0x14c>)
 1002b64:	f001 f840 	bl	1003be8 <assert_post_action>
    return p_reg->INFO.CODEPAGESIZE;
 1002b68:	f8df 90bc 	ldr.w	r9, [pc, #188]	; 1002c28 <fprotect_set_permission+0x140>
 1002b6c:	f8d9 2220 	ldr.w	r2, [r9, #544]	; 0x220
    NRFX_ASSERT(address % nrf_ficr_codepagesize_get(NRF_FICR) == 0);
 1002b70:	fbb6 f3f2 	udiv	r3, r6, r2
 1002b74:	fb02 6313 	mls	r3, r2, r3, r6
 1002b78:	b143      	cbz	r3, 1002b8c <fprotect_set_permission+0xa4>
 1002b7a:	492e      	ldr	r1, [pc, #184]	; (1002c34 <fprotect_set_permission+0x14c>)
 1002b7c:	482c      	ldr	r0, [pc, #176]	; (1002c30 <fprotect_set_permission+0x148>)
 1002b7e:	2278      	movs	r2, #120	; 0x78
 1002b80:	f001 f839 	bl	1003bf6 <assert_print>
 1002b84:	2178      	movs	r1, #120	; 0x78
 1002b86:	482b      	ldr	r0, [pc, #172]	; (1002c34 <fprotect_set_permission+0x14c>)
 1002b88:	f001 f82e 	bl	1003be8 <assert_post_action>
 1002b8c:	f8d9 3220 	ldr.w	r3, [r9, #544]	; 0x220
    return p_reg->INFO.CODESIZE;
 1002b90:	f8d9 2224 	ldr.w	r2, [r9, #548]	; 0x224
    NRFX_ASSERT(size <= NRF_ACL_REGION_SIZE_MAX);
 1002b94:	4353      	muls	r3, r2
 1002b96:	429d      	cmp	r5, r3
 1002b98:	d908      	bls.n	1002bac <fprotect_set_permission+0xc4>
 1002b9a:	4926      	ldr	r1, [pc, #152]	; (1002c34 <fprotect_set_permission+0x14c>)
 1002b9c:	4824      	ldr	r0, [pc, #144]	; (1002c30 <fprotect_set_permission+0x148>)
 1002b9e:	2279      	movs	r2, #121	; 0x79
 1002ba0:	f001 f829 	bl	1003bf6 <assert_print>
 1002ba4:	2179      	movs	r1, #121	; 0x79
 1002ba6:	4823      	ldr	r0, [pc, #140]	; (1002c34 <fprotect_set_permission+0x14c>)
 1002ba8:	f001 f81e 	bl	1003be8 <assert_post_action>
    return p_reg->INFO.CODEPAGESIZE;
 1002bac:	4b1e      	ldr	r3, [pc, #120]	; (1002c28 <fprotect_set_permission+0x140>)
 1002bae:	f8d3 2220 	ldr.w	r2, [r3, #544]	; 0x220
    NRFX_ASSERT(size % nrf_ficr_codepagesize_get(NRF_FICR) == 0);
 1002bb2:	fbb5 f3f2 	udiv	r3, r5, r2
 1002bb6:	fb02 5313 	mls	r3, r2, r3, r5
 1002bba:	b143      	cbz	r3, 1002bce <fprotect_set_permission+0xe6>
 1002bbc:	491d      	ldr	r1, [pc, #116]	; (1002c34 <fprotect_set_permission+0x14c>)
 1002bbe:	481c      	ldr	r0, [pc, #112]	; (1002c30 <fprotect_set_permission+0x148>)
 1002bc0:	227b      	movs	r2, #123	; 0x7b
 1002bc2:	f001 f818 	bl	1003bf6 <assert_print>
 1002bc6:	217b      	movs	r1, #123	; 0x7b
 1002bc8:	481a      	ldr	r0, [pc, #104]	; (1002c34 <fprotect_set_permission+0x14c>)
 1002bca:	f001 f80d 	bl	1003be8 <assert_post_action>
    p_reg->ACL[region_id].ADDR = address;
 1002bce:	013f      	lsls	r7, r7, #4
 1002bd0:	f107 4382 	add.w	r3, r7, #1090519040	; 0x41000000
 1002bd4:	f503 2300 	add.w	r3, r3, #524288	; 0x80000
 1002bd8:	f8c3 6800 	str.w	r6, [r3, #2048]	; 0x800
    p_reg->ACL[region_id].SIZE = size;
 1002bdc:	f8c3 5804 	str.w	r5, [r3, #2052]	; 0x804
    p_reg->ACL[region_id].PERM = perm;
 1002be0:	4b15      	ldr	r3, [pc, #84]	; (1002c38 <fprotect_set_permission+0x150>)
 1002be2:	441f      	add	r7, r3
 1002be4:	f8c7 8808 	str.w	r8, [r7, #2056]	; 0x808

	if ((nrf_acl_region_address_get(NRF_ACL, region_idx) != start)
 1002be8:	9a01      	ldr	r2, [sp, #4]
    return (uint32_t)p_reg->ACL[region_id].ADDR;
 1002bea:	0112      	lsls	r2, r2, #4
 1002bec:	f102 4182 	add.w	r1, r2, #1090519040	; 0x41000000
 1002bf0:	f501 2100 	add.w	r1, r1, #524288	; 0x80000
 1002bf4:	f8d1 0800 	ldr.w	r0, [r1, #2048]	; 0x800
 1002bf8:	4286      	cmp	r6, r0
 1002bfa:	d112      	bne.n	1002c22 <fprotect_set_permission+0x13a>
    return (size_t)p_reg->ACL[region_id].SIZE;
 1002bfc:	f8d1 1804 	ldr.w	r1, [r1, #2052]	; 0x804
		|| (nrf_acl_region_size_get(NRF_ACL, region_idx) != length)
 1002c00:	428d      	cmp	r5, r1
 1002c02:	d10e      	bne.n	1002c22 <fprotect_set_permission+0x13a>
    return (nrf_acl_perm_t)p_reg->ACL[region_id].PERM;
 1002c04:	4413      	add	r3, r2
 1002c06:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
		|| (nrf_acl_region_perm_get(NRF_ACL, region_idx) != permission)) {
 1002c0a:	b2db      	uxtb	r3, r3
		return -EFAULT;
 1002c0c:	4598      	cmp	r8, r3
 1002c0e:	bf18      	it	ne
 1002c10:	f06f 040d 	mvnne.w	r4, #13
	}

	return 0;
}
 1002c14:	4620      	mov	r0, r4
 1002c16:	b003      	add	sp, #12
 1002c18:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return -EINVAL;
 1002c1c:	f06f 0415 	mvn.w	r4, #21
 1002c20:	e7f8      	b.n	1002c14 <fprotect_set_permission+0x12c>
		return -EFAULT;
 1002c22:	f06f 040d 	mvn.w	r4, #13
 1002c26:	e7f5      	b.n	1002c14 <fprotect_set_permission+0x12c>
 1002c28:	01ff0000 	.word	0x01ff0000
 1002c2c:	01004c65 	.word	0x01004c65
 1002c30:	010044ec 	.word	0x010044ec
 1002c34:	01004c91 	.word	0x01004c91
 1002c38:	41080000 	.word	0x41080000

01002c3c <k_sys_fatal_error_handler>:
	defined(CONFIG_SPM_SERVICE_NS_HANDLER_FROM_SPM_FAULT)
	z_spm_ns_fatal_error_handler();
#endif

	if (IS_ENABLED(CONFIG_RESET_ON_FATAL_ERROR)) {
		LOG_ERR("Resetting system");
 1002c3c:	4803      	ldr	r0, [pc, #12]	; (1002c4c <k_sys_fatal_error_handler+0x10>)
 1002c3e:	2145      	movs	r1, #69	; 0x45
{
 1002c40:	b508      	push	{r3, lr}
		LOG_ERR("Resetting system");
 1002c42:	f000 ffe6 	bl	1003c12 <z_log_minimal_printk>
		sys_arch_reboot(0);
 1002c46:	2000      	movs	r0, #0
 1002c48:	f7ff fa48 	bl	10020dc <sys_arch_reboot>
		for (;;) {
			/* Spin endlessly */
		}
	}

	CODE_UNREACHABLE;
 1002c4c:	01004cc3 	.word	0x01004cc3

01002c50 <bl_boot>:
#else
#define VTOR SCB->VTOR
#endif

void bl_boot(const struct fw_info *fw_info)
{
 1002c50:	b538      	push	{r3, r4, r5, lr}
 1002c52:	4604      	mov	r4, r0
#if CONFIG_ARCH_HAS_USERSPACE
	__ASSERT(!(CONTROL_nPRIV_Msk & __get_CONTROL()),
			"Not in Privileged mode");
#endif

	printk("Booting (0x%x).\r\n", fw_info->address);
 1002c54:	6981      	ldr	r1, [r0, #24]
 1002c56:	4828      	ldr	r0, [pc, #160]	; (1002cf8 <bl_boot+0xa8>)
 1002c58:	f000 fefb 	bl	1003a52 <printk>
    p_reg->INTENCLR = mask;
 1002c5c:	f04f 31ff 	mov.w	r1, #4294967295
 1002c60:	4b26      	ldr	r3, [pc, #152]	; (1002cfc <bl_boot+0xac>)
 1002c62:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
  __ASM volatile ("isb 0xF":::"memory");
 1002c66:	f3bf 8f6f 	isb	sy
  __ASM volatile ("cpsid i" : : : "memory");
 1002c6a:	b672      	cpsid	i
 1002c6c:	2300      	movs	r3, #0
	__ISB();
	__disable_irq();
	NVIC_Type *nvic = NVIC;
	/* Disable NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(nvic->ICER); i++) {
		nvic->ICER[i] = 0xFFFFFFFF;
 1002c6e:	4a24      	ldr	r2, [pc, #144]	; (1002d00 <bl_boot+0xb0>)
 1002c70:	f103 0020 	add.w	r0, r3, #32
	for (uint8_t i = 0; i < ARRAY_SIZE(nvic->ICER); i++) {
 1002c74:	3301      	adds	r3, #1
 1002c76:	2b10      	cmp	r3, #16
		nvic->ICER[i] = 0xFFFFFFFF;
 1002c78:	f842 1020 	str.w	r1, [r2, r0, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(nvic->ICER); i++) {
 1002c7c:	d1f8      	bne.n	1002c70 <bl_boot+0x20>
 1002c7e:	2300      	movs	r3, #0
	}
	/* Clear pending NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(nvic->ICPR); i++) {
		nvic->ICPR[i] = 0xFFFFFFFF;
 1002c80:	f04f 30ff 	mov.w	r0, #4294967295
 1002c84:	f103 0160 	add.w	r1, r3, #96	; 0x60
	for (uint8_t i = 0; i < ARRAY_SIZE(nvic->ICPR); i++) {
 1002c88:	3301      	adds	r3, #1
 1002c8a:	2b10      	cmp	r3, #16
		nvic->ICPR[i] = 0xFFFFFFFF;
 1002c8c:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(nvic->ICPR); i++) {
 1002c90:	d1f8      	bne.n	1002c84 <bl_boot+0x34>
	}


	SysTick->CTRL = 0;
 1002c92:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 1002c96:	2200      	movs	r2, #0
 1002c98:	611a      	str	r2, [r3, #16]

	/* Disable fault handlers used by the bootloader */
	SCB->ICSR |= SCB_ICSR_PENDSTCLR_Msk;
 1002c9a:	f8d3 2d04 	ldr.w	r2, [r3, #3332]	; 0xd04
 1002c9e:	f503 6350 	add.w	r3, r3, #3328	; 0xd00
 1002ca2:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 1002ca6:	605a      	str	r2, [r3, #4]

#ifndef CONFIG_CPU_CORTEX_M0
	SCB->SHCSR &= ~(SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_BUSFAULTENA_Msk |
 1002ca8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 1002caa:	f422 22e0 	bic.w	r2, r2, #458752	; 0x70000
 1002cae:	625a      	str	r2, [r3, #36]	; 0x24
  __ASM volatile ("MRS %0, control" : "=r" (result) );
 1002cb0:	f3ef 8214 	mrs	r2, CONTROL
			SCB_SHCSR_MEMFAULTENA_Msk);
#endif

	/* Activate the MSP if the core is currently running with the PSP */
	if (CONTROL_SPSEL_Msk & __get_CONTROL()) {
 1002cb4:	0792      	lsls	r2, r2, #30
 1002cb6:	d507      	bpl.n	1002cc8 <bl_boot+0x78>
 1002cb8:	f3ef 8214 	mrs	r2, CONTROL
		__set_CONTROL(__get_CONTROL() & ~CONTROL_SPSEL_Msk);
 1002cbc:	f022 0202 	bic.w	r2, r2, #2
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 1002cc0:	f382 8814 	msr	CONTROL, r2
  __ASM volatile ("isb 0xF":::"memory");
 1002cc4:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
 1002cc8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 1002ccc:	f3bf 8f6f 	isb	sy
	}

	__DSB(); /* Force Memory Write before continuing */
	__ISB(); /* Flush and refill pipeline with updated permissions */

	VTOR = fw_info->address;
 1002cd0:	69a5      	ldr	r5, [r4, #24]
	uint32_t *vector_table = (uint32_t *)fw_info->address;

	if (!fw_info_ext_api_provide(fw_info, true)) {
 1002cd2:	2101      	movs	r1, #1
 1002cd4:	4620      	mov	r0, r4
	VTOR = fw_info->address;
 1002cd6:	609d      	str	r5, [r3, #8]
	if (!fw_info_ext_api_provide(fw_info, true)) {
 1002cd8:	f000 f9f8 	bl	10030cc <fw_info_ext_api_provide>
 1002cdc:	b158      	cbz	r0, 1002cf6 <bl_boot+0xa6>
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 1002cde:	2300      	movs	r3, #0
 1002ce0:	f383 880b 	msr	PSPLIM, r3
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure MSPLIM is RAZ/WI
  (void)MainStackPtrLimit;
#else
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 1002ce4:	f383 880a 	msr	MSPLIM, r3
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 1002ce8:	682a      	ldr	r2, [r5, #0]
 1002cea:	f382 8808 	msr	MSP, r2
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 1002cee:	f383 8809 	msr	PSP, r3
	/* Set MSP to the new address and clear any information from PSP */
	__set_MSP(vector_table[0]);
	__set_PSP(0);

	/* Call reset handler. */
	((void (*)(void))vector_table[1])();
 1002cf2:	686b      	ldr	r3, [r5, #4]
 1002cf4:	4798      	blx	r3
	CODE_UNREACHABLE;
}
 1002cf6:	bd38      	pop	{r3, r4, r5, pc}
 1002cf8:	01004ce5 	.word	0x01004ce5
 1002cfc:	41005000 	.word	0x41005000
 1002d00:	e000e100 	.word	0xe000e100

01002d04 <fw_info_check>:
{
 1002d04:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 1002d06:	4604      	mov	r4, r0
	const uint32_t fw_info_magic[] = {FIRMWARE_INFO_MAGIC};
 1002d08:	4a07      	ldr	r2, [pc, #28]	; (1002d28 <fw_info_check+0x24>)
 1002d0a:	ab01      	add	r3, sp, #4
 1002d0c:	ca07      	ldmia	r2, {r0, r1, r2}
 1002d0e:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	if (memcmp(finfo->magic, fw_info_magic, CONFIG_FW_INFO_MAGIC_LEN)
 1002d12:	220c      	movs	r2, #12
 1002d14:	4619      	mov	r1, r3
 1002d16:	4620      	mov	r0, r4
 1002d18:	f000 fff1 	bl	1003cfe <memcmp>
	return NULL;
 1002d1c:	2800      	cmp	r0, #0
}
 1002d1e:	bf0c      	ite	eq
 1002d20:	4620      	moveq	r0, r4
 1002d22:	2000      	movne	r0, #0
 1002d24:	b004      	add	sp, #16
 1002d26:	bd10      	pop	{r4, pc}
 1002d28:	0100421c 	.word	0x0100421c

01002d2c <fw_info_find>:
{
 1002d2c:	b570      	push	{r4, r5, r6, lr}
 1002d2e:	4605      	mov	r5, r0
	for (uint32_t i = 0; i < FW_INFO_OFFSET_COUNT; i++) {
 1002d30:	2400      	movs	r4, #0
 1002d32:	4e05      	ldr	r6, [pc, #20]	; (1002d48 <fw_info_find+0x1c>)
						fw_info_allowed_offsets[i]);
 1002d34:	f856 0b04 	ldr.w	r0, [r6], #4
		finfo = fw_info_check(firmware_address +
 1002d38:	4428      	add	r0, r5
 1002d3a:	f7ff ffe3 	bl	1002d04 <fw_info_check>
		if (finfo) {
 1002d3e:	b910      	cbnz	r0, 1002d46 <fw_info_find+0x1a>
	for (uint32_t i = 0; i < FW_INFO_OFFSET_COUNT; i++) {
 1002d40:	3401      	adds	r4, #1
 1002d42:	2c05      	cmp	r4, #5
 1002d44:	d1f6      	bne.n	1002d34 <fw_info_find+0x8>
}
 1002d46:	bd70      	pop	{r4, r5, r6, pc}
 1002d48:	010042c8 	.word	0x010042c8

01002d4c <validate_firmware>:
#endif


static bool validate_firmware(uint32_t fw_dst_address, uint32_t fw_src_address,
			      const struct fw_info *fwinfo, bool external)
{
 1002d4c:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 1002d50:	4680      	mov	r8, r0
	if (!fwinfo) {
		PRINT("NULL parameter.\n\r");
		return false;
	}

	if (!fw_info_check((uint32_t)fwinfo)) {
 1002d52:	4610      	mov	r0, r2
{
 1002d54:	460e      	mov	r6, r1
 1002d56:	4615      	mov	r5, r2
 1002d58:	461c      	mov	r4, r3
	const uint32_t fwinfo_end = (fwinfo_address + fwinfo->total_size);
 1002d5a:	f8d2 900c 	ldr.w	r9, [r2, #12]
	const uint32_t fw_dst_end = (fw_dst_address + fwinfo->size);
 1002d5e:	6917      	ldr	r7, [r2, #16]
	if (!fw_info_check((uint32_t)fwinfo)) {
 1002d60:	f7ff ffd0 	bl	1002d04 <fw_info_check>
 1002d64:	b948      	cbnz	r0, 1002d7a <validate_firmware+0x2e>
		PRINT("Invalid firmware info format.\n\r");
 1002d66:	b124      	cbz	r4, 1002d72 <validate_firmware+0x26>
		return false;
 1002d68:	2400      	movs	r4, #0
	return validate_hash(fw_src_address, fwinfo->size, fw_val_info,
				external);
#else
	#error "Validation not specified."
#endif
}
 1002d6a:	4620      	mov	r0, r4
 1002d6c:	b004      	add	sp, #16
 1002d6e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		PRINT("Invalid firmware info format.\n\r");
 1002d72:	4852      	ldr	r0, [pc, #328]	; (1002ebc <validate_firmware+0x170>)
		PRINT("The firmware doesn't belong at destination addr.\n\r");
 1002d74:	f000 fe6d 	bl	1003a52 <printk>
 1002d78:	e7f7      	b.n	1002d6a <validate_firmware+0x1e>
	if (fw_dst_address != fwinfo->address) {
 1002d7a:	69ab      	ldr	r3, [r5, #24]
 1002d7c:	4543      	cmp	r3, r8
 1002d7e:	d003      	beq.n	1002d88 <validate_firmware+0x3c>
		PRINT("The firmware doesn't belong at destination addr.\n\r");
 1002d80:	2c00      	cmp	r4, #0
 1002d82:	d1f1      	bne.n	1002d68 <validate_firmware+0x1c>
 1002d84:	484e      	ldr	r0, [pc, #312]	; (1002ec0 <validate_firmware+0x174>)
 1002d86:	e7f5      	b.n	1002d74 <validate_firmware+0x28>
	if (!external && (fw_src_address != fw_dst_address)) {
 1002d88:	b91c      	cbnz	r4, 1002d92 <validate_firmware+0x46>
 1002d8a:	42b3      	cmp	r3, r6
 1002d8c:	d001      	beq.n	1002d92 <validate_firmware+0x46>
		PRINT("src and dst must be equal for local calls.\n\r");
 1002d8e:	484d      	ldr	r0, [pc, #308]	; (1002ec4 <validate_firmware+0x178>)
 1002d90:	e7f0      	b.n	1002d74 <validate_firmware+0x28>
	if (fw_info_find(fw_src_address) != fwinfo) {
 1002d92:	4630      	mov	r0, r6
 1002d94:	f7ff ffca 	bl	1002d2c <fw_info_find>
 1002d98:	4285      	cmp	r5, r0
 1002d9a:	d003      	beq.n	1002da4 <validate_firmware+0x58>
		PRINT("Firmware info doesn't point to itself.\n\r");
 1002d9c:	2c00      	cmp	r4, #0
 1002d9e:	d1e3      	bne.n	1002d68 <validate_firmware+0x1c>
 1002da0:	4849      	ldr	r0, [pc, #292]	; (1002ec8 <validate_firmware+0x17c>)
 1002da2:	e7e7      	b.n	1002d74 <validate_firmware+0x28>
	if (fwinfo->valid != CONFIG_FW_INFO_VALID_VAL) {
 1002da4:	6a29      	ldr	r1, [r5, #32]
 1002da6:	4b49      	ldr	r3, [pc, #292]	; (1002ecc <validate_firmware+0x180>)
 1002da8:	4299      	cmp	r1, r3
 1002daa:	d005      	beq.n	1002db8 <validate_firmware+0x6c>
		PRINT("Firwmare has been invalidated: 0x%x.\n\r",
 1002dac:	2c00      	cmp	r4, #0
 1002dae:	d1db      	bne.n	1002d68 <validate_firmware+0x1c>
 1002db0:	4847      	ldr	r0, [pc, #284]	; (1002ed0 <validate_firmware+0x184>)
		PRINT("Firmware validation failed with error %d.\n\r",
 1002db2:	f000 fe4e 	bl	1003a52 <printk>
 1002db6:	e7d8      	b.n	1002d6a <validate_firmware+0x1e>
	if (fwinfo->version < get_monotonic_version(NULL)) {
 1002db8:	f8d5 a014 	ldr.w	sl, [r5, #20]
	uint16_t monotonic_version = get_monotonic_counter();
 1002dbc:	f001 f913 	bl	1003fe6 <get_monotonic_counter>
	if (fwinfo->version < get_monotonic_version(NULL)) {
 1002dc0:	f3c0 004f 	ubfx	r0, r0, #1, #16
 1002dc4:	4582      	cmp	sl, r0
 1002dc6:	d20b      	bcs.n	1002de0 <validate_firmware+0x94>
		PRINT("Firmware version (%u) is smaller than monotonic counter (%u).\n\r",
 1002dc8:	2c00      	cmp	r4, #0
 1002dca:	d1cd      	bne.n	1002d68 <validate_firmware+0x1c>
 1002dcc:	696d      	ldr	r5, [r5, #20]
	uint16_t monotonic_version = get_monotonic_counter();
 1002dce:	f001 f90a 	bl	1003fe6 <get_monotonic_counter>
		PRINT("Firmware version (%u) is smaller than monotonic counter (%u).\n\r",
 1002dd2:	4629      	mov	r1, r5
 1002dd4:	f3c0 024f 	ubfx	r2, r0, #1, #16
 1002dd8:	483e      	ldr	r0, [pc, #248]	; (1002ed4 <validate_firmware+0x188>)
 1002dda:	f000 fe3a 	bl	1003a52 <printk>
 1002dde:	e7c4      	b.n	1002d6a <validate_firmware+0x1e>
 1002de0:	eb15 0909 	adds.w	r9, r5, r9
 1002de4:	d215      	bcs.n	1002e12 <validate_firmware+0xc6>
 1002de6:	19bb      	adds	r3, r7, r6
 1002de8:	d213      	bcs.n	1002e12 <validate_firmware+0xc6>
static bool within(uint32_t addr, uint32_t start, uint32_t end)
{
	if (start > end) {
		return false;
	}
	if (addr < start) {
 1002dea:	42b5      	cmp	r5, r6
 1002dec:	d311      	bcc.n	1002e12 <validate_firmware+0xc6>
		return false;
	}
	if (addr >= end) {
 1002dee:	429d      	cmp	r5, r3
 1002df0:	d20f      	bcs.n	1002e12 <validate_firmware+0xc6>
		return false;
	}
	if (!within(inner_start, start, end)) {
		return false;
	}
	if (!within(inner_end - 1, start, end)) {
 1002df2:	f109 39ff 	add.w	r9, r9, #4294967295
	if (addr < start) {
 1002df6:	454e      	cmp	r6, r9
 1002df8:	d80b      	bhi.n	1002e12 <validate_firmware+0xc6>
	if (addr >= end) {
 1002dfa:	454b      	cmp	r3, r9
 1002dfc:	d909      	bls.n	1002e12 <validate_firmware+0xc6>
 1002dfe:	eb17 0708 	adds.w	r7, r7, r8
 1002e02:	d202      	bcs.n	1002e0a <validate_firmware+0xbe>
	if (!within(fwinfo->boot_address, fw_dst_address, fw_dst_end)) {
 1002e04:	69eb      	ldr	r3, [r5, #28]
	if (addr < start) {
 1002e06:	4543      	cmp	r3, r8
 1002e08:	d207      	bcs.n	1002e1a <validate_firmware+0xce>
		PRINT("Boot address is not within signed region.\n\r");
 1002e0a:	2c00      	cmp	r4, #0
 1002e0c:	d1ac      	bne.n	1002d68 <validate_firmware+0x1c>
 1002e0e:	4832      	ldr	r0, [pc, #200]	; (1002ed8 <validate_firmware+0x18c>)
 1002e10:	e7b0      	b.n	1002d74 <validate_firmware+0x28>
		PRINT("Firmware info is not within signed region.\n\r");
 1002e12:	2c00      	cmp	r4, #0
 1002e14:	d1a8      	bne.n	1002d68 <validate_firmware+0x1c>
 1002e16:	4831      	ldr	r0, [pc, #196]	; (1002edc <validate_firmware+0x190>)
 1002e18:	e7ac      	b.n	1002d74 <validate_firmware+0x28>
	if (addr >= end) {
 1002e1a:	42bb      	cmp	r3, r7
 1002e1c:	d2f5      	bcs.n	1002e0a <validate_firmware+0xbe>
	const uint32_t reset_vector = ((const uint32_t *)(fw_src_address + stack_ptr_offset))[1];
 1002e1e:	1d32      	adds	r2, r6, #4
 1002e20:	eba2 0208 	sub.w	r2, r2, r8
 1002e24:	58d3      	ldr	r3, [r2, r3]
	if (addr < start) {
 1002e26:	4598      	cmp	r8, r3
 1002e28:	d903      	bls.n	1002e32 <validate_firmware+0xe6>
		PRINT("Reset handler is not within signed region.\n\r");
 1002e2a:	2c00      	cmp	r4, #0
 1002e2c:	d19c      	bne.n	1002d68 <validate_firmware+0x1c>
 1002e2e:	482c      	ldr	r0, [pc, #176]	; (1002ee0 <validate_firmware+0x194>)
 1002e30:	e7a0      	b.n	1002d74 <validate_firmware+0x28>
	if (addr >= end) {
 1002e32:	429f      	cmp	r7, r3
 1002e34:	d9f9      	bls.n	1002e2a <validate_firmware+0xde>
	fw_val_info = validation_info_find(fw_src_address + fwinfo->size, 4);
 1002e36:	692f      	ldr	r7, [r5, #16]
	const uint32_t validation_info_magic[] = {VALIDATION_INFO_MAGIC};
 1002e38:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 1002ee4 <validate_firmware+0x198>
	fw_val_info = validation_info_find(fw_src_address + fwinfo->size, 4);
 1002e3c:	4437      	add	r7, r6
validation_info_find(uint32_t start_address, uint32_t search_distance)
 1002e3e:	f107 0a05 	add.w	sl, r7, #5
	const uint32_t validation_info_magic[] = {VALIDATION_INFO_MAGIC};
 1002e42:	f10d 0804 	add.w	r8, sp, #4
	for (int i = 0; i <= search_distance; i++) {
 1002e46:	4557      	cmp	r7, sl
 1002e48:	d103      	bne.n	1002e52 <validate_firmware+0x106>
		PRINT("Could not find valid firmware validation info.\n\r");
 1002e4a:	2c00      	cmp	r4, #0
 1002e4c:	d18c      	bne.n	1002d68 <validate_firmware+0x1c>
 1002e4e:	4826      	ldr	r0, [pc, #152]	; (1002ee8 <validate_firmware+0x19c>)
 1002e50:	e790      	b.n	1002d74 <validate_firmware+0x28>
	const uint32_t validation_info_magic[] = {VALIDATION_INFO_MAGIC};
 1002e52:	e899 0007 	ldmia.w	r9, {r0, r1, r2}
 1002e56:	e888 0007 	stmia.w	r8, {r0, r1, r2}
	if (memcmp(vinfo->magic, validation_info_magic,
 1002e5a:	220c      	movs	r2, #12
 1002e5c:	4641      	mov	r1, r8
 1002e5e:	4638      	mov	r0, r7
 1002e60:	f000 ff4d 	bl	1003cfe <memcmp>
 1002e64:	b900      	cbnz	r0, 1002e68 <validate_firmware+0x11c>
		if (validation_info_check(vinfo)) {
 1002e66:	b90f      	cbnz	r7, 1002e6c <validate_firmware+0x120>
	for (int i = 0; i <= search_distance; i++) {
 1002e68:	3701      	adds	r7, #1
 1002e6a:	e7ec      	b.n	1002e46 <validate_firmware+0xfa>
	if (fw_val_info->address != fwinfo->address) {
 1002e6c:	68fa      	ldr	r2, [r7, #12]
 1002e6e:	69ab      	ldr	r3, [r5, #24]
 1002e70:	429a      	cmp	r2, r3
 1002e72:	d004      	beq.n	1002e7e <validate_firmware+0x132>
		PRINT("Validation info doesn't belong to this firmware.\n\r");
 1002e74:	2c00      	cmp	r4, #0
 1002e76:	f47f af77 	bne.w	1002d68 <validate_firmware+0x1c>
 1002e7a:	481c      	ldr	r0, [pc, #112]	; (1002eec <validate_firmware+0x1a0>)
 1002e7c:	e77a      	b.n	1002d74 <validate_firmware+0x28>
	return validate_hash(fw_src_address, fwinfo->size, fw_val_info,
 1002e7e:	692d      	ldr	r5, [r5, #16]
	int retval = bl_crypto_init();
 1002e80:	f001 f843 	bl	1003f0a <bl_crypto_init>
	if (retval) {
 1002e84:	4601      	mov	r1, r0
 1002e86:	b120      	cbz	r0, 1002e92 <validate_firmware+0x146>
		PRINT("bl_crypto_init() returned %d.\n\r", retval);
 1002e88:	2c00      	cmp	r4, #0
 1002e8a:	f47f af6d 	bne.w	1002d68 <validate_firmware+0x1c>
 1002e8e:	4818      	ldr	r0, [pc, #96]	; (1002ef0 <validate_firmware+0x1a4>)
 1002e90:	e78f      	b.n	1002db2 <validate_firmware+0x66>
	retval = bl_sha256_verify((const uint8_t *)fw_src_address, fw_size,
 1002e92:	4629      	mov	r1, r5
 1002e94:	4630      	mov	r0, r6
 1002e96:	f107 0210 	add.w	r2, r7, #16
 1002e9a:	f001 f83d 	bl	1003f18 <bl_sha256_verify>
	if (retval != 0) {
 1002e9e:	4601      	mov	r1, r0
 1002ea0:	b120      	cbz	r0, 1002eac <validate_firmware+0x160>
		PRINT("Firmware validation failed with error %d.\n\r",
 1002ea2:	2c00      	cmp	r4, #0
 1002ea4:	f47f af60 	bne.w	1002d68 <validate_firmware+0x1c>
 1002ea8:	4812      	ldr	r0, [pc, #72]	; (1002ef4 <validate_firmware+0x1a8>)
 1002eaa:	e782      	b.n	1002db2 <validate_firmware+0x66>
	PRINT("Firmware hash verified.\n\r");
 1002eac:	2c00      	cmp	r4, #0
 1002eae:	f47f af5c 	bne.w	1002d6a <validate_firmware+0x1e>
 1002eb2:	4811      	ldr	r0, [pc, #68]	; (1002ef8 <validate_firmware+0x1ac>)
 1002eb4:	f000 fdcd 	bl	1003a52 <printk>
	return true;
 1002eb8:	2401      	movs	r4, #1
 1002eba:	e756      	b.n	1002d6a <validate_firmware+0x1e>
 1002ebc:	01004cf7 	.word	0x01004cf7
 1002ec0:	01004d17 	.word	0x01004d17
 1002ec4:	01004d4a 	.word	0x01004d4a
 1002ec8:	01004d77 	.word	0x01004d77
 1002ecc:	9102ffff 	.word	0x9102ffff
 1002ed0:	01004da0 	.word	0x01004da0
 1002ed4:	01004dc7 	.word	0x01004dc7
 1002ed8:	01004e34 	.word	0x01004e34
 1002edc:	01004e07 	.word	0x01004e07
 1002ee0:	01004e60 	.word	0x01004e60
 1002ee4:	01004228 	.word	0x01004228
 1002ee8:	01004e8d 	.word	0x01004e8d
 1002eec:	01004ebe 	.word	0x01004ebe
 1002ef0:	01004ef1 	.word	0x01004ef1
 1002ef4:	01004f11 	.word	0x01004f11
 1002ef8:	01004f3d 	.word	0x01004f3d

01002efc <s0_address_read>:
static const struct bl_storage_data *p_bl_storage_data =
	(struct bl_storage_data *)PM_PROVISION_ADDRESS;

uint32_t s0_address_read(void)
{
	uint32_t addr = p_bl_storage_data->s0_address;
 1002efc:	4b02      	ldr	r3, [pc, #8]	; (1002f08 <s0_address_read+0xc>)
 1002efe:	6818      	ldr	r0, [r3, #0]
  __ASM volatile ("dsb 0xF":::"memory");
 1002f00:	f3bf 8f4f 	dsb	sy

	__DSB(); /* Because of nRF9160 Erratum 7 */
	return addr;
}
 1002f04:	4770      	bx	lr
 1002f06:	bf00      	nop
 1002f08:	01008600 	.word	0x01008600

01002f0c <num_public_keys_read>:
	return addr;
}

uint32_t num_public_keys_read(void)
{
	uint32_t num_pk = p_bl_storage_data->num_public_keys;
 1002f0c:	4b02      	ldr	r3, [pc, #8]	; (1002f18 <num_public_keys_read+0xc>)
 1002f0e:	6898      	ldr	r0, [r3, #8]
 1002f10:	f3bf 8f4f 	dsb	sy

	__DSB(); /* Because of nRF9160 Erratum 7 */
	return num_pk;
}
 1002f14:	4770      	bx	lr
 1002f16:	bf00      	nop
 1002f18:	01008600 	.word	0x01008600

01002f1c <get_counter_struct.constprop.0>:

/** Get one of the (possibly multiple) counters in the provision data.
 *
 *  param[in]  description  Which counter to get. See COUNTER_DESC_*.
 */
static const struct monotonic_counter *get_counter_struct(uint16_t description)
 1002f1c:	b570      	push	{r4, r5, r6, lr}
		&p_bl_storage_data->key_data[num_public_keys_read()];
 1002f1e:	f7ff fff5 	bl	1002f0c <num_public_keys_read>
	struct counter_collection *collection = (struct counter_collection *)
 1002f22:	2314      	movs	r3, #20
 1002f24:	4358      	muls	r0, r3
 1002f26:	4910      	ldr	r1, [pc, #64]	; (1002f68 <get_counter_struct.constprop.0+0x4c>)
 1002f28:	4401      	add	r1, r0
	return read_halfword(&collection->type) == TYPE_COUNTERS
 1002f2a:	4608      	mov	r0, r1
 1002f2c:	f001 f81e 	bl	1003f6c <read_halfword>
		? collection : NULL;
 1002f30:	2801      	cmp	r0, #1
 1002f32:	d002      	beq.n	1002f3a <get_counter_struct.constprop.0+0x1e>
{
	const struct counter_collection *counters = get_counter_collection();

	if (counters == NULL) {
		return NULL;
 1002f34:	2400      	movs	r4, #0

		current = (const struct monotonic_counter *)
					&current->counter_slots[num_slots];
	}
	return NULL;
}
 1002f36:	4620      	mov	r0, r4
 1002f38:	bd70      	pop	{r4, r5, r6, pc}
	for (size_t i = 0; i < read_halfword(&counters->num_counters); i++) {
 1002f3a:	2600      	movs	r6, #0
	const struct monotonic_counter *current = counters->counters;
 1002f3c:	1d0c      	adds	r4, r1, #4
	for (size_t i = 0; i < read_halfword(&counters->num_counters); i++) {
 1002f3e:	3102      	adds	r1, #2
 1002f40:	4608      	mov	r0, r1
 1002f42:	f001 f813 	bl	1003f6c <read_halfword>
 1002f46:	4286      	cmp	r6, r0
 1002f48:	d2f4      	bcs.n	1002f34 <get_counter_struct.constprop.0+0x18>
		uint16_t num_slots = read_halfword(&current->num_counter_slots);
 1002f4a:	1ca0      	adds	r0, r4, #2
 1002f4c:	f001 f80e 	bl	1003f6c <read_halfword>
 1002f50:	4605      	mov	r5, r0
		if (read_halfword(&current->description) == description) {
 1002f52:	4620      	mov	r0, r4
 1002f54:	f001 f80a 	bl	1003f6c <read_halfword>
 1002f58:	2801      	cmp	r0, #1
 1002f5a:	d0ec      	beq.n	1002f36 <get_counter_struct.constprop.0+0x1a>
		current = (const struct monotonic_counter *)
 1002f5c:	3502      	adds	r5, #2
 1002f5e:	eb04 0445 	add.w	r4, r4, r5, lsl #1
	for (size_t i = 0; i < read_halfword(&counters->num_counters); i++) {
 1002f62:	3601      	adds	r6, #1
 1002f64:	e7ec      	b.n	1002f40 <get_counter_struct.constprop.0+0x24>
 1002f66:	bf00      	nop
 1002f68:	0100860c 	.word	0x0100860c

01002f6c <pcd_fw_copy_invalidate>:

static struct pcd_cmd *cmd = (struct pcd_cmd *)PCD_CMD_ADDRESS;

void pcd_fw_copy_invalidate(void)
{
	cmd->magic = PCD_CMD_MAGIC_FAIL;
 1002f6c:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 1002f70:	4a01      	ldr	r2, [pc, #4]	; (1002f78 <pcd_fw_copy_invalidate+0xc>)
 1002f72:	601a      	str	r2, [r3, #0]
}
 1002f74:	4770      	bx	lr
 1002f76:	bf00      	nop
 1002f78:	25bafc15 	.word	0x25bafc15

01002f7c <pcd_fw_copy_status_get>:

enum pcd_status pcd_fw_copy_status_get(void)
{
	if (cmd->magic == PCD_CMD_MAGIC_COPY) {
 1002f7c:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 1002f80:	6818      	ldr	r0, [r3, #0]
 1002f82:	4b05      	ldr	r3, [pc, #20]	; (1002f98 <pcd_fw_copy_status_get+0x1c>)
 1002f84:	4298      	cmp	r0, r3
 1002f86:	d005      	beq.n	1002f94 <pcd_fw_copy_status_get+0x18>
		return PCD_STATUS_COPY;
	} else if (cmd->magic == PCD_CMD_MAGIC_DONE) {
		return PCD_STATUS_COPY_DONE;
 1002f88:	4b04      	ldr	r3, [pc, #16]	; (1002f9c <pcd_fw_copy_status_get+0x20>)
 1002f8a:	4298      	cmp	r0, r3
 1002f8c:	bf14      	ite	ne
 1002f8e:	2002      	movne	r0, #2
 1002f90:	2001      	moveq	r0, #1
 1002f92:	4770      	bx	lr
		return PCD_STATUS_COPY;
 1002f94:	2000      	movs	r0, #0
	}

	return PCD_STATUS_COPY_FAILED;
}
 1002f96:	4770      	bx	lr
 1002f98:	b5b4b3b6 	.word	0xb5b4b3b6
 1002f9c:	f103ce5d 	.word	0xf103ce5d

01002fa0 <pcd_fw_copy>:
}

#ifdef CONFIG_PCD_NET

int pcd_fw_copy(const struct device *fdev)
{
 1002fa0:	b530      	push	{r4, r5, lr}
	struct stream_flash_ctx stream;
	uint8_t buf[CONFIG_PCD_BUF_SIZE];
	int rc;

	if (cmd->magic != PCD_CMD_MAGIC_COPY) {
 1002fa2:	f04f 5500 	mov.w	r5, #536870912	; 0x20000000
 1002fa6:	4b18      	ldr	r3, [pc, #96]	; (1003008 <pcd_fw_copy+0x68>)
 1002fa8:	682a      	ldr	r2, [r5, #0]
{
 1002faa:	4601      	mov	r1, r0
	if (cmd->magic != PCD_CMD_MAGIC_COPY) {
 1002fac:	429a      	cmp	r2, r3
{
 1002fae:	f5ad 7d0f 	sub.w	sp, sp, #572	; 0x23c
	if (cmd->magic != PCD_CMD_MAGIC_COPY) {
 1002fb2:	d126      	bne.n	1003002 <pcd_fw_copy+0x62>
		return -EFAULT;
	}

	rc = stream_flash_init(&stream, fdev, buf, sizeof(buf),
 1002fb4:	2300      	movs	r3, #0
 1002fb6:	e9cd 3301 	strd	r3, r3, [sp, #4]
 1002fba:	68eb      	ldr	r3, [r5, #12]
 1002fbc:	aa0e      	add	r2, sp, #56	; 0x38
 1002fbe:	9300      	str	r3, [sp, #0]
 1002fc0:	a805      	add	r0, sp, #20
 1002fc2:	f44f 7300 	mov.w	r3, #512	; 0x200
 1002fc6:	f7fe fd0d 	bl	10019e4 <stream_flash_init>
			       cmd->offset, 0, NULL);
	if (rc != 0) {
 1002fca:	4604      	mov	r4, r0
 1002fcc:	b140      	cbz	r0, 1002fe0 <pcd_fw_copy+0x40>
		LOG_ERR("stream_flash_init failed: %d", rc);
 1002fce:	2145      	movs	r1, #69	; 0x45
 1002fd0:	4602      	mov	r2, r0
 1002fd2:	480e      	ldr	r0, [pc, #56]	; (100300c <pcd_fw_copy+0x6c>)
	}

	rc = stream_flash_buffered_write(&stream, (uint8_t *)cmd->data,
					 cmd->len, true);
	if (rc != 0) {
		LOG_ERR("stream_flash_buffered_write fail: %d", rc);
 1002fd4:	f000 fe1d 	bl	1003c12 <z_log_minimal_printk>
	}

	LOG_INF("Transfer done");

	return 0;
}
 1002fd8:	4620      	mov	r0, r4
 1002fda:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
 1002fde:	bd30      	pop	{r4, r5, pc}
	rc = stream_flash_buffered_write(&stream, (uint8_t *)cmd->data,
 1002fe0:	2301      	movs	r3, #1
 1002fe2:	e9d5 1201 	ldrd	r1, r2, [r5, #4]
 1002fe6:	a805      	add	r0, sp, #20
 1002fe8:	f000 fe26 	bl	1003c38 <stream_flash_buffered_write>
	if (rc != 0) {
 1002fec:	4604      	mov	r4, r0
 1002fee:	b118      	cbz	r0, 1002ff8 <pcd_fw_copy+0x58>
		LOG_ERR("stream_flash_buffered_write fail: %d", rc);
 1002ff0:	4602      	mov	r2, r0
 1002ff2:	2145      	movs	r1, #69	; 0x45
 1002ff4:	4806      	ldr	r0, [pc, #24]	; (1003010 <pcd_fw_copy+0x70>)
 1002ff6:	e7ed      	b.n	1002fd4 <pcd_fw_copy+0x34>
	LOG_INF("Transfer done");
 1002ff8:	2149      	movs	r1, #73	; 0x49
 1002ffa:	4806      	ldr	r0, [pc, #24]	; (1003014 <pcd_fw_copy+0x74>)
 1002ffc:	f000 fe09 	bl	1003c12 <z_log_minimal_printk>
	return 0;
 1003000:	e7ea      	b.n	1002fd8 <pcd_fw_copy+0x38>
		return -EFAULT;
 1003002:	f06f 040d 	mvn.w	r4, #13
 1003006:	e7e7      	b.n	1002fd8 <pcd_fw_copy+0x38>
 1003008:	b5b4b3b6 	.word	0xb5b4b3b6
 100300c:	01004f57 	.word	0x01004f57
 1003010:	01004f79 	.word	0x01004f79
 1003014:	01004fa3 	.word	0x01004fa3

01003018 <pcd_fw_copy_done>:

void pcd_fw_copy_done(void)
{
	/* Signal complete by setting magic to DONE */
	cmd->magic = PCD_CMD_MAGIC_DONE;
 1003018:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 100301c:	4a01      	ldr	r2, [pc, #4]	; (1003024 <pcd_fw_copy_done+0xc>)
 100301e:	601a      	str	r2, [r3, #0]
}
 1003020:	4770      	bx	lr
 1003022:	bf00      	nop
 1003024:	f103ce5d 	.word	0xf103ce5d

01003028 <check_ext_api_requests>:
	}
};
#endif

static int check_ext_api_requests(const struct device *dev)
{
 1003028:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	(void)dev;

	const struct fw_info_ext_api_request *ext_api_req =
			skip_ext_apis(&m_firmware_info);
 100302c:	4823      	ldr	r0, [pc, #140]	; (10030bc <check_ext_api_requests+0x94>)
{
 100302e:	b085      	sub	sp, #20
			skip_ext_apis(&m_firmware_info);
 1003030:	f000 ffe0 	bl	1003ff4 <skip_ext_apis>

	for (uint32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
 1003034:	2500      	movs	r5, #0
			skip_ext_apis(&m_firmware_info);
 1003036:	4604      	mov	r4, r0
	for (uint32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
 1003038:	4b20      	ldr	r3, [pc, #128]	; (10030bc <check_ext_api_requests+0x94>)
	const uint32_t ext_api_magic[] = {EXT_API_MAGIC};
 100303a:	4e21      	ldr	r6, [pc, #132]	; (10030c0 <check_ext_api_requests+0x98>)
 100303c:	f8d3 8038 	ldr.w	r8, [r3, #56]	; 0x38
			/* EXT_API hard requirement not met. */
			printk("ERROR: Cannot fulfill EXT_API request.\r\n");
			k_panic();
		} else {
			/* EXT_API soft requirement not met. */
			printk("WARNING: Optional EXT_API request not "
 1003040:	f8df 9080 	ldr.w	r9, [pc, #128]	; 10030c4 <check_ext_api_requests+0x9c>
	for (uint32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
 1003044:	45a8      	cmp	r8, r5
 1003046:	d803      	bhi.n	1003050 <check_ext_api_requests+0x28>
		}
		ADVANCE_EXT_API_REQ(ext_api_req);
	}

	return 0;
}
 1003048:	2000      	movs	r0, #0
 100304a:	b005      	add	sp, #20
 100304c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if (fw_info_ext_api_check((uint32_t)*(ext_api_req->ext_api))
 1003050:	6a63      	ldr	r3, [r4, #36]	; 0x24
 1003052:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
 1003056:	681f      	ldr	r7, [r3, #0]
 1003058:	ab01      	add	r3, sp, #4
 100305a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	if (memcmp(ext_api->magic, ext_api_magic, CONFIG_FW_INFO_MAGIC_LEN)
 100305e:	220c      	movs	r2, #12
 1003060:	4619      	mov	r1, r3
 1003062:	4638      	mov	r0, r7
 1003064:	f000 fe4b 	bl	1003cfe <memcmp>
 1003068:	b990      	cbnz	r0, 1003090 <check_ext_api_requests+0x68>
 100306a:	b18f      	cbz	r7, 1003090 <check_ext_api_requests+0x68>
			&& ext_api_satisfies_req(*(ext_api_req->ext_api),
 100306c:	6a63      	ldr	r3, [r4, #36]	; 0x24
	const uint32_t req_id = ext_api_req->request.ext_api_id;
 100306e:	6921      	ldr	r1, [r4, #16]
			&& ext_api_satisfies_req(*(ext_api_req->ext_api),
 1003070:	681b      	ldr	r3, [r3, #0]
	return ((ext_api->ext_api_id == req_id)
 1003072:	691a      	ldr	r2, [r3, #16]
		&& ((ext_api->ext_api_flags & req_flags) == req_flags));
 1003074:	4291      	cmp	r1, r2
 1003076:	d10b      	bne.n	1003090 <check_ext_api_requests+0x68>
		&&  (ext_api->ext_api_version >= req_min_version)
 1003078:	699a      	ldr	r2, [r3, #24]
	const uint32_t req_min_version = ext_api_req->request.ext_api_version;
 100307a:	69a1      	ldr	r1, [r4, #24]
		&&  (ext_api->ext_api_version >= req_min_version)
 100307c:	4291      	cmp	r1, r2
 100307e:	d807      	bhi.n	1003090 <check_ext_api_requests+0x68>
	const uint32_t req_max_version = ext_api_req->ext_api_max_version;
 1003080:	69e1      	ldr	r1, [r4, #28]
		&&  (ext_api->ext_api_version <  req_max_version)
 1003082:	4291      	cmp	r1, r2
 1003084:	d904      	bls.n	1003090 <check_ext_api_requests+0x68>
	const uint32_t req_flags = ext_api_req->request.ext_api_flags;
 1003086:	6962      	ldr	r2, [r4, #20]
		&& ((ext_api->ext_api_flags & req_flags) == req_flags));
 1003088:	695b      	ldr	r3, [r3, #20]
 100308a:	ea32 0303 	bics.w	r3, r2, r3
 100308e:	d00a      	beq.n	10030a6 <check_ext_api_requests+0x7e>
		} else if (ext_api_req->required) {
 1003090:	6a27      	ldr	r7, [r4, #32]
 1003092:	b167      	cbz	r7, 10030ae <check_ext_api_requests+0x86>
			printk("ERROR: Cannot fulfill EXT_API request.\r\n");
 1003094:	480c      	ldr	r0, [pc, #48]	; (10030c8 <check_ext_api_requests+0xa0>)
 1003096:	f000 fcdc 	bl	1003a52 <printk>
			k_panic();
 100309a:	4040      	eors	r0, r0
 100309c:	f380 8811 	msr	BASEPRI, r0
 10030a0:	f04f 0004 	mov.w	r0, #4
 10030a4:	df02      	svc	2
		ADVANCE_EXT_API_REQ(ext_api_req);
 10030a6:	68e3      	ldr	r3, [r4, #12]
	for (uint32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
 10030a8:	3501      	adds	r5, #1
		ADVANCE_EXT_API_REQ(ext_api_req);
 10030aa:	441c      	add	r4, r3
	for (uint32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
 10030ac:	e7ca      	b.n	1003044 <check_ext_api_requests+0x1c>
			printk("WARNING: Optional EXT_API request not "
 10030ae:	4648      	mov	r0, r9
 10030b0:	f000 fccf 	bl	1003a52 <printk>
			*ext_api_req->ext_api = NULL;
 10030b4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 10030b6:	601f      	str	r7, [r3, #0]
 10030b8:	e7f5      	b.n	10030a6 <check_ext_api_requests+0x7e>
 10030ba:	bf00      	nop
 10030bc:	01000200 	.word	0x01000200
 10030c0:	01004234 	.word	0x01004234
 10030c4:	01004fe3 	.word	0x01004fe3
 10030c8:	01004fba 	.word	0x01004fba

010030cc <fw_info_ext_api_provide>:
{
 10030cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10030d0:	460f      	mov	r7, r1
	if (fw_info == NULL) {
 10030d2:	4606      	mov	r6, r0
{
 10030d4:	b089      	sub	sp, #36	; 0x24
	if (fw_info == NULL) {
 10030d6:	b918      	cbnz	r0, 10030e0 <fw_info_ext_api_provide+0x14>
		return false;
 10030d8:	2000      	movs	r0, #0
}
 10030da:	b009      	add	sp, #36	; 0x24
 10030dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				skip_ext_apis(fw_info);
 10030e0:	f000 ff88 	bl	1003ff4 <skip_ext_apis>
	for (uint32_t i = 0; i < fw_info->ext_api_request_num; i++) {
 10030e4:	f04f 0900 	mov.w	r9, #0
				skip_ext_apis(fw_info);
 10030e8:	4604      	mov	r4, r0
	for (uint32_t i = 0; i < fw_info->ext_api_request_num; i++) {
 10030ea:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 10030ec:	454b      	cmp	r3, r9
 10030ee:	d801      	bhi.n	10030f4 <fw_info_ext_api_provide+0x28>
	return true;
 10030f0:	2001      	movs	r0, #1
 10030f2:	e7f2      	b.n	10030da <fw_info_ext_api_provide+0xe>
	for (uint32_t i = 0; i < (uint32_t)_fw_info_images_size; i++) {
 10030f4:	f04f 0a00 	mov.w	sl, #0
 10030f8:	4b2a      	ldr	r3, [pc, #168]	; (10031a4 <fw_info_ext_api_provide+0xd8>)
 10030fa:	9301      	str	r3, [sp, #4]
	for (uint32_t i = 0; i < FW_INFO_OFFSET_COUNT; i++) {
 10030fc:	f04f 0b00 	mov.w	fp, #0
				fw_info_find(_fw_info_images_start[i]);
 1003100:	9b01      	ldr	r3, [sp, #4]
	const uint32_t fw_info_magic[] = {FIRMWARE_INFO_MAGIC};
 1003102:	f10d 0814 	add.w	r8, sp, #20
 1003106:	f853 2b04 	ldr.w	r2, [r3], #4
 100310a:	e9cd 3201 	strd	r3, r2, [sp, #4]
	for (uint32_t i = 0; i < FW_INFO_OFFSET_COUNT; i++) {
 100310e:	4b26      	ldr	r3, [pc, #152]	; (10031a8 <fw_info_ext_api_provide+0xdc>)
						fw_info_allowed_offsets[i]);
 1003110:	f853 5b04 	ldr.w	r5, [r3], #4
 1003114:	9303      	str	r3, [sp, #12]
		finfo = fw_info_check(firmware_address +
 1003116:	9b02      	ldr	r3, [sp, #8]
 1003118:	441d      	add	r5, r3
	const uint32_t fw_info_magic[] = {FIRMWARE_INFO_MAGIC};
 100311a:	4b24      	ldr	r3, [pc, #144]	; (10031ac <fw_info_ext_api_provide+0xe0>)
 100311c:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 1003120:	e888 0007 	stmia.w	r8, {r0, r1, r2}
	if (memcmp(finfo->magic, fw_info_magic, CONFIG_FW_INFO_MAGIC_LEN)
 1003124:	220c      	movs	r2, #12
 1003126:	4641      	mov	r1, r8
 1003128:	4628      	mov	r0, r5
 100312a:	f000 fde8 	bl	1003cfe <memcmp>
 100312e:	9b03      	ldr	r3, [sp, #12]
 1003130:	b900      	cbnz	r0, 1003134 <fw_info_ext_api_provide+0x68>
		if (finfo) {
 1003132:	b9ad      	cbnz	r5, 1003160 <fw_info_ext_api_provide+0x94>
	for (uint32_t i = 0; i < FW_INFO_OFFSET_COUNT; i++) {
 1003134:	f10b 0b01 	add.w	fp, fp, #1
 1003138:	f1bb 0f05 	cmp.w	fp, #5
 100313c:	d1e8      	bne.n	1003110 <fw_info_ext_api_provide+0x44>
	for (uint32_t i = 0; i < (uint32_t)_fw_info_images_size; i++) {
 100313e:	4b1c      	ldr	r3, [pc, #112]	; (10031b0 <fw_info_ext_api_provide+0xe4>)
 1003140:	f10a 0a01 	add.w	sl, sl, #1
 1003144:	459a      	cmp	sl, r3
 1003146:	d3d9      	bcc.n	10030fc <fw_info_ext_api_provide+0x30>
		if (provide) {
 1003148:	b11f      	cbz	r7, 1003152 <fw_info_ext_api_provide+0x86>
	return NULL;
 100314a:	2300      	movs	r3, #0
			*ext_api_req->ext_api = new_ext_api;
 100314c:	6a62      	ldr	r2, [r4, #36]	; 0x24
 100314e:	6013      	str	r3, [r2, #0]
		if (!new_ext_api && ext_api_req->required) {
 1003150:	bb13      	cbnz	r3, 1003198 <fw_info_ext_api_provide+0xcc>
 1003152:	6a23      	ldr	r3, [r4, #32]
 1003154:	b303      	cbz	r3, 1003198 <fw_info_ext_api_provide+0xcc>
 1003156:	e7bf      	b.n	10030d8 <fw_info_ext_api_provide+0xc>
			ADVANCE_EXT_API(ext_api);
 1003158:	68da      	ldr	r2, [r3, #12]
		for (uint32_t j = 0; j < fw_info->ext_api_num; j++) {
 100315a:	3001      	adds	r0, #1
			ADVANCE_EXT_API(ext_api);
 100315c:	4413      	add	r3, r2
		for (uint32_t j = 0; j < fw_info->ext_api_num; j++) {
 100315e:	e008      	b.n	1003172 <fw_info_ext_api_provide+0xa6>
		if (!fw_info || (fw_info->valid != CONFIG_FW_INFO_VALID_VAL)
 1003160:	6a2b      	ldr	r3, [r5, #32]
 1003162:	4a14      	ldr	r2, [pc, #80]	; (10031b4 <fw_info_ext_api_provide+0xe8>)
 1003164:	4293      	cmp	r3, r2
 1003166:	d1ea      	bne.n	100313e <fw_info_ext_api_provide+0x72>
		    || (fw_info == skip_fw_info)) {
 1003168:	42ae      	cmp	r6, r5
 100316a:	d0e8      	beq.n	100313e <fw_info_ext_api_provide+0x72>
		for (uint32_t j = 0; j < fw_info->ext_api_num; j++) {
 100316c:	6b69      	ldr	r1, [r5, #52]	; 0x34
		const struct fw_info_ext_api *ext_api = &fw_info->ext_apis[0];
 100316e:	f105 033c 	add.w	r3, r5, #60	; 0x3c
		for (uint32_t j = 0; j < fw_info->ext_api_num; j++) {
 1003172:	4288      	cmp	r0, r1
 1003174:	d0e3      	beq.n	100313e <fw_info_ext_api_provide+0x72>
	const uint32_t req_id = ext_api_req->request.ext_api_id;
 1003176:	6925      	ldr	r5, [r4, #16]
	return ((ext_api->ext_api_id == req_id)
 1003178:	691a      	ldr	r2, [r3, #16]
		&& ((ext_api->ext_api_flags & req_flags) == req_flags));
 100317a:	4295      	cmp	r5, r2
 100317c:	d1ec      	bne.n	1003158 <fw_info_ext_api_provide+0x8c>
		&&  (ext_api->ext_api_version >= req_min_version)
 100317e:	699a      	ldr	r2, [r3, #24]
	const uint32_t req_min_version = ext_api_req->request.ext_api_version;
 1003180:	69a5      	ldr	r5, [r4, #24]
		&&  (ext_api->ext_api_version >= req_min_version)
 1003182:	4295      	cmp	r5, r2
 1003184:	d8e8      	bhi.n	1003158 <fw_info_ext_api_provide+0x8c>
	const uint32_t req_max_version = ext_api_req->ext_api_max_version;
 1003186:	69e5      	ldr	r5, [r4, #28]
		&&  (ext_api->ext_api_version <  req_max_version)
 1003188:	4295      	cmp	r5, r2
 100318a:	d9e5      	bls.n	1003158 <fw_info_ext_api_provide+0x8c>
	const uint32_t req_flags = ext_api_req->request.ext_api_flags;
 100318c:	6962      	ldr	r2, [r4, #20]
		&& ((ext_api->ext_api_flags & req_flags) == req_flags));
 100318e:	695d      	ldr	r5, [r3, #20]
 1003190:	43aa      	bics	r2, r5
 1003192:	d1e1      	bne.n	1003158 <fw_info_ext_api_provide+0x8c>
		if (provide) {
 1003194:	2f00      	cmp	r7, #0
 1003196:	d1d9      	bne.n	100314c <fw_info_ext_api_provide+0x80>
		ADVANCE_EXT_API_REQ(ext_api_req);
 1003198:	68e3      	ldr	r3, [r4, #12]
	for (uint32_t i = 0; i < fw_info->ext_api_request_num; i++) {
 100319a:	f109 0901 	add.w	r9, r9, #1
		ADVANCE_EXT_API_REQ(ext_api_req);
 100319e:	441c      	add	r4, r3
	for (uint32_t i = 0; i < fw_info->ext_api_request_num; i++) {
 10031a0:	e7a3      	b.n	10030ea <fw_info_ext_api_provide+0x1e>
 10031a2:	bf00      	nop
 10031a4:	010051f0 	.word	0x010051f0
 10031a8:	010042dc 	.word	0x010042dc
 10031ac:	01004240 	.word	0x01004240
 10031b0:	00000001 	.word	0x00000001
 10031b4:	9102ffff 	.word	0x9102ffff

010031b8 <SystemInit>:
void SystemInit(void)
{
    /* Trimming of the device. Copy all the trimming values from FICR into the target addresses. Trim
     until one ADDR is not initialized. */
    uint32_t index = 0;
    for (index = 0; index < 32ul && NRF_FICR_NS->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
 10031b8:	2200      	movs	r2, #0
 10031ba:	00d3      	lsls	r3, r2, #3
 10031bc:	f103 73ff 	add.w	r3, r3, #33423360	; 0x1fe0000
 10031c0:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 10031c4:	f8d3 1300 	ldr.w	r1, [r3, #768]	; 0x300
 10031c8:	3101      	adds	r1, #1
 10031ca:	d007      	beq.n	10031dc <SystemInit+0x24>
        #if defined ( __ICCARM__ )
            /* IAR will complain about the order of volatile pointer accesses. */
            #pragma diag_suppress=Pa082
        #endif
        *((volatile uint32_t *)NRF_FICR_NS->TRIMCNF[index].ADDR) = NRF_FICR_NS->TRIMCNF[index].DATA;
 10031cc:	f8d3 1300 	ldr.w	r1, [r3, #768]	; 0x300
    for (index = 0; index < 32ul && NRF_FICR_NS->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
 10031d0:	3201      	adds	r2, #1
        *((volatile uint32_t *)NRF_FICR_NS->TRIMCNF[index].ADDR) = NRF_FICR_NS->TRIMCNF[index].DATA;
 10031d2:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
    for (index = 0; index < 32ul && NRF_FICR_NS->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
 10031d6:	2a20      	cmp	r2, #32
        *((volatile uint32_t *)NRF_FICR_NS->TRIMCNF[index].ADDR) = NRF_FICR_NS->TRIMCNF[index].DATA;
 10031d8:	600b      	str	r3, [r1, #0]
    for (index = 0; index < 32ul && NRF_FICR_NS->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
 10031da:	d1ee      	bne.n	10031ba <SystemInit+0x2>
                #else
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000130ul));
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000134ul));
                #endif
            #elif defined(NRF_NETWORK)
                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
 10031dc:	4b14      	ldr	r3, [pc, #80]	; (1003230 <SystemInit+0x78>)
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)\
             || defined (NRF_NETWORK)
                if (var1 == 0x07)
 10031de:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
 10031e2:	2a07      	cmp	r2, #7
 10031e4:	d11a      	bne.n	100321c <SystemInit+0x64>
                {
                    switch(var2)
 10031e6:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
 10031ea:	3b02      	subs	r3, #2
 10031ec:	2b03      	cmp	r3, #3
 10031ee:	d80c      	bhi.n	100320a <SystemInit+0x52>
        #endif
    }

    /* Workaround for Errata 49 "SLEEPENTER and SLEEPEXIT events asserted after pin reset" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (nrf53_errata_49())
 10031f0:	4a10      	ldr	r2, [pc, #64]	; (1003234 <SystemInit+0x7c>)
 10031f2:	5cd3      	ldrb	r3, [r2, r3]
 10031f4:	b14b      	cbz	r3, 100320a <SystemInit+0x52>
    {
        if (NRF_RESET_NS->RESETREAS & RESET_RESETREAS_RESETPIN_Msk)
 10031f6:	4b10      	ldr	r3, [pc, #64]	; (1003238 <SystemInit+0x80>)
 10031f8:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
 10031fc:	07d1      	lsls	r1, r2, #31
        {
            NRF_POWER_NS->EVENTS_SLEEPENTER = 0;
 10031fe:	bf42      	ittt	mi
 1003200:	2200      	movmi	r2, #0
 1003202:	f8c3 2114 	strmi.w	r2, [r3, #276]	; 0x114
            NRF_POWER_NS->EVENTS_SLEEPEXIT = 0;
 1003206:	f8c3 2118 	strmi.w	r2, [r3, #280]	; 0x118

    /* Workaround for Errata 55 "Bits in RESETREAS are set when they should not be" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (nrf53_errata_55())
    {
        if (NRF_RESET_NS->RESETREAS & RESET_RESETREAS_RESETPIN_Msk){
 100320a:	4b0b      	ldr	r3, [pc, #44]	; (1003238 <SystemInit+0x80>)
 100320c:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
 1003210:	07d2      	lsls	r2, r2, #31
            NRF_RESET_NS->RESETREAS = ~RESET_RESETREAS_RESETPIN_Msk;
 1003212:	bf44      	itt	mi
 1003214:	f06f 0201 	mvnmi.w	r2, #1
 1003218:	f8c3 2400 	strmi.w	r2, [r3, #1024]	; 0x400
                /* Do nothing, allow user code to handle APPROTECT. Use this if you want to enable authenticated debug. */

        #else
            /* Load APPROTECT soft branch from UICR.
               If UICR->APPROTECT is disabled, CTRLAP->APPROTECT will be disabled. */
            NRF_CTRLAP_NS->APPROTECT.DISABLE = NRF_UICR_NS->APPROTECT;
 100321c:	4b07      	ldr	r3, [pc, #28]	; (100323c <SystemInit+0x84>)
 100321e:	681a      	ldr	r2, [r3, #0]
 1003220:	4b07      	ldr	r3, [pc, #28]	; (1003240 <SystemInit+0x88>)
 1003222:	f8c3 2544 	str.w	r2, [r3, #1348]	; 0x544
    SystemCoreClock = __SYSTEM_CLOCK;
 1003226:	4b07      	ldr	r3, [pc, #28]	; (1003244 <SystemInit+0x8c>)
 1003228:	4a07      	ldr	r2, [pc, #28]	; (1003248 <SystemInit+0x90>)
 100322a:	601a      	str	r2, [r3, #0]

    /* Handle fw-branch APPROTECT setup. */
    nrf53_handle_approtect();

    SystemCoreClockUpdate();
}
 100322c:	4770      	bx	lr
 100322e:	bf00      	nop
 1003230:	01ff0000 	.word	0x01ff0000
 1003234:	01005016 	.word	0x01005016
 1003238:	41005000 	.word	0x41005000
 100323c:	01ff8000 	.word	0x01ff8000
 1003240:	41006000 	.word	0x41006000
 1003244:	21000004 	.word	0x21000004
 1003248:	03d09000 	.word	0x03d09000

0100324c <clock_stop>:
    CoreDebug->DEMCR = core_debug;
}
#endif // NRFX_CHECK(USE_WORKAROUND_FOR_ANOMALY_132)

static void clock_stop(nrf_clock_domain_t domain)
{
 100324c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    switch (domain)
 100324e:	4604      	mov	r4, r0
 1003250:	b168      	cbz	r0, 100326e <clock_stop+0x22>
 1003252:	2801      	cmp	r0, #1
 1003254:	d02e      	beq.n	10032b4 <clock_stop+0x68>
            nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED);
            nrf_clock_task_trigger(NRF_CLOCK, NRF_CLOCK_TASK_HFCLKAUDIOSTOP);
            break;
#endif
        default:
            NRFX_ASSERT(0);
 1003256:	492c      	ldr	r1, [pc, #176]	; (1003308 <clock_stop+0xbc>)
 1003258:	482c      	ldr	r0, [pc, #176]	; (100330c <clock_stop+0xc0>)
 100325a:	22d8      	movs	r2, #216	; 0xd8
 100325c:	f000 fccb 	bl	1003bf6 <assert_print>
 1003260:	21d8      	movs	r1, #216	; 0xd8
 1003262:	4829      	ldr	r0, [pc, #164]	; (1003308 <clock_stop+0xbc>)
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
 1003264:	b003      	add	sp, #12
 1003266:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
            NRFX_ASSERT(0);
 100326a:	f000 bcbd 	b.w	1003be8 <assert_post_action>
    p_reg->INTENCLR = mask;
 100326e:	2202      	movs	r2, #2
 1003270:	4b27      	ldr	r3, [pc, #156]	; (1003310 <clock_stop+0xc4>)
 1003272:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 1003276:	f8c3 0104 	str.w	r0, [r3, #260]	; 0x104
 100327a:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 100327e:	2201      	movs	r2, #1
 1003280:	60da      	str	r2, [r3, #12]
    nrf_clock_hfclk_t clk_src = NRF_CLOCK_HFCLK_HIGH_ACCURACY;
 1003282:	2301      	movs	r3, #1
    nrf_clock_hfclk_t *p_clk_src = (domain == NRF_CLOCK_DOMAIN_HFCLK) ? &clk_src : NULL;
 1003284:	429c      	cmp	r4, r3
 1003286:	bf18      	it	ne
 1003288:	2500      	movne	r5, #0
 100328a:	f242 7710 	movw	r7, #10000	; 0x2710
 100328e:	4e20      	ldr	r6, [pc, #128]	; (1003310 <clock_stop+0xc4>)
    nrf_clock_hfclk_t clk_src = NRF_CLOCK_HFCLK_HIGH_ACCURACY;
 1003290:	f88d 3007 	strb.w	r3, [sp, #7]
    nrf_clock_hfclk_t *p_clk_src = (domain == NRF_CLOCK_DOMAIN_HFCLK) ? &clk_src : NULL;
 1003294:	bf08      	it	eq
 1003296:	f10d 0507 	addeq.w	r5, sp, #7
    switch (domain)
 100329a:	b1ac      	cbz	r4, 10032c8 <clock_stop+0x7c>
 100329c:	2c01      	cmp	r4, #1
 100329e:	d029      	beq.n	10032f4 <clock_stop+0xa8>
            NRFX_ASSERT(0);
 10032a0:	491c      	ldr	r1, [pc, #112]	; (1003314 <clock_stop+0xc8>)
 10032a2:	481a      	ldr	r0, [pc, #104]	; (100330c <clock_stop+0xc0>)
 10032a4:	f44f 724f 	mov.w	r2, #828	; 0x33c
 10032a8:	f000 fca5 	bl	1003bf6 <assert_print>
 10032ac:	f44f 714f 	mov.w	r1, #828	; 0x33c
 10032b0:	4818      	ldr	r0, [pc, #96]	; (1003314 <clock_stop+0xc8>)
 10032b2:	e7d7      	b.n	1003264 <clock_stop+0x18>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 10032b4:	2200      	movs	r2, #0
    p_reg->INTENCLR = mask;
 10032b6:	4b16      	ldr	r3, [pc, #88]	; (1003310 <clock_stop+0xc4>)
 10032b8:	f8c3 0308 	str.w	r0, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 10032bc:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
 10032c0:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 10032c4:	6058      	str	r0, [r3, #4]
}
 10032c6:	e7dc      	b.n	1003282 <clock_stop+0x36>
            if (p_clk_src != NULL)
 10032c8:	b125      	cbz	r5, 10032d4 <clock_stop+0x88>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
 10032ca:	f8d6 3418 	ldr.w	r3, [r6, #1048]	; 0x418
 10032ce:	f003 0303 	and.w	r3, r3, #3
                (*(nrf_clock_lfclk_t *)p_clk_src) =
 10032d2:	702b      	strb	r3, [r5, #0]
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
 10032d4:	f8d6 3418 	ldr.w	r3, [r6, #1048]	; 0x418
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
 10032d8:	03db      	lsls	r3, r3, #15
 10032da:	d509      	bpl.n	10032f0 <clock_stop+0xa4>
    NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, p_clk_src) ||
 10032dc:	b11d      	cbz	r5, 10032e6 <clock_stop+0x9a>
 10032de:	f89d 3007 	ldrb.w	r3, [sp, #7]
 10032e2:	2b01      	cmp	r3, #1
 10032e4:	d104      	bne.n	10032f0 <clock_stop+0xa4>
 10032e6:	2001      	movs	r0, #1
 10032e8:	f000 fe90 	bl	100400c <nrfx_busy_wait>
 10032ec:	3f01      	subs	r7, #1
 10032ee:	d1d4      	bne.n	100329a <clock_stop+0x4e>
}
 10032f0:	b003      	add	sp, #12
 10032f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
            if (p_clk_src != NULL)
 10032f4:	b125      	cbz	r5, 1003300 <clock_stop+0xb4>
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
 10032f6:	f8d6 340c 	ldr.w	r3, [r6, #1036]	; 0x40c
 10032fa:	f003 0301 	and.w	r3, r3, #1
                (*(nrf_clock_hfclk_t *)p_clk_src) =
 10032fe:	702b      	strb	r3, [r5, #0]
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
 1003300:	f8d6 340c 	ldr.w	r3, [r6, #1036]	; 0x40c
 1003304:	e7e8      	b.n	10032d8 <clock_stop+0x8c>
 1003306:	bf00      	nop
 1003308:	0100501a 	.word	0x0100501a
 100330c:	010044ec 	.word	0x010044ec
 1003310:	41005000 	.word	0x41005000
 1003314:	01005057 	.word	0x01005057

01003318 <nrfx_clock_init>:
    }
    return is_correct_clk;
}

nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
 1003318:	b510      	push	{r4, lr}
    NRFX_ASSERT(event_handler);
 100331a:	4604      	mov	r4, r0
 100331c:	b950      	cbnz	r0, 1003334 <nrfx_clock_init+0x1c>
 100331e:	490a      	ldr	r1, [pc, #40]	; (1003348 <nrfx_clock_init+0x30>)
 1003320:	480a      	ldr	r0, [pc, #40]	; (100334c <nrfx_clock_init+0x34>)
 1003322:	f240 1215 	movw	r2, #277	; 0x115
 1003326:	f000 fc66 	bl	1003bf6 <assert_print>
 100332a:	f240 1115 	movw	r1, #277	; 0x115
 100332e:	4806      	ldr	r0, [pc, #24]	; (1003348 <nrfx_clock_init+0x30>)
 1003330:	f000 fc5a 	bl	1003be8 <assert_post_action>

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
 1003334:	4b06      	ldr	r3, [pc, #24]	; (1003350 <nrfx_clock_init+0x38>)
 1003336:	791a      	ldrb	r2, [r3, #4]
 1003338:	b922      	cbnz	r2, 1003344 <nrfx_clock_init+0x2c>
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
        m_clock_cb.module_initialized = true;
 100333a:	2201      	movs	r2, #1
    nrfx_err_t err_code = NRFX_SUCCESS;
 100333c:	4805      	ldr	r0, [pc, #20]	; (1003354 <nrfx_clock_init+0x3c>)
        m_clock_cb.event_handler = event_handler;
 100333e:	601c      	str	r4, [r3, #0]
        m_clock_cb.module_initialized = true;
 1003340:	711a      	strb	r2, [r3, #4]
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
 1003342:	bd10      	pop	{r4, pc}
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
 1003344:	4804      	ldr	r0, [pc, #16]	; (1003358 <nrfx_clock_init+0x40>)
    return err_code;
 1003346:	e7fc      	b.n	1003342 <nrfx_clock_init+0x2a>
 1003348:	0100501a 	.word	0x0100501a
 100334c:	010044ec 	.word	0x010044ec
 1003350:	21000138 	.word	0x21000138
 1003354:	0bad0000 	.word	0x0bad0000
 1003358:	0bad000c 	.word	0x0bad000c

0100335c <nrfx_clock_enable>:

void nrfx_clock_enable(void)
{
 100335c:	b508      	push	{r3, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
 100335e:	4b0e      	ldr	r3, [pc, #56]	; (1003398 <nrfx_clock_enable+0x3c>)
 1003360:	791b      	ldrb	r3, [r3, #4]
 1003362:	b953      	cbnz	r3, 100337a <nrfx_clock_enable+0x1e>
 1003364:	490d      	ldr	r1, [pc, #52]	; (100339c <nrfx_clock_enable+0x40>)
 1003366:	480e      	ldr	r0, [pc, #56]	; (10033a0 <nrfx_clock_enable+0x44>)
 1003368:	f44f 7297 	mov.w	r2, #302	; 0x12e
 100336c:	f000 fc43 	bl	1003bf6 <assert_print>
 1003370:	f44f 7197 	mov.w	r1, #302	; 0x12e
 1003374:	4809      	ldr	r0, [pc, #36]	; (100339c <nrfx_clock_enable+0x40>)
 1003376:	f000 fc37 	bl	1003be8 <assert_post_action>
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
 100337a:	2005      	movs	r0, #5
 100337c:	f7fe fbd4 	bl	1001b28 <arch_irq_is_enabled>
 1003380:	b910      	cbnz	r0, 1003388 <nrfx_clock_enable+0x2c>
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
 1003382:	2005      	movs	r0, #5
 1003384:	f7fe fbc0 	bl	1001b08 <arch_irq_enable>
    p_reg->LFCLKSRC = (uint32_t)(source);
 1003388:	2201      	movs	r2, #1
 100338a:	4b06      	ldr	r3, [pc, #24]	; (10033a4 <nrfx_clock_enable+0x48>)
 100338c:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
}

#if NRF_CLOCK_HAS_HFCLKSRC
NRF_STATIC_INLINE void nrf_clock_hf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_hfclk_t source)
{
    p_reg->HFCLKSRC = (uint32_t)(source);
 1003390:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
#if NRFX_CHECK(NRFX_POWER_ENABLED)
    nrfx_clock_irq_enabled = true;
#endif

    NRFX_LOG_INFO("Module enabled.");
}
 1003394:	bd08      	pop	{r3, pc}
 1003396:	bf00      	nop
 1003398:	21000138 	.word	0x21000138
 100339c:	0100501a 	.word	0x0100501a
 10033a0:	010044ec 	.word	0x010044ec
 10033a4:	41005000 	.word	0x41005000

010033a8 <nrfx_clock_start>:
    NRFX_LOG_INFO("Uninitialized.");
}

void nrfx_clock_start(nrf_clock_domain_t domain)
{
    NRFX_ASSERT(m_clock_cb.module_initialized);
 10033a8:	4b2c      	ldr	r3, [pc, #176]	; (100345c <nrfx_clock_start+0xb4>)
{
 10033aa:	b510      	push	{r4, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
 10033ac:	791b      	ldrb	r3, [r3, #4]
{
 10033ae:	4604      	mov	r4, r0
    NRFX_ASSERT(m_clock_cb.module_initialized);
 10033b0:	b953      	cbnz	r3, 10033c8 <nrfx_clock_start+0x20>
 10033b2:	492b      	ldr	r1, [pc, #172]	; (1003460 <nrfx_clock_start+0xb8>)
 10033b4:	482b      	ldr	r0, [pc, #172]	; (1003464 <nrfx_clock_start+0xbc>)
 10033b6:	f44f 72b4 	mov.w	r2, #360	; 0x168
 10033ba:	f000 fc1c 	bl	1003bf6 <assert_print>
 10033be:	f44f 71b4 	mov.w	r1, #360	; 0x168
 10033c2:	4827      	ldr	r0, [pc, #156]	; (1003460 <nrfx_clock_start+0xb8>)
 10033c4:	f000 fc10 	bl	1003be8 <assert_post_action>
    switch (domain)
 10033c8:	b174      	cbz	r4, 10033e8 <nrfx_clock_start+0x40>
 10033ca:	2c01      	cmp	r4, #1
 10033cc:	d03b      	beq.n	1003446 <nrfx_clock_start+0x9e>
            nrf_clock_int_enable(NRF_CLOCK, NRF_CLOCK_INT_HFAUDIO_STARTED_MASK);
            nrf_clock_task_trigger(NRF_CLOCK, NRF_CLOCK_TASK_HFCLKAUDIOSTART);
            break;
#endif
        default:
            NRFX_ASSERT(0);
 10033ce:	4924      	ldr	r1, [pc, #144]	; (1003460 <nrfx_clock_start+0xb8>)
 10033d0:	4824      	ldr	r0, [pc, #144]	; (1003464 <nrfx_clock_start+0xbc>)
 10033d2:	f44f 72d3 	mov.w	r2, #422	; 0x1a6
 10033d6:	f000 fc0e 	bl	1003bf6 <assert_print>
            break;
    }
}
 10033da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            NRFX_ASSERT(0);
 10033de:	f44f 71d3 	mov.w	r1, #422	; 0x1a6
 10033e2:	481f      	ldr	r0, [pc, #124]	; (1003460 <nrfx_clock_start+0xb8>)
 10033e4:	f000 bc00 	b.w	1003be8 <assert_post_action>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
 10033e8:	4a1f      	ldr	r2, [pc, #124]	; (1003468 <nrfx_clock_start+0xc0>)
 10033ea:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
 10033ee:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
 10033f2:	03c9      	lsls	r1, r1, #15
 10033f4:	d412      	bmi.n	100341c <nrfx_clock_start+0x74>
            return ((p_reg->LFCLKRUN & CLOCK_LFCLKRUN_STATUS_Msk)
 10033f6:	f8d2 3414 	ldr.w	r3, [r2, #1044]	; 0x414
                else if (nrf_clock_start_task_check(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK))
 10033fa:	07db      	lsls	r3, r3, #31
 10033fc:	d418      	bmi.n	1003430 <nrfx_clock_start+0x88>
        *p_lfclksrc = clock_initial_lfclksrc_get();
 10033fe:	2301      	movs	r3, #1
    p_reg->LFCLKSRC = (uint32_t)(source);
 1003400:	4a19      	ldr	r2, [pc, #100]	; (1003468 <nrfx_clock_start+0xc0>)
 1003402:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 1003406:	2300      	movs	r3, #0
 1003408:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
 100340c:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
    p_reg->INTENSET = mask;
 1003410:	2302      	movs	r3, #2
 1003412:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 1003416:	2301      	movs	r3, #1
 1003418:	6093      	str	r3, [r2, #8]
}
 100341a:	bd10      	pop	{r4, pc}
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
 100341c:	f003 0303 	and.w	r3, r3, #3
    is_correct_clk = is_correct_clk || (*p_lfclksrc == NRF_CLOCK_LFCLK_RC);
 1003420:	2b02      	cmp	r3, #2
 1003422:	d0ed      	beq.n	1003400 <nrfx_clock_start+0x58>
    if (!is_correct_clk)
 1003424:	2b01      	cmp	r3, #1
 1003426:	d0eb      	beq.n	1003400 <nrfx_clock_start+0x58>
        clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
 1003428:	2000      	movs	r0, #0
 100342a:	f7ff ff0f 	bl	100324c <clock_stop>
 100342e:	e7e6      	b.n	10033fe <nrfx_clock_start+0x56>
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
 1003430:	f8d2 341c 	ldr.w	r3, [r2, #1052]	; 0x41c
 1003434:	f003 0303 	and.w	r3, r3, #3
    if (!is_correct_clk)
 1003438:	3b01      	subs	r3, #1
 100343a:	2b01      	cmp	r3, #1
 100343c:	d8f4      	bhi.n	1003428 <nrfx_clock_start+0x80>
    p_reg->INTENSET = mask;
 100343e:	2302      	movs	r3, #2
 1003440:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
                        break;
 1003444:	e7e9      	b.n	100341a <nrfx_clock_start+0x72>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 1003446:	2200      	movs	r2, #0
 1003448:	4b07      	ldr	r3, [pc, #28]	; (1003468 <nrfx_clock_start+0xc0>)
 100344a:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
 100344e:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENSET = mask;
 1003452:	f8c3 4304 	str.w	r4, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 1003456:	601c      	str	r4, [r3, #0]
}
 1003458:	e7df      	b.n	100341a <nrfx_clock_start+0x72>
 100345a:	bf00      	nop
 100345c:	21000138 	.word	0x21000138
 1003460:	0100501a 	.word	0x0100501a
 1003464:	010044ec 	.word	0x010044ec
 1003468:	41005000 	.word	0x41005000

0100346c <nrfx_clock_stop>:

void nrfx_clock_stop(nrf_clock_domain_t domain)
{
    NRFX_ASSERT(m_clock_cb.module_initialized);
 100346c:	4b0a      	ldr	r3, [pc, #40]	; (1003498 <nrfx_clock_stop+0x2c>)
{
 100346e:	b510      	push	{r4, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
 1003470:	791b      	ldrb	r3, [r3, #4]
{
 1003472:	4604      	mov	r4, r0
    NRFX_ASSERT(m_clock_cb.module_initialized);
 1003474:	b953      	cbnz	r3, 100348c <nrfx_clock_stop+0x20>
 1003476:	4909      	ldr	r1, [pc, #36]	; (100349c <nrfx_clock_stop+0x30>)
 1003478:	4809      	ldr	r0, [pc, #36]	; (10034a0 <nrfx_clock_stop+0x34>)
 100347a:	f240 12ad 	movw	r2, #429	; 0x1ad
 100347e:	f000 fbba 	bl	1003bf6 <assert_print>
 1003482:	f240 11ad 	movw	r1, #429	; 0x1ad
 1003486:	4805      	ldr	r0, [pc, #20]	; (100349c <nrfx_clock_stop+0x30>)
 1003488:	f000 fbae 	bl	1003be8 <assert_post_action>
    clock_stop(domain);
 100348c:	4620      	mov	r0, r4
}
 100348e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    clock_stop(domain);
 1003492:	f7ff bedb 	b.w	100324c <clock_stop>
 1003496:	bf00      	nop
 1003498:	21000138 	.word	0x21000138
 100349c:	0100501a 	.word	0x0100501a
 10034a0:	010044ec 	.word	0x010044ec

010034a4 <nrfx_power_clock_irq_handler>:
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
 10034a4:	4b17      	ldr	r3, [pc, #92]	; (1003504 <nrfx_power_clock_irq_handler+0x60>)
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
 10034a6:	b510      	push	{r4, lr}
 10034a8:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
 10034ac:	b152      	cbz	r2, 10034c4 <nrfx_power_clock_irq_handler+0x20>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 10034ae:	2000      	movs	r0, #0
 10034b0:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
 10034b4:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENCLR = mask;
 10034b8:	2201      	movs	r2, #1
 10034ba:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        {
            m_clock_cb.hfclk_started = true;
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
 10034be:	4b12      	ldr	r3, [pc, #72]	; (1003508 <nrfx_power_clock_irq_handler+0x64>)
 10034c0:	681b      	ldr	r3, [r3, #0]
 10034c2:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
 10034c4:	4b0f      	ldr	r3, [pc, #60]	; (1003504 <nrfx_power_clock_irq_handler+0x60>)
 10034c6:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
 10034ca:	b18a      	cbz	r2, 10034f0 <nrfx_power_clock_irq_handler+0x4c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 10034cc:	2200      	movs	r2, #0
 10034ce:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
 10034d2:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
 10034d6:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
 10034da:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
 10034de:	f002 0203 	and.w	r2, r2, #3
 10034e2:	2a01      	cmp	r2, #1
 10034e4:	f04f 0102 	mov.w	r1, #2
 10034e8:	d103      	bne.n	10034f2 <nrfx_power_clock_irq_handler+0x4e>
    p_reg->LFCLKSRC = (uint32_t)(source);
 10034ea:	f8c3 1518 	str.w	r1, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 10034ee:	609a      	str	r2, [r3, #8]
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
    }
#endif
}
 10034f0:	bd10      	pop	{r4, pc}
    p_reg->INTENCLR = mask;
 10034f2:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
 10034f6:	4b04      	ldr	r3, [pc, #16]	; (1003508 <nrfx_power_clock_irq_handler+0x64>)
 10034f8:	2001      	movs	r0, #1
}
 10034fa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
 10034fe:	681b      	ldr	r3, [r3, #0]
 1003500:	4718      	bx	r3
 1003502:	bf00      	nop
 1003504:	41005000 	.word	0x41005000
 1003508:	21000138 	.word	0x21000138

0100350c <nvmc_word_write>:
 100350c:	4a04      	ldr	r2, [pc, #16]	; (1003520 <nvmc_word_write+0x14>)
 100350e:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
{
#if defined(NRF9160_XXAA)
    while (!nrf_nvmc_write_ready_check(NRF_NVMC))
    {}
#else
    while (!nrf_nvmc_ready_check(NRF_NVMC))
 1003512:	07db      	lsls	r3, r3, #31
 1003514:	d5fb      	bpl.n	100350e <nvmc_word_write+0x2>
    {}
#endif

    *(volatile uint32_t *)addr = value;
 1003516:	6001      	str	r1, [r0, #0]
  __ASM volatile ("dmb 0xF":::"memory");
 1003518:	f3bf 8f5f 	dmb	sy
    __DMB();
}
 100351c:	4770      	bx	lr
 100351e:	bf00      	nop
 1003520:	41080000 	.word	0x41080000

01003524 <nrfx_nvmc_page_erase>:
    if ((addr - NVMC_FLASH_BASE_ADDRESS) < flash_total_size_get())
 1003524:	f100 437f 	add.w	r3, r0, #4278190080	; 0xff000000
 1003528:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
        nvmc_word_write(addr + (NVMC_BYTES_IN_WORD * i), ((uint32_t const *)src)[i]);
    }
}

nrfx_err_t nrfx_nvmc_page_erase(uint32_t addr)
{
 100352c:	b510      	push	{r4, lr}
 100352e:	4604      	mov	r4, r0
    if ((addr - NVMC_FLASH_BASE_ADDRESS) < flash_total_size_get())
 1003530:	d30a      	bcc.n	1003548 <nrfx_nvmc_page_erase+0x24>
    NRFX_ASSERT(is_valid_address(addr, false));
 1003532:	4910      	ldr	r1, [pc, #64]	; (1003574 <nrfx_nvmc_page_erase+0x50>)
 1003534:	4810      	ldr	r0, [pc, #64]	; (1003578 <nrfx_nvmc_page_erase+0x54>)
 1003536:	f44f 7283 	mov.w	r2, #262	; 0x106
 100353a:	f000 fb5c 	bl	1003bf6 <assert_print>
 100353e:	f44f 7183 	mov.w	r1, #262	; 0x106
 1003542:	480c      	ldr	r0, [pc, #48]	; (1003574 <nrfx_nvmc_page_erase+0x50>)
 1003544:	f000 fb50 	bl	1003be8 <assert_post_action>
    return !(addr % flash_page_size_get());
 1003548:	f3c4 030a 	ubfx	r3, r4, #0, #11

    if (!is_page_aligned_check(addr))
 100354c:	b97b      	cbnz	r3, 100356e <nrfx_nvmc_page_erase+0x4a>
    p_reg->CONFIG = (uint32_t)mode;
 100354e:	2202      	movs	r2, #2
 1003550:	4b0a      	ldr	r3, [pc, #40]	; (100357c <nrfx_nvmc_page_erase+0x58>)
 1003552:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    *(volatile uint32_t *)page_addr = 0xFFFFFFFF;
 1003556:	f04f 32ff 	mov.w	r2, #4294967295
 100355a:	6022      	str	r2, [r4, #0]
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
 100355c:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
        return NRFX_ERROR_INVALID_ADDR;
    }

    nvmc_erase_mode_set();
    nrf_nvmc_page_erase_start(NRF_NVMC, addr);
    while (!nrf_nvmc_ready_check(NRF_NVMC))
 1003560:	07d2      	lsls	r2, r2, #31
 1003562:	d5fb      	bpl.n	100355c <nrfx_nvmc_page_erase+0x38>
    p_reg->CONFIG = (uint32_t)mode;
 1003564:	2200      	movs	r2, #0
    {}
    nvmc_readonly_mode_set();

    return NRFX_SUCCESS;
 1003566:	4806      	ldr	r0, [pc, #24]	; (1003580 <nrfx_nvmc_page_erase+0x5c>)
 1003568:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
}
 100356c:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_ADDR;
 100356e:	4805      	ldr	r0, [pc, #20]	; (1003584 <nrfx_nvmc_page_erase+0x60>)
 1003570:	e7fc      	b.n	100356c <nrfx_nvmc_page_erase+0x48>
 1003572:	bf00      	nop
 1003574:	0100508b 	.word	0x0100508b
 1003578:	010044ec 	.word	0x010044ec
 100357c:	41080000 	.word	0x41080000
 1003580:	0bad0000 	.word	0x0bad0000
 1003584:	0bad000a 	.word	0x0bad000a

01003588 <nrfx_nvmc_word_write>:

    nrfx_nvmc_word_write(aligned_addr, partial_word_create(addr, (const uint8_t *)&value, 2));
}

void nrfx_nvmc_word_write(uint32_t addr, uint32_t value)
{
 1003588:	b570      	push	{r4, r5, r6, lr}
 100358a:	460d      	mov	r5, r1
    NRFX_ASSERT(is_valid_address(addr, true));
 100358c:	2101      	movs	r1, #1
{
 100358e:	4604      	mov	r4, r0
    NRFX_ASSERT(is_valid_address(addr, true));
 1003590:	f000 fd3e 	bl	1004010 <is_valid_address>
 1003594:	b950      	cbnz	r0, 10035ac <nrfx_nvmc_word_write+0x24>
 1003596:	4912      	ldr	r1, [pc, #72]	; (10035e0 <nrfx_nvmc_word_write+0x58>)
 1003598:	4812      	ldr	r0, [pc, #72]	; (10035e4 <nrfx_nvmc_word_write+0x5c>)
 100359a:	f44f 72ca 	mov.w	r2, #404	; 0x194
 100359e:	f000 fb2a 	bl	1003bf6 <assert_print>
 10035a2:	f44f 71ca 	mov.w	r1, #404	; 0x194
 10035a6:	480e      	ldr	r0, [pc, #56]	; (10035e0 <nrfx_nvmc_word_write+0x58>)
 10035a8:	f000 fb1e 	bl	1003be8 <assert_post_action>
    NRFX_ASSERT(nrfx_is_word_aligned((void const *)addr));
 10035ac:	07a3      	lsls	r3, r4, #30
 10035ae:	d00a      	beq.n	10035c6 <nrfx_nvmc_word_write+0x3e>
 10035b0:	490b      	ldr	r1, [pc, #44]	; (10035e0 <nrfx_nvmc_word_write+0x58>)
 10035b2:	480c      	ldr	r0, [pc, #48]	; (10035e4 <nrfx_nvmc_word_write+0x5c>)
 10035b4:	f240 1295 	movw	r2, #405	; 0x195
 10035b8:	f000 fb1d 	bl	1003bf6 <assert_print>
 10035bc:	f240 1195 	movw	r1, #405	; 0x195
 10035c0:	4807      	ldr	r0, [pc, #28]	; (10035e0 <nrfx_nvmc_word_write+0x58>)
 10035c2:	f000 fb11 	bl	1003be8 <assert_post_action>
 10035c6:	2301      	movs	r3, #1
 10035c8:	4e07      	ldr	r6, [pc, #28]	; (10035e8 <nrfx_nvmc_word_write+0x60>)

    nvmc_write_mode_set();

    nvmc_word_write(addr, value);
 10035ca:	4629      	mov	r1, r5
 10035cc:	f8c6 3504 	str.w	r3, [r6, #1284]	; 0x504
 10035d0:	4620      	mov	r0, r4
 10035d2:	f7ff ff9b 	bl	100350c <nvmc_word_write>
 10035d6:	2300      	movs	r3, #0
 10035d8:	f8c6 3504 	str.w	r3, [r6, #1284]	; 0x504

    nvmc_readonly_mode_set();
}
 10035dc:	bd70      	pop	{r4, r5, r6, pc}
 10035de:	bf00      	nop
 10035e0:	0100508b 	.word	0x0100508b
 10035e4:	010044ec 	.word	0x010044ec
 10035e8:	41080000 	.word	0x41080000

010035ec <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 10035ec:	4b0e      	ldr	r3, [pc, #56]	; (1003628 <z_sys_init_run_level+0x3c>)
{
 10035ee:	b570      	push	{r4, r5, r6, lr}
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 10035f0:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
 10035f4:	3001      	adds	r0, #1
 10035f6:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
 10035fa:	42a6      	cmp	r6, r4
 10035fc:	d800      	bhi.n	1003600 <z_sys_init_run_level+0x14>
				dev->state->init_res = rc;
			}
			dev->state->initialized = true;
		}
	}
}
 10035fe:	bd70      	pop	{r4, r5, r6, pc}
		int rc = entry->init(dev);
 1003600:	e9d4 3500 	ldrd	r3, r5, [r4]
 1003604:	4628      	mov	r0, r5
 1003606:	4798      	blx	r3
		if (dev != NULL) {
 1003608:	b165      	cbz	r5, 1003624 <z_sys_init_run_level+0x38>
				dev->state->init_res = rc;
 100360a:	68eb      	ldr	r3, [r5, #12]
			if (rc != 0) {
 100360c:	b130      	cbz	r0, 100361c <z_sys_init_run_level+0x30>
				if (rc < 0) {
 100360e:	2800      	cmp	r0, #0
 1003610:	bfb8      	it	lt
 1003612:	4240      	neglt	r0, r0
				dev->state->init_res = rc;
 1003614:	28ff      	cmp	r0, #255	; 0xff
 1003616:	bfa8      	it	ge
 1003618:	20ff      	movge	r0, #255	; 0xff
 100361a:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
 100361c:	785a      	ldrb	r2, [r3, #1]
 100361e:	f042 0201 	orr.w	r2, r2, #1
 1003622:	705a      	strb	r2, [r3, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 1003624:	3408      	adds	r4, #8
 1003626:	e7e8      	b.n	10035fa <z_sys_init_run_level+0xe>
 1003628:	010042f0 	.word	0x010042f0

0100362c <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
 100362c:	b573      	push	{r0, r1, r4, r5, r6, lr}
 100362e:	4604      	mov	r4, r0
 1003630:	460d      	mov	r5, r1
	__asm__ volatile(
 1003632:	f04f 0320 	mov.w	r3, #32
 1003636:	f3ef 8611 	mrs	r6, BASEPRI
 100363a:	f383 8812 	msr	BASEPRI_MAX, r3
 100363e:	f3bf 8f6f 	isb	sy
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
 1003642:	2200      	movs	r2, #0
 1003644:	2804      	cmp	r0, #4
 1003646:	bf96      	itet	ls
 1003648:	4b16      	ldrls	r3, [pc, #88]	; (10036a4 <z_fatal_error+0x78>)
 100364a:	4b17      	ldrhi	r3, [pc, #92]	; (10036a8 <z_fatal_error+0x7c>)
	return 0;
 100364c:	f853 3020 	ldrls.w	r3, [r3, r0, lsl #2]
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
 1003650:	9200      	str	r2, [sp, #0]
 1003652:	2145      	movs	r1, #69	; 0x45
 1003654:	4602      	mov	r2, r0
 1003656:	4815      	ldr	r0, [pc, #84]	; (10036ac <z_fatal_error+0x80>)
 1003658:	f000 fadb 	bl	1003c12 <z_log_minimal_printk>
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
 100365c:	b13d      	cbz	r5, 100366e <z_fatal_error+0x42>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
 100365e:	69eb      	ldr	r3, [r5, #28]
 1003660:	f3c3 0308 	ubfx	r3, r3, #0, #9
 1003664:	b11b      	cbz	r3, 100366e <z_fatal_error+0x42>
		LOG_ERR("Fault during interrupt handling\n");
 1003666:	2145      	movs	r1, #69	; 0x45
 1003668:	4811      	ldr	r0, [pc, #68]	; (10036b0 <z_fatal_error+0x84>)
 100366a:	f000 fad2 	bl	1003c12 <z_log_minimal_printk>
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
 100366e:	2200      	movs	r2, #0
 1003670:	2145      	movs	r1, #69	; 0x45
 1003672:	4b10      	ldr	r3, [pc, #64]	; (10036b4 <z_fatal_error+0x88>)
 1003674:	4810      	ldr	r0, [pc, #64]	; (10036b8 <z_fatal_error+0x8c>)
 1003676:	f000 facc 	bl	1003c12 <z_log_minimal_printk>

#ifndef CONFIG_XTENSA
	coredump(reason, esf, thread);
#endif

	k_sys_fatal_error_handler(reason, esf);
 100367a:	4629      	mov	r1, r5
 100367c:	4620      	mov	r0, r4
 100367e:	f7ff fadd 	bl	1002c3c <k_sys_fatal_error_handler>
	 *
	 * Note that k_thread_abort() returns on some architectures but
	 * not others; e.g. on ARC, x86_64, Xtensa with ASM2, ARM
	 */
	if (!IS_ENABLED(CONFIG_TEST)) {
		__ASSERT(reason != K_ERR_KERNEL_PANIC,
 1003682:	2c04      	cmp	r4, #4
 1003684:	d108      	bne.n	1003698 <z_fatal_error+0x6c>
 1003686:	490d      	ldr	r1, [pc, #52]	; (10036bc <z_fatal_error+0x90>)
 1003688:	480d      	ldr	r0, [pc, #52]	; (10036c0 <z_fatal_error+0x94>)
 100368a:	2293      	movs	r2, #147	; 0x93
 100368c:	f000 fab3 	bl	1003bf6 <assert_print>
 1003690:	2193      	movs	r1, #147	; 0x93
 1003692:	480a      	ldr	r0, [pc, #40]	; (10036bc <z_fatal_error+0x90>)
 1003694:	f000 faa8 	bl	1003be8 <assert_post_action>
	__asm__ volatile(
 1003698:	f386 8811 	msr	BASEPRI, r6
 100369c:	f3bf 8f6f 	isb	sy
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
 10036a0:	b002      	add	sp, #8
 10036a2:	bd70      	pop	{r4, r5, r6, pc}
 10036a4:	01004304 	.word	0x01004304
 10036a8:	010050c7 	.word	0x010050c7
 10036ac:	010050d5 	.word	0x010050d5
 10036b0:	01005102 	.word	0x01005102
 10036b4:	01005128 	.word	0x01005128
 10036b8:	01005130 	.word	0x01005130
 10036bc:	0100514d 	.word	0x0100514d
 10036c0:	010044ec 	.word	0x010044ec

010036c4 <bg_thread_main>:
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
 10036c4:	2201      	movs	r2, #1
{
 10036c6:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
 10036c8:	4b08      	ldr	r3, [pc, #32]	; (10036ec <bg_thread_main+0x28>)

	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
 10036ca:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
 10036cc:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
 10036ce:	f7ff ff8d 	bl	10035ec <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
 10036d2:	f000 f907 	bl	10038e4 <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
 10036d6:	2003      	movs	r0, #3
 10036d8:	f7ff ff88 	bl	10035ec <z_sys_init_run_level>
	z_mem_manage_boot_finish();
#endif /* CONFIG_MMU */

	extern void main(void);

	main();
 10036dc:	f7fd fa64 	bl	1000ba8 <main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
 10036e0:	4a03      	ldr	r2, [pc, #12]	; (10036f0 <bg_thread_main+0x2c>)
 10036e2:	7b13      	ldrb	r3, [r2, #12]
 10036e4:	f023 0301 	bic.w	r3, r3, #1
 10036e8:	7313      	strb	r3, [r2, #12]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
 10036ea:	bd08      	pop	{r3, pc}
 10036ec:	21000144 	.word	0x21000144
 10036f0:	21000038 	.word	0x21000038

010036f4 <z_bss_zero>:
{
 10036f4:	b508      	push	{r3, lr}
	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
 10036f6:	4803      	ldr	r0, [pc, #12]	; (1003704 <z_bss_zero+0x10>)
 10036f8:	4a03      	ldr	r2, [pc, #12]	; (1003708 <z_bss_zero+0x14>)
 10036fa:	2100      	movs	r1, #0
 10036fc:	1a12      	subs	r2, r2, r0
 10036fe:	f000 fcae 	bl	100405e <z_early_memset>
}
 1003702:	bd08      	pop	{r3, pc}
 1003704:	21000018 	.word	0x21000018
 1003708:	21000148 	.word	0x21000148

0100370c <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
 100370c:	b508      	push	{r3, lr}
 *
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
		(uint32_t)(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
 100370e:	4b17      	ldr	r3, [pc, #92]	; (100376c <z_cstart+0x60>)
	uint32_t msp =
 1003710:	f503 6200 	add.w	r2, r3, #2048	; 0x800
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 1003714:	f382 8808 	msr	MSP, r2
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 1003718:	f383 880a 	msr	MSPLIM, r3
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 100371c:	2500      	movs	r5, #0
 100371e:	23e0      	movs	r3, #224	; 0xe0
 1003720:	4c13      	ldr	r4, [pc, #76]	; (1003770 <z_cstart+0x64>)
 1003722:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
 1003726:	77e5      	strb	r5, [r4, #31]
 1003728:	7625      	strb	r5, [r4, #24]
 100372a:	7665      	strb	r5, [r4, #25]
 100372c:	76a5      	strb	r5, [r4, #26]
 100372e:	f884 5020 	strb.w	r5, [r4, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
 1003732:	6a63      	ldr	r3, [r4, #36]	; 0x24
 1003734:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
 1003738:	6263      	str	r3, [r4, #36]	; 0x24
 100373a:	f884 5023 	strb.w	r5, [r4, #35]	; 0x23

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
 100373e:	f7fe fc7b 	bl	1002038 <z_arm_fault_init>
	z_arm_cpu_idle_init();
 1003742:	f7fe f9a3 	bl	1001a8c <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
 1003746:	f04f 33ff 	mov.w	r3, #4294967295
 100374a:	62a3      	str	r3, [r4, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
 100374c:	62e3      	str	r3, [r4, #44]	; 0x2c
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
 100374e:	f000 fc7b 	bl	1004048 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
 1003752:	4628      	mov	r0, r5
 1003754:	f7ff ff4a 	bl	10035ec <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
 1003758:	2001      	movs	r0, #1
 100375a:	f7ff ff47 	bl	10035ec <z_sys_init_run_level>
#else
#ifdef ARCH_SWITCH_TO_MAIN_NO_MULTITHREADING
	/* Custom ARCH-specific routine to switch to main()
	 * in the case of no multi-threading.
	 */
	ARCH_SWITCH_TO_MAIN_NO_MULTITHREADING(bg_thread_main,
 100375e:	462b      	mov	r3, r5
 1003760:	462a      	mov	r2, r5
 1003762:	4629      	mov	r1, r5
 1003764:	4803      	ldr	r0, [pc, #12]	; (1003774 <z_cstart+0x68>)
 1003766:	f7fe fa3d 	bl	1001be4 <z_arm_switch_to_main_no_multithreading>
 100376a:	bf00      	nop
 100376c:	21000548 	.word	0x21000548
 1003770:	e000ed00 	.word	0xe000ed00
 1003774:	010036c5 	.word	0x010036c5

01003778 <z_data_copy>:
 * @brief Copy the data section from ROM to RAM
 *
 * This routine copies the data section from ROM to RAM.
 */
void z_data_copy(void)
{
 1003778:	b508      	push	{r3, lr}
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
		       __data_region_end - __data_region_start);
 100377a:	4806      	ldr	r0, [pc, #24]	; (1003794 <z_data_copy+0x1c>)
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
 100377c:	4a06      	ldr	r2, [pc, #24]	; (1003798 <z_data_copy+0x20>)
 100377e:	4907      	ldr	r1, [pc, #28]	; (100379c <z_data_copy+0x24>)
 1003780:	1a12      	subs	r2, r2, r0
 1003782:	f000 fc6e 	bl	1004062 <z_early_memcpy>
#else
	z_early_memcpy(&_app_smem_start, &_app_smem_rom_start,
		       _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
 1003786:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_early_memcpy(&__ramfunc_start, &__ramfunc_load_start,
 100378a:	4a05      	ldr	r2, [pc, #20]	; (10037a0 <z_data_copy+0x28>)
 100378c:	4905      	ldr	r1, [pc, #20]	; (10037a4 <z_data_copy+0x2c>)
 100378e:	4806      	ldr	r0, [pc, #24]	; (10037a8 <z_data_copy+0x30>)
 1003790:	f000 bc67 	b.w	1004062 <z_early_memcpy>
 1003794:	21000000 	.word	0x21000000
 1003798:	21000018 	.word	0x21000018
 100379c:	010051f4 	.word	0x010051f4
 10037a0:	00000000 	.word	0x00000000
 10037a4:	010051f4 	.word	0x010051f4
 10037a8:	21000000 	.word	0x21000000

010037ac <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
 10037ac:	4b03      	ldr	r3, [pc, #12]	; (10037bc <elapsed+0x10>)
 10037ae:	681b      	ldr	r3, [r3, #0]
 10037b0:	b90b      	cbnz	r3, 10037b6 <elapsed+0xa>
 10037b2:	f000 bba1 	b.w	1003ef8 <sys_clock_elapsed>
}
 10037b6:	2000      	movs	r0, #0
 10037b8:	4770      	bx	lr
 10037ba:	bf00      	nop
 10037bc:	21000140 	.word	0x21000140

010037c0 <next_timeout>:
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
 10037c0:	4b0d      	ldr	r3, [pc, #52]	; (10037f8 <next_timeout+0x38>)

static int32_t next_timeout(void)
{
 10037c2:	b510      	push	{r4, lr}
 10037c4:	681c      	ldr	r4, [r3, #0]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
 10037c6:	429c      	cmp	r4, r3
 10037c8:	bf08      	it	eq
 10037ca:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
 10037cc:	f7ff ffee 	bl	10037ac <elapsed>
	int32_t ret;

	if ((to == NULL) ||
 10037d0:	b174      	cbz	r4, 10037f0 <next_timeout+0x30>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
 10037d2:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 10037d6:	1a1b      	subs	r3, r3, r0
 10037d8:	eb62 70e0 	sbc.w	r0, r2, r0, asr #31
	if ((to == NULL) ||
 10037dc:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 10037e0:	f170 0200 	sbcs.w	r2, r0, #0
 10037e4:	da04      	bge.n	10037f0 <next_timeout+0x30>
		ret = MAX_WAIT;
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
 10037e6:	2800      	cmp	r0, #0
 10037e8:	bfac      	ite	ge
 10037ea:	4618      	movge	r0, r3
 10037ec:	2000      	movlt	r0, #0
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
 10037ee:	bd10      	pop	{r4, pc}
		ret = MAX_WAIT;
 10037f0:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
	return ret;
 10037f4:	e7fb      	b.n	10037ee <next_timeout+0x2e>
 10037f6:	bf00      	nop
 10037f8:	21000008 	.word	0x21000008

010037fc <remove_timeout>:
{
 10037fc:	b530      	push	{r4, r5, lr}
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
 10037fe:	6803      	ldr	r3, [r0, #0]
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 1003800:	b168      	cbz	r0, 100381e <remove_timeout+0x22>
	return (node == list->tail) ? NULL : node->next;
 1003802:	4a0a      	ldr	r2, [pc, #40]	; (100382c <remove_timeout+0x30>)
 1003804:	6852      	ldr	r2, [r2, #4]
 1003806:	4290      	cmp	r0, r2
 1003808:	d009      	beq.n	100381e <remove_timeout+0x22>
	if (next(t) != NULL) {
 100380a:	b143      	cbz	r3, 100381e <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
 100380c:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
 1003810:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
 1003814:	1912      	adds	r2, r2, r4
 1003816:	eb41 0105 	adc.w	r1, r1, r5
 100381a:	e9c3 2104 	strd	r2, r1, [r3, #16]
 * @param node the node to remove
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
 100381e:	6842      	ldr	r2, [r0, #4]
	sys_dnode_t *const next = node->next;

	prev->next = next;
 1003820:	6013      	str	r3, [r2, #0]
	next->prev = prev;
 1003822:	605a      	str	r2, [r3, #4]
	node->next = NULL;
 1003824:	2300      	movs	r3, #0
	node->prev = NULL;
 1003826:	e9c0 3300 	strd	r3, r3, [r0]
}
 100382a:	bd30      	pop	{r4, r5, pc}
 100382c:	21000008 	.word	0x21000008

01003830 <sys_clock_announce>:
		}
	}
}

void sys_clock_announce(int32_t ticks)
{
 1003830:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	__asm__ volatile(
 1003834:	f04f 0320 	mov.w	r3, #32
 1003838:	f3ef 8511 	mrs	r5, BASEPRI
 100383c:	f383 8812 	msr	BASEPRI_MAX, r3
 1003840:	f3bf 8f6f 	isb	sy
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
 1003844:	4f24      	ldr	r7, [pc, #144]	; (10038d8 <sys_clock_announce+0xa8>)
	return list->head == list;
 1003846:	f8df 8094 	ldr.w	r8, [pc, #148]	; 10038dc <sys_clock_announce+0xac>

	while (first() != NULL && first()->dticks <= announce_remaining) {
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
 100384a:	4e25      	ldr	r6, [pc, #148]	; (10038e0 <sys_clock_announce+0xb0>)
	announce_remaining = ticks;
 100384c:	6038      	str	r0, [r7, #0]
 100384e:	f8d8 0000 	ldr.w	r0, [r8]
	while (first() != NULL && first()->dticks <= announce_remaining) {
 1003852:	683b      	ldr	r3, [r7, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1003854:	4540      	cmp	r0, r8
 1003856:	ea4f 71e3 	mov.w	r1, r3, asr #31
		curr_tick += dt;
 100385a:	e9d6 2e00 	ldrd	r2, lr, [r6]
 100385e:	d00b      	beq.n	1003878 <sys_clock_announce+0x48>
	while (first() != NULL && first()->dticks <= announce_remaining) {
 1003860:	b150      	cbz	r0, 1003878 <sys_clock_announce+0x48>
 1003862:	e9d0 4c04 	ldrd	r4, ip, [r0, #16]
 1003866:	42a3      	cmp	r3, r4
 1003868:	eb71 090c 	sbcs.w	r9, r1, ip
 100386c:	da16      	bge.n	100389c <sys_clock_announce+0x6c>
		key = k_spin_lock(&timeout_lock);
		announce_remaining -= dt;
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
 100386e:	1ae4      	subs	r4, r4, r3
 1003870:	eb6c 0c01 	sbc.w	ip, ip, r1
 1003874:	e9c0 4c04 	strd	r4, ip, [r0, #16]
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
 1003878:	2400      	movs	r4, #0
	curr_tick += announce_remaining;
 100387a:	189b      	adds	r3, r3, r2
 100387c:	eb4e 0101 	adc.w	r1, lr, r1
 1003880:	e9c6 3100 	strd	r3, r1, [r6]
	announce_remaining = 0;
 1003884:	603c      	str	r4, [r7, #0]

	sys_clock_set_timeout(next_timeout(), false);
 1003886:	f7ff ff9b 	bl	10037c0 <next_timeout>
 100388a:	4621      	mov	r1, r4
 100388c:	f000 fb33 	bl	1003ef6 <sys_clock_set_timeout>
	__asm__ volatile(
 1003890:	f385 8811 	msr	BASEPRI, r5
 1003894:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
 1003898:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		curr_tick += dt;
 100389c:	18a2      	adds	r2, r4, r2
 100389e:	eb4e 71e4 	adc.w	r1, lr, r4, asr #31
		t->dticks = 0;
 10038a2:	2300      	movs	r3, #0
		curr_tick += dt;
 10038a4:	e9c6 2100 	strd	r2, r1, [r6]
		t->dticks = 0;
 10038a8:	2200      	movs	r2, #0
 10038aa:	e9c0 2304 	strd	r2, r3, [r0, #16]
		remove_timeout(t);
 10038ae:	f7ff ffa5 	bl	10037fc <remove_timeout>
 10038b2:	f385 8811 	msr	BASEPRI, r5
 10038b6:	f3bf 8f6f 	isb	sy
		t->fn(t);
 10038ba:	6883      	ldr	r3, [r0, #8]
 10038bc:	4798      	blx	r3
	__asm__ volatile(
 10038be:	f04f 0320 	mov.w	r3, #32
 10038c2:	f3ef 8511 	mrs	r5, BASEPRI
 10038c6:	f383 8812 	msr	BASEPRI_MAX, r3
 10038ca:	f3bf 8f6f 	isb	sy
		announce_remaining -= dt;
 10038ce:	683b      	ldr	r3, [r7, #0]
 10038d0:	1b1b      	subs	r3, r3, r4
 10038d2:	603b      	str	r3, [r7, #0]
 10038d4:	e7bb      	b.n	100384e <sys_clock_announce+0x1e>
 10038d6:	bf00      	nop
 10038d8:	21000140 	.word	0x21000140
 10038dc:	21000008 	.word	0x21000008
 10038e0:	210000b0 	.word	0x210000b0

010038e4 <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
 10038e4:	4a02      	ldr	r2, [pc, #8]	; (10038f0 <boot_banner+0xc>)
 10038e6:	4903      	ldr	r1, [pc, #12]	; (10038f4 <boot_banner+0x10>)
 10038e8:	4803      	ldr	r0, [pc, #12]	; (10038f8 <boot_banner+0x14>)
 10038ea:	f000 b8b2 	b.w	1003a52 <printk>
 10038ee:	bf00      	nop
 10038f0:	01005127 	.word	0x01005127
 10038f4:	010051bc 	.word	0x010051bc
 10038f8:	010051c9 	.word	0x010051c9

010038fc <sha256_blocks>:
 10038fc:	2a3f      	cmp	r2, #63	; 0x3f
 10038fe:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1003902:	4617      	mov	r7, r2
 1003904:	d953      	bls.n	10039ae <sha256_blocks+0xb2>
 1003906:	4605      	mov	r5, r0
 1003908:	460c      	mov	r4, r1
 100390a:	f1a2 0640 	sub.w	r6, r2, #64	; 0x40
 100390e:	f026 063f 	bic.w	r6, r6, #63	; 0x3f
 1003912:	3640      	adds	r6, #64	; 0x40
 1003914:	f8df 809c 	ldr.w	r8, [pc, #156]	; 10039b4 <sha256_blocks+0xb8>
 1003918:	440e      	add	r6, r1
 100391a:	6823      	ldr	r3, [r4, #0]
 100391c:	3440      	adds	r4, #64	; 0x40
 100391e:	ba1b      	rev	r3, r3
 1003920:	642b      	str	r3, [r5, #64]	; 0x40
 1003922:	f854 3c3c 	ldr.w	r3, [r4, #-60]
 1003926:	4641      	mov	r1, r8
 1003928:	ba1b      	rev	r3, r3
 100392a:	646b      	str	r3, [r5, #68]	; 0x44
 100392c:	f854 3c38 	ldr.w	r3, [r4, #-56]
 1003930:	4628      	mov	r0, r5
 1003932:	ba1b      	rev	r3, r3
 1003934:	64ab      	str	r3, [r5, #72]	; 0x48
 1003936:	f854 3c34 	ldr.w	r3, [r4, #-52]
 100393a:	ba1b      	rev	r3, r3
 100393c:	64eb      	str	r3, [r5, #76]	; 0x4c
 100393e:	f854 3c30 	ldr.w	r3, [r4, #-48]
 1003942:	ba1b      	rev	r3, r3
 1003944:	652b      	str	r3, [r5, #80]	; 0x50
 1003946:	f854 3c2c 	ldr.w	r3, [r4, #-44]
 100394a:	ba1b      	rev	r3, r3
 100394c:	656b      	str	r3, [r5, #84]	; 0x54
 100394e:	f854 3c28 	ldr.w	r3, [r4, #-40]
 1003952:	ba1b      	rev	r3, r3
 1003954:	65ab      	str	r3, [r5, #88]	; 0x58
 1003956:	f854 3c24 	ldr.w	r3, [r4, #-36]
 100395a:	ba1b      	rev	r3, r3
 100395c:	65eb      	str	r3, [r5, #92]	; 0x5c
 100395e:	f854 3c20 	ldr.w	r3, [r4, #-32]
 1003962:	ba1b      	rev	r3, r3
 1003964:	662b      	str	r3, [r5, #96]	; 0x60
 1003966:	f854 3c1c 	ldr.w	r3, [r4, #-28]
 100396a:	ba1b      	rev	r3, r3
 100396c:	666b      	str	r3, [r5, #100]	; 0x64
 100396e:	f854 3c18 	ldr.w	r3, [r4, #-24]
 1003972:	ba1b      	rev	r3, r3
 1003974:	66ab      	str	r3, [r5, #104]	; 0x68
 1003976:	f854 3c14 	ldr.w	r3, [r4, #-20]
 100397a:	ba1b      	rev	r3, r3
 100397c:	66eb      	str	r3, [r5, #108]	; 0x6c
 100397e:	f854 3c10 	ldr.w	r3, [r4, #-16]
 1003982:	ba1b      	rev	r3, r3
 1003984:	672b      	str	r3, [r5, #112]	; 0x70
 1003986:	f854 3c0c 	ldr.w	r3, [r4, #-12]
 100398a:	ba1b      	rev	r3, r3
 100398c:	676b      	str	r3, [r5, #116]	; 0x74
 100398e:	f854 3c08 	ldr.w	r3, [r4, #-8]
 1003992:	ba1b      	rev	r3, r3
 1003994:	67ab      	str	r3, [r5, #120]	; 0x78
 1003996:	f854 3c04 	ldr.w	r3, [r4, #-4]
 100399a:	ba1b      	rev	r3, r3
 100399c:	67eb      	str	r3, [r5, #124]	; 0x7c
 100399e:	f7fc fc97 	bl	10002d0 <ocrypto_sha256_loop>
 10039a2:	42b4      	cmp	r4, r6
 10039a4:	d1b9      	bne.n	100391a <sha256_blocks+0x1e>
 10039a6:	f007 003f 	and.w	r0, r7, #63	; 0x3f
 10039aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 10039ae:	4610      	mov	r0, r2
 10039b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 10039b4:	01004318 	.word	0x01004318

010039b8 <sha256_blocks.constprop.0>:
 10039b8:	460a      	mov	r2, r1
 10039ba:	b510      	push	{r4, lr}
 10039bc:	6814      	ldr	r4, [r2, #0]
 10039be:	491a      	ldr	r1, [pc, #104]	; (1003a28 <sha256_blocks.constprop.0+0x70>)
 10039c0:	ba24      	rev	r4, r4
 10039c2:	6404      	str	r4, [r0, #64]	; 0x40
 10039c4:	6854      	ldr	r4, [r2, #4]
 10039c6:	ba24      	rev	r4, r4
 10039c8:	6444      	str	r4, [r0, #68]	; 0x44
 10039ca:	6894      	ldr	r4, [r2, #8]
 10039cc:	ba24      	rev	r4, r4
 10039ce:	6484      	str	r4, [r0, #72]	; 0x48
 10039d0:	68d4      	ldr	r4, [r2, #12]
 10039d2:	ba24      	rev	r4, r4
 10039d4:	64c4      	str	r4, [r0, #76]	; 0x4c
 10039d6:	6914      	ldr	r4, [r2, #16]
 10039d8:	ba24      	rev	r4, r4
 10039da:	6504      	str	r4, [r0, #80]	; 0x50
 10039dc:	6954      	ldr	r4, [r2, #20]
 10039de:	ba24      	rev	r4, r4
 10039e0:	6544      	str	r4, [r0, #84]	; 0x54
 10039e2:	6994      	ldr	r4, [r2, #24]
 10039e4:	ba24      	rev	r4, r4
 10039e6:	6584      	str	r4, [r0, #88]	; 0x58
 10039e8:	69d4      	ldr	r4, [r2, #28]
 10039ea:	ba24      	rev	r4, r4
 10039ec:	65c4      	str	r4, [r0, #92]	; 0x5c
 10039ee:	6a14      	ldr	r4, [r2, #32]
 10039f0:	ba24      	rev	r4, r4
 10039f2:	6604      	str	r4, [r0, #96]	; 0x60
 10039f4:	6a54      	ldr	r4, [r2, #36]	; 0x24
 10039f6:	ba24      	rev	r4, r4
 10039f8:	6644      	str	r4, [r0, #100]	; 0x64
 10039fa:	6a94      	ldr	r4, [r2, #40]	; 0x28
 10039fc:	ba24      	rev	r4, r4
 10039fe:	6684      	str	r4, [r0, #104]	; 0x68
 1003a00:	6ad4      	ldr	r4, [r2, #44]	; 0x2c
 1003a02:	ba24      	rev	r4, r4
 1003a04:	66c4      	str	r4, [r0, #108]	; 0x6c
 1003a06:	6b14      	ldr	r4, [r2, #48]	; 0x30
 1003a08:	ba24      	rev	r4, r4
 1003a0a:	6704      	str	r4, [r0, #112]	; 0x70
 1003a0c:	6b54      	ldr	r4, [r2, #52]	; 0x34
 1003a0e:	ba24      	rev	r4, r4
 1003a10:	6744      	str	r4, [r0, #116]	; 0x74
 1003a12:	6b94      	ldr	r4, [r2, #56]	; 0x38
 1003a14:	ba24      	rev	r4, r4
 1003a16:	6784      	str	r4, [r0, #120]	; 0x78
 1003a18:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 1003a1a:	ba12      	rev	r2, r2
 1003a1c:	67c2      	str	r2, [r0, #124]	; 0x7c
 1003a1e:	f7fc fc57 	bl	10002d0 <ocrypto_sha256_loop>
 1003a22:	2000      	movs	r0, #0
 1003a24:	bd10      	pop	{r4, pc}
 1003a26:	bf00      	nop
 1003a28:	01004318 	.word	0x01004318

01003a2c <sys_notify_validate>:
	if (notify == NULL) {
 1003a2c:	4603      	mov	r3, r0
 1003a2e:	b158      	cbz	r0, 1003a48 <sys_notify_validate+0x1c>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
 1003a30:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
 1003a32:	f002 0203 	and.w	r2, r2, #3
	switch (sys_notify_get_method(notify)) {
 1003a36:	2a01      	cmp	r2, #1
 1003a38:	d003      	beq.n	1003a42 <sys_notify_validate+0x16>
 1003a3a:	2a03      	cmp	r2, #3
 1003a3c:	d104      	bne.n	1003a48 <sys_notify_validate+0x1c>
		if (notify->method.callback == NULL) {
 1003a3e:	6802      	ldr	r2, [r0, #0]
 1003a40:	b112      	cbz	r2, 1003a48 <sys_notify_validate+0x1c>
		notify->result = 0;
 1003a42:	2000      	movs	r0, #0
 1003a44:	6098      	str	r0, [r3, #8]
 1003a46:	4770      	bx	lr
		return -EINVAL;
 1003a48:	f06f 0015 	mvn.w	r0, #21
}
 1003a4c:	4770      	bx	lr

01003a4e <arch_printk_char_out>:
}
 1003a4e:	2000      	movs	r0, #0
 1003a50:	4770      	bx	lr

01003a52 <printk>:
 *
 * @param fmt formatted string to output
 */

void printk(const char *fmt, ...)
{
 1003a52:	b40f      	push	{r0, r1, r2, r3}
 1003a54:	b507      	push	{r0, r1, r2, lr}
 1003a56:	a904      	add	r1, sp, #16
 1003a58:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list ap;

	va_start(ap, fmt);
 1003a5c:	9101      	str	r1, [sp, #4]

	vprintk(fmt, ap);
 1003a5e:	f7fd f941 	bl	1000ce4 <vprintk>

	va_end(ap);
}
 1003a62:	b003      	add	sp, #12
 1003a64:	f85d eb04 	ldr.w	lr, [sp], #4
 1003a68:	b004      	add	sp, #16
 1003a6a:	4770      	bx	lr

01003a6c <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
 1003a6c:	8b03      	ldrh	r3, [r0, #24]
	if ((state == ONOFF_STATE_OFF)
 1003a6e:	f013 0307 	ands.w	r3, r3, #7
 1003a72:	d105      	bne.n	1003a80 <process_recheck+0x14>
	    && !sys_slist_is_empty(&mgr->clients)) {
 1003a74:	6803      	ldr	r3, [r0, #0]
		evt = EVT_START;
 1003a76:	2b00      	cmp	r3, #0
 1003a78:	bf0c      	ite	eq
 1003a7a:	2000      	moveq	r0, #0
 1003a7c:	2003      	movne	r0, #3
 1003a7e:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ON)
 1003a80:	2b02      	cmp	r3, #2
 1003a82:	d105      	bne.n	1003a90 <process_recheck+0x24>
		   && (mgr->refs == 0U)) {
 1003a84:	8b43      	ldrh	r3, [r0, #26]
		evt = EVT_STOP;
 1003a86:	2b00      	cmp	r3, #0
 1003a88:	bf14      	ite	ne
 1003a8a:	2000      	movne	r0, #0
 1003a8c:	2004      	moveq	r0, #4
 1003a8e:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ERROR)
 1003a90:	2b01      	cmp	r3, #1
 1003a92:	d105      	bne.n	1003aa0 <process_recheck+0x34>
		   && !sys_slist_is_empty(&mgr->clients)) {
 1003a94:	6803      	ldr	r3, [r0, #0]
		evt = EVT_RESET;
 1003a96:	2b00      	cmp	r3, #0
 1003a98:	bf0c      	ite	eq
 1003a9a:	2000      	moveq	r0, #0
 1003a9c:	2005      	movne	r0, #5
 1003a9e:	4770      	bx	lr
	int evt = EVT_NOP;
 1003aa0:	2000      	movs	r0, #0
}
 1003aa2:	4770      	bx	lr

01003aa4 <notify_one>:
{
 1003aa4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1003aa8:	460d      	mov	r5, r1
 1003aaa:	4607      	mov	r7, r0
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
 1003aac:	4619      	mov	r1, r3
 1003aae:	1d28      	adds	r0, r5, #4
{
 1003ab0:	4690      	mov	r8, r2
 1003ab2:	461e      	mov	r6, r3
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
 1003ab4:	f7fd f8f2 	bl	1000c9c <sys_notify_finalize>
	if (cb) {
 1003ab8:	4604      	mov	r4, r0
 1003aba:	b138      	cbz	r0, 1003acc <notify_one+0x28>
		cb(mgr, cli, state, res);
 1003abc:	4633      	mov	r3, r6
 1003abe:	4642      	mov	r2, r8
 1003ac0:	4629      	mov	r1, r5
 1003ac2:	4638      	mov	r0, r7
 1003ac4:	46a4      	mov	ip, r4
}
 1003ac6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		cb(mgr, cli, state, res);
 1003aca:	4760      	bx	ip
}
 1003acc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

01003ad0 <transition_complete>:
{
 1003ad0:	b410      	push	{r4}
 1003ad2:	f04f 0420 	mov.w	r4, #32
 1003ad6:	f3ef 8211 	mrs	r2, BASEPRI
 1003ada:	f384 8812 	msr	BASEPRI_MAX, r4
 1003ade:	f3bf 8f6f 	isb	sy
	mgr->last_res = res;
 1003ae2:	6141      	str	r1, [r0, #20]
}
 1003ae4:	bc10      	pop	{r4}
	process_event(mgr, EVT_COMPLETE, key);
 1003ae6:	2101      	movs	r1, #1
 1003ae8:	f7fd b90a 	b.w	1000d00 <process_event>

01003aec <validate_args>:
{
 1003aec:	b510      	push	{r4, lr}
 1003aee:	460c      	mov	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
 1003af0:	b140      	cbz	r0, 1003b04 <validate_args+0x18>
 1003af2:	b139      	cbz	r1, 1003b04 <validate_args+0x18>
	int rv = sys_notify_validate(&cli->notify);
 1003af4:	1d08      	adds	r0, r1, #4
 1003af6:	f7ff ff99 	bl	1003a2c <sys_notify_validate>
	if ((rv == 0)
 1003afa:	b928      	cbnz	r0, 1003b08 <validate_args+0x1c>
	    && ((cli->notify.flags
 1003afc:	68a3      	ldr	r3, [r4, #8]
 1003afe:	f033 0303 	bics.w	r3, r3, #3
 1003b02:	d001      	beq.n	1003b08 <validate_args+0x1c>
		rv = -EINVAL;
 1003b04:	f06f 0015 	mvn.w	r0, #21
}
 1003b08:	bd10      	pop	{r4, pc}

01003b0a <onoff_manager_init>:
{
 1003b0a:	b538      	push	{r3, r4, r5, lr}
 1003b0c:	460c      	mov	r4, r1
	if ((mgr == NULL)
 1003b0e:	4605      	mov	r5, r0
 1003b10:	b158      	cbz	r0, 1003b2a <onoff_manager_init+0x20>
	    || (transitions == NULL)
 1003b12:	b151      	cbz	r1, 1003b2a <onoff_manager_init+0x20>
	    || (transitions->start == NULL)
 1003b14:	680b      	ldr	r3, [r1, #0]
 1003b16:	b143      	cbz	r3, 1003b2a <onoff_manager_init+0x20>
	    || (transitions->stop == NULL)) {
 1003b18:	684b      	ldr	r3, [r1, #4]
 1003b1a:	b133      	cbz	r3, 1003b2a <onoff_manager_init+0x20>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
 1003b1c:	221c      	movs	r2, #28
 1003b1e:	2100      	movs	r1, #0
 1003b20:	f000 f909 	bl	1003d36 <memset>
	return 0;
 1003b24:	2000      	movs	r0, #0
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
 1003b26:	612c      	str	r4, [r5, #16]
}
 1003b28:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
 1003b2a:	f06f 0015 	mvn.w	r0, #21
 1003b2e:	e7fb      	b.n	1003b28 <onoff_manager_init+0x1e>

01003b30 <encode_uint>:
{
 1003b30:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1003b34:	469a      	mov	sl, r3
	bool upcase = isupper((int)conv->specifier);
 1003b36:	78d3      	ldrb	r3, [r2, #3]
{
 1003b38:	4680      	mov	r8, r0
	switch (specifier) {
 1003b3a:	2b6f      	cmp	r3, #111	; 0x6f
{
 1003b3c:	460f      	mov	r7, r1
 1003b3e:	4615      	mov	r5, r2
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
 1003b40:	f1a3 0b41 	sub.w	fp, r3, #65	; 0x41
	switch (specifier) {
 1003b44:	d029      	beq.n	1003b9a <encode_uint+0x6a>
 1003b46:	d824      	bhi.n	1003b92 <encode_uint+0x62>
		return 16;
 1003b48:	2b58      	cmp	r3, #88	; 0x58
 1003b4a:	bf14      	ite	ne
 1003b4c:	260a      	movne	r6, #10
 1003b4e:	2610      	moveq	r6, #16
	char *bp = bps + (bpe - bps);
 1003b50:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
		unsigned int lsv = (unsigned int)(value % radix);
 1003b54:	4632      	mov	r2, r6
 1003b56:	2300      	movs	r3, #0
 1003b58:	4640      	mov	r0, r8
 1003b5a:	4639      	mov	r1, r7
 1003b5c:	f7fc fb70 	bl	1000240 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
 1003b60:	2a09      	cmp	r2, #9
 1003b62:	b2d4      	uxtb	r4, r2
 1003b64:	d81e      	bhi.n	1003ba4 <encode_uint+0x74>
 1003b66:	3430      	adds	r4, #48	; 0x30
	} while ((value != 0) && (bps < bp));
 1003b68:	45b0      	cmp	r8, r6
		*--bp = (lsv <= 9) ? ('0' + lsv)
 1003b6a:	b2e4      	uxtb	r4, r4
	} while ((value != 0) && (bps < bp));
 1003b6c:	f177 0300 	sbcs.w	r3, r7, #0
		*--bp = (lsv <= 9) ? ('0' + lsv)
 1003b70:	f809 4d01 	strb.w	r4, [r9, #-1]!
	} while ((value != 0) && (bps < bp));
 1003b74:	d301      	bcc.n	1003b7a <encode_uint+0x4a>
 1003b76:	45d1      	cmp	r9, sl
 1003b78:	d811      	bhi.n	1003b9e <encode_uint+0x6e>
	if (conv->flag_hash) {
 1003b7a:	782b      	ldrb	r3, [r5, #0]
 1003b7c:	069b      	lsls	r3, r3, #26
 1003b7e:	d505      	bpl.n	1003b8c <encode_uint+0x5c>
		if (radix == 8) {
 1003b80:	2e08      	cmp	r6, #8
 1003b82:	d115      	bne.n	1003bb0 <encode_uint+0x80>
			conv->altform_0 = true;
 1003b84:	78ab      	ldrb	r3, [r5, #2]
 1003b86:	f043 0308 	orr.w	r3, r3, #8
			conv->altform_0c = true;
 1003b8a:	70ab      	strb	r3, [r5, #2]
}
 1003b8c:	4648      	mov	r0, r9
 1003b8e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (specifier) {
 1003b92:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		return 16;
 1003b96:	2b70      	cmp	r3, #112	; 0x70
 1003b98:	e7d7      	b.n	1003b4a <encode_uint+0x1a>
	switch (specifier) {
 1003b9a:	2608      	movs	r6, #8
 1003b9c:	e7d8      	b.n	1003b50 <encode_uint+0x20>
		value /= radix;
 1003b9e:	4680      	mov	r8, r0
 1003ba0:	460f      	mov	r7, r1
 1003ba2:	e7d7      	b.n	1003b54 <encode_uint+0x24>
		*--bp = (lsv <= 9) ? ('0' + lsv)
 1003ba4:	f1bb 0f19 	cmp.w	fp, #25
 1003ba8:	bf94      	ite	ls
 1003baa:	3437      	addls	r4, #55	; 0x37
 1003bac:	3457      	addhi	r4, #87	; 0x57
 1003bae:	e7db      	b.n	1003b68 <encode_uint+0x38>
		} else if (radix == 16) {
 1003bb0:	2e10      	cmp	r6, #16
 1003bb2:	d1eb      	bne.n	1003b8c <encode_uint+0x5c>
			conv->altform_0c = true;
 1003bb4:	78ab      	ldrb	r3, [r5, #2]
 1003bb6:	f043 0310 	orr.w	r3, r3, #16
 1003bba:	e7e6      	b.n	1003b8a <encode_uint+0x5a>

01003bbc <outs>:
{
 1003bbc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1003bc0:	4607      	mov	r7, r0
 1003bc2:	4688      	mov	r8, r1
 1003bc4:	4615      	mov	r5, r2
 1003bc6:	461e      	mov	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
 1003bc8:	4614      	mov	r4, r2
 1003bca:	42b4      	cmp	r4, r6
 1003bcc:	eba4 0005 	sub.w	r0, r4, r5
 1003bd0:	d302      	bcc.n	1003bd8 <outs+0x1c>
 1003bd2:	b93e      	cbnz	r6, 1003be4 <outs+0x28>
 1003bd4:	7823      	ldrb	r3, [r4, #0]
 1003bd6:	b12b      	cbz	r3, 1003be4 <outs+0x28>
		int rc = out((int)*sp++, ctx);
 1003bd8:	4641      	mov	r1, r8
 1003bda:	f814 0b01 	ldrb.w	r0, [r4], #1
 1003bde:	47b8      	blx	r7
		if (rc < 0) {
 1003be0:	2800      	cmp	r0, #0
 1003be2:	daf2      	bge.n	1003bca <outs+0xe>
}
 1003be4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

01003be8 <assert_post_action>:
	if (k_is_user_context()) {
		k_oops();
	}
#endif

	k_panic();
 1003be8:	4040      	eors	r0, r0
 1003bea:	f380 8811 	msr	BASEPRI, r0
 1003bee:	f04f 0004 	mov.w	r0, #4
 1003bf2:	df02      	svc	2
}
 1003bf4:	4770      	bx	lr

01003bf6 <assert_print>:

void assert_print(const char *fmt, ...)
{
 1003bf6:	b40f      	push	{r0, r1, r2, r3}
 1003bf8:	b507      	push	{r0, r1, r2, lr}
 1003bfa:	a904      	add	r1, sp, #16
 1003bfc:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list ap;

	va_start(ap, fmt);
 1003c00:	9101      	str	r1, [sp, #4]

	vprintk(fmt, ap);
 1003c02:	f7fd f86f 	bl	1000ce4 <vprintk>

	va_end(ap);
}
 1003c06:	b003      	add	sp, #12
 1003c08:	f85d eb04 	ldr.w	lr, [sp], #4
 1003c0c:	b004      	add	sp, #16
 1003c0e:	4770      	bx	lr

01003c10 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_WARN_DEPRECATED, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_ENFORCE_ZEPHYR_STDINT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_LEGACY_INCLUDE_PATH, 1);

GEN_ABS_SYM_END
 1003c10:	4770      	bx	lr

01003c12 <z_log_minimal_printk>:
#include <zephyr/sys/printk.h>

#define HEXDUMP_BYTES_IN_LINE 8U

void z_log_minimal_printk(const char *fmt, ...)
{
 1003c12:	b40f      	push	{r0, r1, r2, r3}
 1003c14:	b507      	push	{r0, r1, r2, lr}
 1003c16:	a904      	add	r1, sp, #16
 1003c18:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list ap;

	va_start(ap, fmt);
 1003c1c:	9101      	str	r1, [sp, #4]
	vprintk(fmt, ap);
 1003c1e:	f7fd f861 	bl	1000ce4 <vprintk>
	va_end(ap);
}
 1003c22:	b003      	add	sp, #12
 1003c24:	f85d eb04 	ldr.w	lr, [sp], #4
 1003c28:	b004      	add	sp, #16
 1003c2a:	4770      	bx	lr

01003c2c <flash_get_write_block_size>:

extern size_t z_impl_flash_get_write_block_size(const struct device * dev);

__pinned_func
static inline size_t flash_get_write_block_size(const struct device * dev)
{
 1003c2c:	b508      	push	{r3, lr}
	return api->get_parameters(dev)->write_block_size;
 1003c2e:	6883      	ldr	r3, [r0, #8]
 1003c30:	68db      	ldr	r3, [r3, #12]
 1003c32:	4798      	blx	r3
		return (size_t) arch_syscall_invoke1(parm0.x, K_SYSCALL_FLASH_GET_WRITE_BLOCK_SIZE);
	}
#endif
	compiler_barrier();
	return z_impl_flash_get_write_block_size(dev);
}
 1003c34:	6800      	ldr	r0, [r0, #0]
 1003c36:	bd08      	pop	{r3, pc}

01003c38 <stream_flash_buffered_write>:
{
 1003c38:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1003c3c:	4689      	mov	r9, r1
 1003c3e:	4616      	mov	r6, r2
 1003c40:	4698      	mov	r8, r3
	if (!ctx) {
 1003c42:	4604      	mov	r4, r0
 1003c44:	b398      	cbz	r0, 1003cae <stream_flash_buffered_write+0x76>
	if (ctx->bytes_written + ctx->buf_bytes + len > ctx->available) {
 1003c46:	6882      	ldr	r2, [r0, #8]
 1003c48:	6903      	ldr	r3, [r0, #16]
 1003c4a:	4413      	add	r3, r2
 1003c4c:	6982      	ldr	r2, [r0, #24]
 1003c4e:	4433      	add	r3, r6
 1003c50:	4293      	cmp	r3, r2
 1003c52:	d830      	bhi.n	1003cb6 <stream_flash_buffered_write+0x7e>
	int processed = 0;
 1003c54:	2500      	movs	r5, #0
	       (buf_empty_bytes = ctx->buf_len - ctx->buf_bytes)) {
 1003c56:	e9d4 7001 	ldrd	r7, r0, [r4, #4]
	while ((len - processed) >=
 1003c5a:	eba6 0a05 	sub.w	sl, r6, r5
	       (buf_empty_bytes = ctx->buf_len - ctx->buf_bytes)) {
 1003c5e:	1a3f      	subs	r7, r7, r0
	while ((len - processed) >=
 1003c60:	45ba      	cmp	sl, r7
 1003c62:	d215      	bcs.n	1003c90 <stream_flash_buffered_write+0x58>
	if (processed < len) {
 1003c64:	42b5      	cmp	r5, r6
 1003c66:	d209      	bcs.n	1003c7c <stream_flash_buffered_write+0x44>
		memcpy(ctx->buf + ctx->buf_bytes,
 1003c68:	6823      	ldr	r3, [r4, #0]
 1003c6a:	4652      	mov	r2, sl
 1003c6c:	4418      	add	r0, r3
 1003c6e:	eb09 0105 	add.w	r1, r9, r5
 1003c72:	f000 f855 	bl	1003d20 <memcpy>
		ctx->buf_bytes += len - processed;
 1003c76:	68a3      	ldr	r3, [r4, #8]
 1003c78:	4453      	add	r3, sl
 1003c7a:	60a3      	str	r3, [r4, #8]
	if (flush && ctx->buf_bytes > 0) {
 1003c7c:	f1b8 0f00 	cmp.w	r8, #0
 1003c80:	d01c      	beq.n	1003cbc <stream_flash_buffered_write+0x84>
 1003c82:	68a0      	ldr	r0, [r4, #8]
 1003c84:	b1a8      	cbz	r0, 1003cb2 <stream_flash_buffered_write+0x7a>
		rc = flash_sync(ctx);
 1003c86:	4620      	mov	r0, r4
}
 1003c88:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		rc = flash_sync(ctx);
 1003c8c:	f7fd be38 	b.w	1001900 <flash_sync>
		memcpy(ctx->buf + ctx->buf_bytes, data + processed,
 1003c90:	6823      	ldr	r3, [r4, #0]
 1003c92:	463a      	mov	r2, r7
 1003c94:	4418      	add	r0, r3
 1003c96:	eb09 0105 	add.w	r1, r9, r5
 1003c9a:	f000 f841 	bl	1003d20 <memcpy>
		ctx->buf_bytes = ctx->buf_len;
 1003c9e:	6863      	ldr	r3, [r4, #4]
		rc = flash_sync(ctx);
 1003ca0:	4620      	mov	r0, r4
		ctx->buf_bytes = ctx->buf_len;
 1003ca2:	60a3      	str	r3, [r4, #8]
		rc = flash_sync(ctx);
 1003ca4:	f7fd fe2c 	bl	1001900 <flash_sync>
		if (rc != 0) {
 1003ca8:	b918      	cbnz	r0, 1003cb2 <stream_flash_buffered_write+0x7a>
		processed += buf_empty_bytes;
 1003caa:	443d      	add	r5, r7
 1003cac:	e7d3      	b.n	1003c56 <stream_flash_buffered_write+0x1e>
		return -EFAULT;
 1003cae:	f06f 000d 	mvn.w	r0, #13
}
 1003cb2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return -ENOMEM;
 1003cb6:	f06f 000b 	mvn.w	r0, #11
 1003cba:	e7fa      	b.n	1003cb2 <stream_flash_buffered_write+0x7a>
 1003cbc:	4640      	mov	r0, r8
 1003cbe:	e7f8      	b.n	1003cb2 <stream_flash_buffered_write+0x7a>

01003cc0 <z_do_kernel_oops>:
 *
 * @param esf exception frame
 * @param callee_regs Callee-saved registers (R4-R11)
 */
void z_do_kernel_oops(const z_arch_esf_t *esf, _callee_saved_t *callee_regs)
{
 1003cc0:	4601      	mov	r1, r0
	}

#endif /* CONFIG_USERSPACE */

#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	z_arm_fatal_error(reason, esf);
 1003cc2:	6800      	ldr	r0, [r0, #0]
 1003cc4:	f7fd bef2 	b.w	1001aac <z_arm_fatal_error>

01003cc8 <z_irq_spurious>:
 */
void z_irq_spurious(const void *unused)
{
	ARG_UNUSED(unused);

	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
 1003cc8:	2100      	movs	r1, #0
 1003cca:	2001      	movs	r0, #1
 1003ccc:	f7fd beee 	b.w	1001aac <z_arm_fatal_error>

01003cd0 <z_arm_nmi>:
 * Simply call what is installed in 'static void(*handler)(void)'.
 *
 */

void z_arm_nmi(void)
{
 1003cd0:	b508      	push	{r3, lr}
	handler();
 1003cd2:	f7fd ff5d 	bl	1001b90 <z_SysNmiOnReset>
	z_arm_int_exit();
}
 1003cd6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
 1003cda:	f7fd bfb5 	b.w	1001c48 <z_arm_exc_exit>

01003cde <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
 1003cde:	4603      	mov	r3, r0
	size_t n = 0;
 1003ce0:	2000      	movs	r0, #0

	while (*s != '\0') {
 1003ce2:	5c1a      	ldrb	r2, [r3, r0]
 1003ce4:	b902      	cbnz	r2, 1003ce8 <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
 1003ce6:	4770      	bx	lr
		n++;
 1003ce8:	3001      	adds	r0, #1
 1003cea:	e7fa      	b.n	1003ce2 <strlen+0x4>

01003cec <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
 1003cec:	4603      	mov	r3, r0
	size_t n = 0;
 1003cee:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
 1003cf0:	5c1a      	ldrb	r2, [r3, r0]
 1003cf2:	b10a      	cbz	r2, 1003cf8 <strnlen+0xc>
 1003cf4:	4288      	cmp	r0, r1
 1003cf6:	d100      	bne.n	1003cfa <strnlen+0xe>
		s++;
		n++;
	}

	return n;
}
 1003cf8:	4770      	bx	lr
		n++;
 1003cfa:	3001      	adds	r0, #1
 1003cfc:	e7f8      	b.n	1003cf0 <strnlen+0x4>

01003cfe <memcmp>:
 * @brief Compare two memory areas
 *
 * @return negative # if <m1> < <m2>, 0 if <m1> == <m2>, else positive #
 */
int memcmp(const void *m1, const void *m2, size_t n)
{
 1003cfe:	4603      	mov	r3, r0
 1003d00:	b510      	push	{r4, lr}
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
 1003d02:	b15a      	cbz	r2, 1003d1c <memcmp+0x1e>
 1003d04:	3901      	subs	r1, #1
 1003d06:	1884      	adds	r4, r0, r2
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
 1003d08:	f813 0b01 	ldrb.w	r0, [r3], #1
 1003d0c:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 1003d10:	42a3      	cmp	r3, r4
 1003d12:	d001      	beq.n	1003d18 <memcmp+0x1a>
 1003d14:	4290      	cmp	r0, r2
 1003d16:	d0f7      	beq.n	1003d08 <memcmp+0xa>
		c1++;
		c2++;
	}

	return *c1 - *c2;
 1003d18:	1a80      	subs	r0, r0, r2
}
 1003d1a:	bd10      	pop	{r4, pc}
		return 0;
 1003d1c:	4610      	mov	r0, r2
 1003d1e:	e7fc      	b.n	1003d1a <memcmp+0x1c>

01003d20 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *ZRESTRICT d, const void *ZRESTRICT s, size_t n)
{
 1003d20:	b510      	push	{r4, lr}
 1003d22:	1e43      	subs	r3, r0, #1
 1003d24:	440a      	add	r2, r1
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
 1003d26:	4291      	cmp	r1, r2
 1003d28:	d100      	bne.n	1003d2c <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
 1003d2a:	bd10      	pop	{r4, pc}
		*(d_byte++) = *(s_byte++);
 1003d2c:	f811 4b01 	ldrb.w	r4, [r1], #1
 1003d30:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
 1003d34:	e7f7      	b.n	1003d26 <memcpy+0x6>

01003d36 <memset>:

void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
 1003d36:	4603      	mov	r3, r0
	unsigned char c_byte = (unsigned char)c;
 1003d38:	b2c9      	uxtb	r1, r1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
 1003d3a:	4402      	add	r2, r0
 1003d3c:	4293      	cmp	r3, r2
 1003d3e:	d100      	bne.n	1003d42 <memset+0xc>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
 1003d40:	4770      	bx	lr
		*(d_byte++) = c_byte;
 1003d42:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
 1003d46:	e7f9      	b.n	1003d3c <memset+0x6>

01003d48 <set_on_state>:
 1003d48:	f04f 0320 	mov.w	r3, #32
 1003d4c:	f3ef 8211 	mrs	r2, BASEPRI
 1003d50:	f383 8812 	msr	BASEPRI_MAX, r3
 1003d54:	f3bf 8f6f 	isb	sy
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
 1003d58:	6803      	ldr	r3, [r0, #0]
 1003d5a:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 1003d5e:	f043 0302 	orr.w	r3, r3, #2
 1003d62:	6003      	str	r3, [r0, #0]
	__asm__ volatile(
 1003d64:	f382 8811 	msr	BASEPRI, r2
 1003d68:	f3bf 8f6f 	isb	sy
}
 1003d6c:	4770      	bx	lr

01003d6e <async_start>:
{
 1003d6e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1003d70:	9f06      	ldr	r7, [sp, #24]
 1003d72:	4605      	mov	r5, r0
	struct nrf_clock_control_data *data = dev->data;
 1003d74:	6904      	ldr	r4, [r0, #16]
	return &data->subsys[type];
 1003d76:	b2c9      	uxtb	r1, r1
	__asm__ volatile(
 1003d78:	f04f 0020 	mov.w	r0, #32
 1003d7c:	f3ef 8c11 	mrs	ip, BASEPRI
 1003d80:	f380 8812 	msr	BASEPRI_MAX, r0
 1003d84:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
 1003d88:	260c      	movs	r6, #12
 1003d8a:	fb06 4601 	mla	r6, r6, r1, r4
 1003d8e:	6c30      	ldr	r0, [r6, #64]	; 0x40
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
 1003d90:	f000 0e07 	and.w	lr, r0, #7
 1003d94:	f1be 0f01 	cmp.w	lr, #1
 1003d98:	d110      	bne.n	1003dbc <async_start+0x4e>
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
 1003d9a:	6437      	str	r7, [r6, #64]	; 0x40
	int err = 0;
 1003d9c:	2600      	movs	r6, #0
	__asm__ volatile(
 1003d9e:	f38c 8811 	msr	BASEPRI, ip
 1003da2:	f3bf 8f6f 	isb	sy
	if (err < 0) {
 1003da6:	b93e      	cbnz	r6, 1003db8 <async_start+0x4a>
	subdata->cb = cb;
 1003da8:	200c      	movs	r0, #12
 1003daa:	4341      	muls	r1, r0
 1003dac:	440c      	add	r4, r1
	subdata->user_data = user_data;
 1003dae:	e9c4 230e 	strd	r2, r3, [r4, #56]	; 0x38
	 get_sub_config(dev, type)->start();
 1003db2:	686b      	ldr	r3, [r5, #4]
 1003db4:	585b      	ldr	r3, [r3, r1]
 1003db6:	4798      	blx	r3
}
 1003db8:	4630      	mov	r0, r6
 1003dba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	uint32_t current_ctx = GET_CTX(*flags);
 1003dbc:	f000 00c0 	and.w	r0, r0, #192	; 0xc0
		err = -EALREADY;
 1003dc0:	4287      	cmp	r7, r0
 1003dc2:	bf14      	ite	ne
 1003dc4:	f04f 36ff 	movne.w	r6, #4294967295
 1003dc8:	f06f 0677 	mvneq.w	r6, #119	; 0x77
 1003dcc:	e7e7      	b.n	1003d9e <async_start+0x30>

01003dce <api_start>:
{
 1003dce:	b513      	push	{r0, r1, r4, lr}
	return async_start(dev, subsys, cb, user_data, CTX_API);
 1003dd0:	2480      	movs	r4, #128	; 0x80
 1003dd2:	9400      	str	r4, [sp, #0]
 1003dd4:	f7ff ffcb 	bl	1003d6e <async_start>
}
 1003dd8:	b002      	add	sp, #8
 1003dda:	bd10      	pop	{r4, pc}

01003ddc <api_blocking_start>:
}
 1003ddc:	f06f 0085 	mvn.w	r0, #133	; 0x85
 1003de0:	4770      	bx	lr

01003de2 <onoff_started_callback>:
{
 1003de2:	b410      	push	{r4}
	notify(mgr, 0);
 1003de4:	241c      	movs	r4, #28
	return &data->mgr[type];
 1003de6:	6900      	ldr	r0, [r0, #16]
 1003de8:	b2cb      	uxtb	r3, r1
	notify(mgr, 0);
 1003dea:	fb03 0004 	mla	r0, r3, r4, r0
 1003dee:	2100      	movs	r1, #0
}
 1003df0:	bc10      	pop	{r4}
	notify(mgr, 0);
 1003df2:	4710      	bx	r2

01003df4 <lfclk_start>:
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
 1003df4:	2000      	movs	r0, #0
 1003df6:	f7ff bad7 	b.w	10033a8 <nrfx_clock_start>

01003dfa <lfclk_stop>:
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
 1003dfa:	2000      	movs	r0, #0
 1003dfc:	f7ff bb36 	b.w	100346c <nrfx_clock_stop>

01003e00 <api_stop>:
	return stop(dev, subsys, CTX_API);
 1003e00:	2280      	movs	r2, #128	; 0x80
 1003e02:	f7fe b9ef 	b.w	10021e4 <stop>

01003e06 <is_regular_addr_valid>:
{
 1003e06:	b538      	push	{r3, r4, r5, lr}
 1003e08:	4605      	mov	r5, r0
 1003e0a:	460c      	mov	r4, r1
	return is_within_bounds(addr, len, 0, nrfx_nvmc_flash_size_get());
 1003e0c:	f000 f914 	bl	1004038 <nrfx_nvmc_flash_size_get>
			(addr < (boundary_start + boundary_size)) &&
 1003e10:	2d00      	cmp	r5, #0
 1003e12:	db07      	blt.n	1003e24 <is_regular_addr_valid+0x1e>
	return (addr >= boundary_start &&
 1003e14:	42a8      	cmp	r0, r5
 1003e16:	d905      	bls.n	1003e24 <is_regular_addr_valid+0x1e>
			(len <= (boundary_start + boundary_size - addr)));
 1003e18:	1b40      	subs	r0, r0, r5
			(addr < (boundary_start + boundary_size)) &&
 1003e1a:	4284      	cmp	r4, r0
 1003e1c:	bf8c      	ite	hi
 1003e1e:	2000      	movhi	r0, #0
 1003e20:	2001      	movls	r0, #1
}
 1003e22:	bd38      	pop	{r3, r4, r5, pc}
			(addr < (boundary_start + boundary_size)) &&
 1003e24:	2000      	movs	r0, #0
 1003e26:	e7fc      	b.n	1003e22 <is_regular_addr_valid+0x1c>

01003e28 <flash_get_page_info>:

#include <zephyr/drivers/flash.h>

static int flash_get_page_info(const struct device *dev, off_t offs,
			       uint32_t index, struct flash_pages_info *info)
{
 1003e28:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 1003e2c:	461c      	mov	r4, r3
	const struct flash_driver_api *api = dev->api;
	const struct flash_pages_layout *layout;
	size_t layout_size;
	uint32_t index_jmp;

	info->start_offset = 0;
 1003e2e:	f04f 0800 	mov.w	r8, #0
	const struct flash_driver_api *api = dev->api;
 1003e32:	6883      	ldr	r3, [r0, #8]
{
 1003e34:	460d      	mov	r5, r1
 1003e36:	4616      	mov	r6, r2
	info->index = 0U;

	api->page_layout(dev, &layout, &layout_size);
 1003e38:	4669      	mov	r1, sp
 1003e3a:	691b      	ldr	r3, [r3, #16]
	info->start_offset = 0;
 1003e3c:	f8c4 8000 	str.w	r8, [r4]
	info->index = 0U;
 1003e40:	f8c4 8008 	str.w	r8, [r4, #8]
	api->page_layout(dev, &layout, &layout_size);
 1003e44:	aa01      	add	r2, sp, #4
 1003e46:	4798      	blx	r3

	while (layout_size--) {
 1003e48:	e9dd 7c00 	ldrd	r7, ip, [sp]
 1003e4c:	4640      	mov	r0, r8
		info->size = layout->pages_size;
 1003e4e:	f107 0e04 	add.w	lr, r7, #4
	while (layout_size--) {
 1003e52:	4560      	cmp	r0, ip
 1003e54:	d104      	bne.n	1003e60 <flash_get_page_info+0x38>
		}

		layout++;
	}

	return -EINVAL; /* page at offs or idx doesn't exist */
 1003e56:	f06f 0015 	mvn.w	r0, #21
}
 1003e5a:	b003      	add	sp, #12
 1003e5c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		info->size = layout->pages_size;
 1003e60:	f85e 9030 	ldr.w	r9, [lr, r0, lsl #3]
			index_jmp = index - info->index;
 1003e64:	68a1      	ldr	r1, [r4, #8]
			index_jmp = (offs - info->start_offset) / info->size;
 1003e66:	6822      	ldr	r2, [r4, #0]
		info->size = layout->pages_size;
 1003e68:	f8c4 9004 	str.w	r9, [r4, #4]
		if (offs == 0) {
 1003e6c:	b97d      	cbnz	r5, 1003e8e <flash_get_page_info+0x66>
			index_jmp = index - info->index;
 1003e6e:	1a73      	subs	r3, r6, r1
		index_jmp = MIN(index_jmp, layout->pages_count);
 1003e70:	f857 8030 	ldr.w	r8, [r7, r0, lsl #3]
		if (index_jmp < layout->pages_count) {
 1003e74:	3001      	adds	r0, #1
		index_jmp = MIN(index_jmp, layout->pages_count);
 1003e76:	4543      	cmp	r3, r8
 1003e78:	bf28      	it	cs
 1003e7a:	4643      	movcs	r3, r8
		info->start_offset += (index_jmp * info->size);
 1003e7c:	fb03 2209 	mla	r2, r3, r9, r2
		info->index += index_jmp;
 1003e80:	4419      	add	r1, r3
		if (index_jmp < layout->pages_count) {
 1003e82:	4598      	cmp	r8, r3
		info->start_offset += (index_jmp * info->size);
 1003e84:	6022      	str	r2, [r4, #0]
		info->index += index_jmp;
 1003e86:	60a1      	str	r1, [r4, #8]
		if (index_jmp < layout->pages_count) {
 1003e88:	d9e3      	bls.n	1003e52 <flash_get_page_info+0x2a>
			return 0;
 1003e8a:	2000      	movs	r0, #0
 1003e8c:	e7e5      	b.n	1003e5a <flash_get_page_info+0x32>
			index_jmp = (offs - info->start_offset) / info->size;
 1003e8e:	1aab      	subs	r3, r5, r2
 1003e90:	fbb3 f3f9 	udiv	r3, r3, r9
 1003e94:	e7ec      	b.n	1003e70 <flash_get_page_info+0x48>

01003e96 <z_impl_flash_get_page_info_by_offs>:

int z_impl_flash_get_page_info_by_offs(const struct device *dev, off_t offs,
				       struct flash_pages_info *info)
{
 1003e96:	4613      	mov	r3, r2
	return flash_get_page_info(dev, offs, 0U, info);
 1003e98:	2200      	movs	r2, #0
 1003e9a:	f7ff bfc5 	b.w	1003e28 <flash_get_page_info>

01003e9e <flash_page_foreach>:
	return count;
}

void flash_page_foreach(const struct device *dev, flash_page_cb cb,
			void *data)
{
 1003e9e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	const struct flash_driver_api *api = dev->api;
	const struct flash_pages_layout *layout;
	struct flash_pages_info page_info;
	size_t block, num_blocks, page = 0, i;
	off_t off = 0;
 1003ea2:	2400      	movs	r4, #0

	api->page_layout(dev, &layout, &num_blocks);
 1003ea4:	6883      	ldr	r3, [r0, #8]
{
 1003ea6:	b086      	sub	sp, #24
 1003ea8:	4688      	mov	r8, r1
 1003eaa:	4691      	mov	r9, r2
	api->page_layout(dev, &layout, &num_blocks);
 1003eac:	691b      	ldr	r3, [r3, #16]
 1003eae:	aa02      	add	r2, sp, #8
 1003eb0:	a901      	add	r1, sp, #4
 1003eb2:	4798      	blx	r3
	size_t block, num_blocks, page = 0, i;
 1003eb4:	46a2      	mov	sl, r4

	for (block = 0; block < num_blocks; block++) {
 1003eb6:	4625      	mov	r5, r4
 1003eb8:	9b02      	ldr	r3, [sp, #8]
 1003eba:	42ab      	cmp	r3, r5
 1003ebc:	d802      	bhi.n	1003ec4 <flash_page_foreach+0x26>

			off += page_info.size;
			page++;
		}
	}
}
 1003ebe:	b006      	add	sp, #24
 1003ec0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		for (i = 0; i < l->pages_count; i++) {
 1003ec4:	2600      	movs	r6, #0
		const struct flash_pages_layout *l = &layout[block];
 1003ec6:	9f01      	ldr	r7, [sp, #4]
 1003ec8:	eb07 07c5 	add.w	r7, r7, r5, lsl #3
		page_info.size = l->pages_size;
 1003ecc:	687b      	ldr	r3, [r7, #4]
 1003ece:	9304      	str	r3, [sp, #16]
		for (i = 0; i < l->pages_count; i++) {
 1003ed0:	683a      	ldr	r2, [r7, #0]
 1003ed2:	eb0a 0306 	add.w	r3, sl, r6
 1003ed6:	42b2      	cmp	r2, r6
 1003ed8:	d802      	bhi.n	1003ee0 <flash_page_foreach+0x42>
	for (block = 0; block < num_blocks; block++) {
 1003eda:	469a      	mov	sl, r3
 1003edc:	3501      	adds	r5, #1
 1003ede:	e7eb      	b.n	1003eb8 <flash_page_foreach+0x1a>
			if (!cb(&page_info, data)) {
 1003ee0:	4649      	mov	r1, r9
 1003ee2:	a803      	add	r0, sp, #12
			page_info.start_offset = off;
 1003ee4:	9403      	str	r4, [sp, #12]
			page_info.index = page;
 1003ee6:	9305      	str	r3, [sp, #20]
			if (!cb(&page_info, data)) {
 1003ee8:	47c0      	blx	r8
 1003eea:	2800      	cmp	r0, #0
 1003eec:	d0e7      	beq.n	1003ebe <flash_page_foreach+0x20>
			off += page_info.size;
 1003eee:	9b04      	ldr	r3, [sp, #16]
		for (i = 0; i < l->pages_count; i++) {
 1003ef0:	3601      	adds	r6, #1
			off += page_info.size;
 1003ef2:	441c      	add	r4, r3
		for (i = 0; i < l->pages_count; i++) {
 1003ef4:	e7ec      	b.n	1003ed0 <flash_page_foreach+0x32>

01003ef6 <sys_clock_set_timeout>:
}
 1003ef6:	4770      	bx	lr

01003ef8 <sys_clock_elapsed>:
}
 1003ef8:	2000      	movs	r0, #0
 1003efa:	4770      	bx	lr

01003efc <fprotect_area>:
	return 0;
}

int fprotect_area(uint32_t start, size_t length)
{
	return fprotect_set_permission(start, length,
 1003efc:	2202      	movs	r2, #2
 1003efe:	f7fe bdf3 	b.w	1002ae8 <fprotect_set_permission>

01003f02 <crypto_init_signing>:


__weak int crypto_init_signing(void)
{
	return 0;
}
 1003f02:	2000      	movs	r0, #0
 1003f04:	4770      	bx	lr

01003f06 <crypto_init_hash>:
 1003f06:	2000      	movs	r0, #0
 1003f08:	4770      	bx	lr

01003f0a <bl_crypto_init>:
{
	return 0;
}

int bl_crypto_init(void)
{
 1003f0a:	b508      	push	{r3, lr}
	int retval = crypto_init_signing();
 1003f0c:	f7ff fff9 	bl	1003f02 <crypto_init_signing>
	if (retval) {
 1003f10:	b908      	cbnz	r0, 1003f16 <bl_crypto_init+0xc>
		return retval;
	}

	return crypto_init_hash();
 1003f12:	f7ff fff8 	bl	1003f06 <crypto_init_hash>
}
 1003f16:	bd08      	pop	{r3, pc}

01003f18 <bl_sha256_verify>:
					firmware, firmware_len, true);
}

#ifndef CONFIG_BL_SHA256_EXT_API_REQUIRED
int bl_sha256_verify(const uint8_t *data, uint32_t data_len, const uint8_t *expected)
{
 1003f18:	b530      	push	{r4, r5, lr}
 1003f1a:	b089      	sub	sp, #36	; 0x24
 1003f1c:	4615      	mov	r5, r2
	int retval = get_hash(hash, data, data_len, external);
 1003f1e:	2301      	movs	r3, #1
 1003f20:	460a      	mov	r2, r1
 1003f22:	4601      	mov	r1, r0
 1003f24:	4668      	mov	r0, sp
 1003f26:	f000 f80e 	bl	1003f46 <get_hash>
	if (retval != 0) {
 1003f2a:	4604      	mov	r4, r0
 1003f2c:	b940      	cbnz	r0, 1003f40 <bl_sha256_verify+0x28>
	if (!ocrypto_constant_time_equal(expected, hash, hash_len)) {
 1003f2e:	2220      	movs	r2, #32
 1003f30:	4669      	mov	r1, sp
 1003f32:	4628      	mov	r0, r5
 1003f34:	f7fc f99e 	bl	1000274 <ocrypto_constant_time_equal>
		return -EHASHINV;
 1003f38:	2800      	cmp	r0, #0
 1003f3a:	bf08      	it	eq
 1003f3c:	f06f 0464 	mvneq.w	r4, #100	; 0x64
	return verify_truncated_hash(data, data_len, expected, CONFIG_SB_HASH_LEN, true);
}
 1003f40:	4620      	mov	r0, r4
 1003f42:	b009      	add	sp, #36	; 0x24
 1003f44:	bd30      	pop	{r4, r5, pc}

01003f46 <get_hash>:

BUILD_ASSERT(SHA256_CTX_SIZE >= sizeof(ocrypto_sha256_ctx), \
		"ocrypto_sha256_ctx can no longer fit inside bl_sha256_ctx_t.");

int get_hash(uint8_t *hash, const uint8_t *data, uint32_t data_len, bool external)
{
 1003f46:	b508      	push	{r3, lr}
	(void) external;
	ocrypto_sha256(hash, data, data_len);
 1003f48:	f7fc fcae 	bl	10008a8 <ocrypto_sha256>

	/* Return success always as ocrypto_sha256 does not have a return value. */
	return 0;
}
 1003f4c:	2000      	movs	r0, #0
 1003f4e:	bd08      	pop	{r3, pc}

01003f50 <bl_validate_firmware>:


bool bl_validate_firmware(uint32_t fw_dst_address, uint32_t fw_src_address)
{
 1003f50:	b570      	push	{r4, r5, r6, lr}
 1003f52:	4605      	mov	r5, r0
	return validate_firmware(fw_dst_address, fw_src_address,
 1003f54:	4608      	mov	r0, r1
{
 1003f56:	460c      	mov	r4, r1
	return validate_firmware(fw_dst_address, fw_src_address,
 1003f58:	f7fe fee8 	bl	1002d2c <fw_info_find>
 1003f5c:	4621      	mov	r1, r4
 1003f5e:	4602      	mov	r2, r0
 1003f60:	2301      	movs	r3, #1
 1003f62:	4628      	mov	r0, r5
				fw_info_find(fw_src_address), true);
}
 1003f64:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return validate_firmware(fw_dst_address, fw_src_address,
 1003f68:	f7fe bef0 	b.w	1002d4c <validate_firmware>

01003f6c <read_halfword>:
	uint32_t target_addr = (uint32_t)ptr & ~3; /* Floor address */
 1003f6c:	f020 0203 	bic.w	r2, r0, #3
{
 1003f70:	4603      	mov	r3, r0
	uint32_t val32 = *(uint32_t *)target_addr;
 1003f72:	6810      	ldr	r0, [r2, #0]
  __ASM volatile ("dsb 0xF":::"memory");
 1003f74:	f3bf 8f4f 	dsb	sy
	return (top_half ? (val32 >> 16) : val32) & 0x0000FFFF;
 1003f78:	079b      	lsls	r3, r3, #30
 1003f7a:	bf14      	ite	ne
 1003f7c:	0c00      	lsrne	r0, r0, #16
 1003f7e:	b280      	uxtheq	r0, r0
}
 1003f80:	4770      	bx	lr

01003f82 <num_monotonic_counter_slots>:


uint16_t num_monotonic_counter_slots(void)
{
 1003f82:	b508      	push	{r3, lr}
	const struct monotonic_counter *counter
			= get_counter_struct(COUNTER_DESC_VERSION);
 1003f84:	f7fe ffca 	bl	1002f1c <get_counter_struct.constprop.0>
	uint16_t num_slots = 0;

	if (counter != NULL) {
 1003f88:	b908      	cbnz	r0, 1003f8e <num_monotonic_counter_slots+0xc>
	uint16_t num_slots = 0;
 1003f8a:	2000      	movs	r0, #0
		num_slots = read_halfword(&counter->num_counter_slots);
	}
	return num_slots != 0xFFFF ? num_slots : 0;
}
 1003f8c:	bd08      	pop	{r3, pc}
		num_slots = read_halfword(&counter->num_counter_slots);
 1003f8e:	3002      	adds	r0, #2
 1003f90:	f7ff ffec 	bl	1003f6c <read_halfword>
	return num_slots != 0xFFFF ? num_slots : 0;
 1003f94:	f64f 73ff 	movw	r3, #65535	; 0xffff
 1003f98:	4298      	cmp	r0, r3
 1003f9a:	d1f7      	bne.n	1003f8c <num_monotonic_counter_slots+0xa>
 1003f9c:	e7f5      	b.n	1003f8a <num_monotonic_counter_slots+0x8>

01003f9e <get_counter>:
 *
 * @return The current value of the counter (the highest value before the first
 *         free slot).
 */
static uint16_t get_counter(const uint16_t **free_slot)
{
 1003f9e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1003fa2:	4605      	mov	r5, r0
	uint16_t highest_counter = 0;
	const uint16_t *addr = NULL;
	const uint16_t *slots =
			get_counter_struct(COUNTER_DESC_VERSION)->counter_slots;
 1003fa4:	f7fe ffba 	bl	1002f1c <get_counter_struct.constprop.0>
 1003fa8:	4604      	mov	r4, r0
	uint16_t num_slots = num_monotonic_counter_slots();
 1003faa:	f7ff ffea 	bl	1003f82 <num_monotonic_counter_slots>
 1003fae:	1d21      	adds	r1, r4, #4

	for (uint32_t i = 0; i < num_slots; i++) {
 1003fb0:	2400      	movs	r4, #0
	uint16_t num_slots = num_monotonic_counter_slots();
 1003fb2:	4607      	mov	r7, r0
	uint16_t highest_counter = 0;
 1003fb4:	4626      	mov	r6, r4
	for (uint32_t i = 0; i < num_slots; i++) {
 1003fb6:	42a7      	cmp	r7, r4
 1003fb8:	d807      	bhi.n	1003fca <get_counter+0x2c>
	const uint16_t *addr = NULL;
 1003fba:	f04f 0800 	mov.w	r8, #0
		if (highest_counter < counter) {
			highest_counter = counter;
		}
	}

	if (free_slot != NULL) {
 1003fbe:	b10d      	cbz	r5, 1003fc4 <get_counter+0x26>
		*free_slot = addr;
 1003fc0:	f8c5 8000 	str.w	r8, [r5]
	}
	return highest_counter;
}
 1003fc4:	4630      	mov	r0, r6
 1003fc6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		uint16_t counter = ~read_halfword(&slots[i]);
 1003fca:	4608      	mov	r0, r1
 1003fcc:	f7ff ffce 	bl	1003f6c <read_halfword>
 1003fd0:	43c3      	mvns	r3, r0
 1003fd2:	b29b      	uxth	r3, r3
 1003fd4:	4688      	mov	r8, r1
		if (counter == 0) {
 1003fd6:	3102      	adds	r1, #2
 1003fd8:	2b00      	cmp	r3, #0
 1003fda:	d0f0      	beq.n	1003fbe <get_counter+0x20>
		if (highest_counter < counter) {
 1003fdc:	429e      	cmp	r6, r3
 1003fde:	bf38      	it	cc
 1003fe0:	461e      	movcc	r6, r3
	for (uint32_t i = 0; i < num_slots; i++) {
 1003fe2:	3401      	adds	r4, #1
 1003fe4:	e7e7      	b.n	1003fb6 <get_counter+0x18>

01003fe6 <get_monotonic_counter>:


uint16_t get_monotonic_counter(void)
{
	return get_counter(NULL);
 1003fe6:	2000      	movs	r0, #0
 1003fe8:	f7ff bfd9 	b.w	1003f9e <get_counter>

01003fec <pcd_cmd_data_ptr_get>:
}
 1003fec:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 1003ff0:	6858      	ldr	r0, [r3, #4]
 1003ff2:	4770      	bx	lr

01003ff4 <skip_ext_apis>:
{
 1003ff4:	4603      	mov	r3, r0
	for (uint32_t j = 0; j < fw_info->ext_api_num; j++) {
 1003ff6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 1003ff8:	2300      	movs	r3, #0
	const struct fw_info_ext_api *ext_api = &fw_info->ext_apis[0];
 1003ffa:	303c      	adds	r0, #60	; 0x3c
	for (uint32_t j = 0; j < fw_info->ext_api_num; j++) {
 1003ffc:	429a      	cmp	r2, r3
 1003ffe:	d100      	bne.n	1004002 <skip_ext_apis+0xe>
}
 1004000:	4770      	bx	lr
		ADVANCE_EXT_API(ext_api);
 1004002:	68c1      	ldr	r1, [r0, #12]
	for (uint32_t j = 0; j < fw_info->ext_api_num; j++) {
 1004004:	3301      	adds	r3, #1
		ADVANCE_EXT_API(ext_api);
 1004006:	4408      	add	r0, r1
	for (uint32_t j = 0; j < fw_info->ext_api_num; j++) {
 1004008:	e7f8      	b.n	1003ffc <skip_ext_apis+0x8>

0100400a <nrfx_isr>:
#include <zephyr/kernel.h>
#include <soc/nrfx_coredep.h>

void nrfx_isr(const void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
 100400a:	4700      	bx	r0

0100400c <nrfx_busy_wait>:
 100400c:	f000 b831 	b.w	1004072 <z_impl_k_busy_wait>

01004010 <is_valid_address>:
{
 1004010:	4603      	mov	r3, r0
    if ((addr - NVMC_FLASH_BASE_ADDRESS) < flash_total_size_get())
 1004012:	f103 427f 	add.w	r2, r3, #4278190080	; 0xff000000
 1004016:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
{
 100401a:	4608      	mov	r0, r1
    if ((addr - NVMC_FLASH_BASE_ADDRESS) < flash_total_size_get())
 100401c:	d30a      	bcc.n	1004034 <is_valid_address+0x24>
    if (uicr_allowed &&
 100401e:	b151      	cbz	r1, 1004036 <is_valid_address+0x26>
        (addr - (uint32_t)NRF_UICR) < sizeof(NRF_UICR_Type))
 1004020:	f103 417e 	add.w	r1, r3, #4261412864	; 0xfe000000
 1004024:	f501 4100 	add.w	r1, r1, #32768	; 0x8000
    if (uicr_allowed &&
 1004028:	f5b1 7f60 	cmp.w	r1, #896	; 0x380
 100402c:	bf2c      	ite	cs
 100402e:	2000      	movcs	r0, #0
 1004030:	2001      	movcc	r0, #1
 1004032:	4770      	bx	lr
        return true;
 1004034:	2001      	movs	r0, #1
}
 1004036:	4770      	bx	lr

01004038 <nrfx_nvmc_flash_size_get>:
}

uint32_t nrfx_nvmc_flash_size_get(void)
{
    return flash_total_size_get();
}
 1004038:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 100403c:	4770      	bx	lr

0100403e <nrfx_nvmc_flash_page_size_get>:

uint32_t nrfx_nvmc_flash_page_size_get(void)
{
    return flash_page_size_get();
}
 100403e:	f44f 6000 	mov.w	r0, #2048	; 0x800
 1004042:	4770      	bx	lr

01004044 <nrfx_nvmc_flash_page_count_get>:

uint32_t nrfx_nvmc_flash_page_count_get(void)
{
    return flash_page_count_get();
}
 1004044:	2080      	movs	r0, #128	; 0x80
 1004046:	4770      	bx	lr

01004048 <z_device_state_init>:
}
 1004048:	4770      	bx	lr

0100404a <z_device_is_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
 100404a:	b138      	cbz	r0, 100405c <z_device_is_ready+0x12>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
 100404c:	68c3      	ldr	r3, [r0, #12]
 100404e:	8818      	ldrh	r0, [r3, #0]
 1004050:	f3c0 0008 	ubfx	r0, r0, #0, #9
 1004054:	f5a0 7380 	sub.w	r3, r0, #256	; 0x100
 1004058:	4258      	negs	r0, r3
 100405a:	4158      	adcs	r0, r3
}
 100405c:	4770      	bx	lr

0100405e <z_early_memset>:
	(void) memset(dst, c, n);
 100405e:	f7ff be6a 	b.w	1003d36 <memset>

01004062 <z_early_memcpy>:
	(void) memcpy(dst, src, n);
 1004062:	f7ff be5d 	b.w	1003d20 <memcpy>

01004066 <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 1004066:	f3ef 8005 	mrs	r0, IPSR
}

bool k_is_in_isr(void)
{
	return arch_is_in_isr();
}
 100406a:	3800      	subs	r0, #0
 100406c:	bf18      	it	ne
 100406e:	2001      	movne	r0, #1
 1004070:	4770      	bx	lr

01004072 <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
 1004072:	b108      	cbz	r0, 1004078 <z_impl_k_busy_wait+0x6>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
 1004074:	f7fd bbfc 	b.w	1001870 <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
 1004078:	4770      	bx	lr

0100407a <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
 100407a:	4770      	bx	lr
